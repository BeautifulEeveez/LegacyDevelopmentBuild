
local guithingytext = ([[
KnottyEeveez_MegaCreations.11.2019
Copyright(KnottyEeveez-2019)
This isn't a glitcher anymore. It's beyond glitcher
Project Name: Legacy(Articulacy)


i got 1 2 3 4 5 6 7 8
nein nein nein nein nein nein nein.

Motivators:
The Glitcher Simulator Community - Even through tough times they've always made me feel better about myself
Salvo_Starly - Cool person. Let me use his Tween stuff
Poison_Resistance/ItzPoison - dickhead
Dreamer - They're cool. Taught me how to NOT be a espresso depresso.
Avix_G - Keeping the community a respectful place.
Aero - Been my friend from almost the beginning

And finally. You. The person using this script. By using this script you are supporting me by basically telling me that you'll
actually have a look at the script instead of judging it by it's ugly cover.

Well.. Enough of my backstory and more about the script.

1 Year Before..
Cassidy was just a normal girl but Lonely and Depressed. Forgotten by everyone and wanted change in the way she was seen in people's eyes.
In her mind she thought up about the galactic protectors.. The glitchers were the only thing on her mind in class.
At home she would study on how they obtained this destructive yet divine power. She looked up to those that she could think of.
Later that day she would design her own type of wings and core. Taking designs off of Silence, Stratospheric and Star Glitcher
All she thought that night was becoming one herself which she wanted all along. Thinking of how she could join the war between
Ruin and Glitcher and restore peace to the universe. But she was no close to that. She'd have to travel years to join them in a
endless battle. What could she do? The next morning she woke up and thought of how all of her classmates liked the Ruin more than
Glitcher and dreamt of slaying all of them for her anger and suffering. She immediately began to work on a ring with the knowledge of
programming. She would later name this Ethereal. After throwing it behind her back she felt something. Power.. Immediately she looked behind and saw
these majestic wings swaing back and fourth behind her. She tested out her new powers and began to fight.

5 Months Later. Cassidy grew tired of this worthless power with only a few attacks. She began working on something even bigger.

L E G A C Y

Note about lore: Ethereal v1 is not the ethereal I am talking about. I am talking about EGR

	
CREDITS:	
GodzPlaysRB/Wonder/KnottyEeveez - Owner/Scripter
Asari - Made the evolved wing. Also very cool person
Chat GUI originally by Salvo_Starly
Credit where credit is due. Any code from other scripters.
Leanop - CR Template

EXTRA INFORMATION:
Wielder: Cassidy Nakamura
Mood: Revengeful

rbxassetid://916843842 pitch to 3 lol

Allies:
Aprins - Reality Glitcher

Enemies/Rivals: -- In priority (Different Universes)
Jake_Davies(Derpz) - Derpz Glitcher
Cytus - Rem Cytus

------MODES------
# - WIP
* - Finished
/ - Animation Needed
A - Attack Needed
E - Effects Needed
R - Refinement Need
-----------------
Page 1 Modes:
A   SANCTUARY - Literal Nightmare Fuel
A   Exponential - Outgoing and Eager.
*   INDECENCY - An Inking Mistake.
A   Resonance - Kind and loving.
---FUTURE MODES--- In priority

---TO DO LIST--- In priority
Add a questionable attack to U-K-E

--- NOTES --- Developer Notes
Please do not skid or edit this.
]])
warn'Legacy loaded.. Bring the madness.'

wait(1)
local kan = Instance.new("Sound",char)
kan.Volume = 1.15
kan.TimePosition = 0
kan.PlaybackSpeed = 1.01
kan.Pitch = 1.01
kan.SoundId = "rbxassetid://4453518004"
kan.Name = "Legacy"
kan.Looped = true
script.EQ.Parent = kan
plr = game:GetService("Players").LocalPlayer
Player = plr
mouse = plr:GetMouse()
local entergui = script.EthLoad
local musicactive = false
entergui.Parent = plr.PlayerGui
entergui.Main.Scroll.Text.Text = guithingytext
--{0.251, 0},{0.27, 0}
entergui.Main:TweenPosition(UDim2.new(0.251, 0,0.27, 0),Enum.EasingDirection.Out,Enum.EasingStyle.Quart,2)
local nipsexist = false
local armorexist = true
entergui.Main.Options.Option2.Opti1.MouseButton1Click:Connect(function()
if(armorexist==true)then
armorexist = false
entergui.Main.Options.Option2.Opti1.Image="http://www.roblox.com/asset/?id=53252054"
elseif(armorexist==false)then
armorexist = true
entergui.Main.Options.Option2.Opti1.Image="http://www.roblox.com/asset/?id=149260637"
end
end)
entergui.Main.Options.Option1.Opti1.MouseButton1Click:Connect(function()
if(nipsexist==true)then
nipsexist = false
entergui.Main.Options.Option1.Opti1.Image="http://www.roblox.com/asset/?id=53252054"
elseif(nipsexist==false)then
nipsexist = true
entergui.Main.Options.Option1.Text = "hah you thought"
entergui.Main.Options.Option1.Opti1.Image="http://www.roblox.com/asset/?id=149260637"
end
end)
entergui.Main.Run.MouseButton1Click:Connect(function()
	kan:Play()
entergui.Main:TweenPosition(UDim2.new(-1, 0,0.27, 0),Enum.EasingDirection.Out,Enum.EasingStyle.Quart,0.7)
local Hue = 0
char = plr.Character
Character = char
hum = char.Humanoid
hum2 = Instance.new("Humanoid",game:GetService("ServerStorage"))
local cam = game.Workspace.CurrentCamera
Camera = cam
local CamInterrupt = false
local TwoD = false
local TargetInfo = {nil, nil}
cam.CameraType = "Custom"
t = char.Torso
h = char.Head
ra = char["Right Arm"]
la = char["Left Arm"]
rl = char["Right Leg"]
ll = char["Left Leg"]
tors = char.Torso
lleg = char["Left Leg"]
root = char.HumanoidRootPart
hed = char.Head
rleg = char["Right Leg"]
rarm = char["Right Arm"]
larm = char["Left Arm"]
radian = math.rad
random = math.random
Vec3 = Vector3.new
Inst = Instance.new
cFrame = CFrame.new
Euler = CFrame.fromEulerAnglesXYZ
vt = Vector3.new
bc = BrickColor.new
br = BrickColor.random
it = Instance.new
cf = CFrame.new
cos = math.cos
rad = math.rad
sin = math.sin
radm = math.random
huge = math.huge
tan = math.tan
abs = math.abs
switch = 1
local freemodelflame = script.Flame
freemodelflame.Enabled = true
function TweenAnimate(object,Aniim,time,easingstyle,easingdirection,repet,reverse,deelay)
local infos=TweenInfo.new(time,Enum.EasingStyle[easingstyle],Enum.EasingDirection[easingdirection],repet,reverse,deelay)
local tween=game:GetService("TweenService"):Create(object,infos,Aniim)
tween:Play()
return tween
end
attack = true
local cp = kan.SoundId:gsub("rbxassetid://","")
local twistedtable = {"TWISTED","TWISTED","TWISTED","TWISTED","TWISTED","TWISTED","TWISTED","TWISTED","₮̷̲́₩̵̲̐ł̶̤͠₴̷̬͝₮̷̼̌Ɇ̶̪͆Đ̴̲͐","₮̷̲́₩̵̲̐ł̶̤͠₴̷̬͝₮̷̼̌Ɇ̶̪͆Đ̴̲͐","₮̷̲́₩̵̲̐ł̶̤͠₴̷̬͝₮̷̼̌Ɇ̶̪͆Đ̴̲͐","T̸͖͝Ẇ̷̪I̴̟̓S̶̠̒Ṫ̸͎Ȅ̵̮Ḓ̸̊","T̸͖͝Ẇ̷̪I̴̟̓S̶̠̒Ṫ̸͎Ȅ̵̮Ḓ̸̊","T̸͖͝Ẇ̷̪I̴̟̓S̶̠̒Ṫ̸͎Ȅ̵̮Ḓ̸̊","T̸͖͝Ẇ̷̪I̴̟̓S̶̠̒Ṫ̸͎Ȅ̵̮Ḓ̸̊","Ț̷̪̟̮̮͓̜́̐͊̔̅̇̿͐̌̎̀͜͠͝ͅW̷͉̝̩̐̒͊͛͛̉̆̃̋̑̀̔̎̽͠I̴̡̢͚̤͕͉̘̣̭̣̼͖̠̗̮͇͈̭̖͐̈̌͗̂̌͆̈͌̈̏̾̌͋̽̊̾͘͝Ş̶̤̭͔̰͈̥̼̫̺̬͙͋͊͑͒̈́̑̑͌̆͛̅͑̚T̵̙̗͎̟̖̮̪͉͔̮̂̈́̑͛͋͆̕͠E̸̡̡̬̫̬͕͓͙̼̼͒͋͊̊́͊͆͒̊͌̎͋͠͝ͅD̷͓͙̻̳̫̥̫̥̝͖̈͋̔̈́̔̋̉̈́̇̓͑̒̊͛̀̒̕̕","Ț̷̪̟̮̮͓̜́̐͊̔̅̇̿͐̌̎̀͜͠͝ͅW̷͉̝̩̐̒͊͛͛̉̆̃̋̑̀̔̎̽͠I̴̡̢͚̤͕͉̘̣̭̣̼͖̠̗̮͇͈̭̖͐̈̌͗̂̌͆̈͌̈̏̾̌͋̽̊̾͘͝Ş̶̤̭͔̰͈̥̼̫̺̬͙͋͊͑͒̈́̑̑͌̆͛̅͑̚T̵̙̗͎̟̖̮̪͉͔̮̂̈́̑͛͋͆̕͠E̸̡̡̬̫̬͕͓͙̼̼͒͋͊̊́͊͆͒̊͌̎͋͠͝ͅD̷͓͙̻̳̫̥̫̥̝͖̈͋̔̈́̔̋̉̈́̇̓͑̒̊͛̀̒̕̕","Ț̷̪̟̮̮͓̜́̐͊̔̅̇̿͐̌̎̀͜͠͝ͅW̷͉̝̩̐̒͊͛͛̉̆̃̋̑̀̔̎̽͠I̴̡̢͚̤͕͉̘̣̭̣̼͖̠̗̮͇͈̭̖͐̈̌͗̂̌͆̈͌̈̏̾̌͋̽̊̾͘͝Ş̶̤̭͔̰͈̥̼̫̺̬͙͋͊͑͒̈́̑̑͌̆͛̅͑̚T̵̙̗͎̟̖̮̪͉͔̮̂̈́̑͛͋͆̕͠E̸̡̡̬̫̬͕͓͙̼̼͒͋͊̊́͊͆͒̊͌̎͋͠͝ͅD̷͓͙̻̳̫̥̫̥̝͖̈͋̔̈́̔̋̉̈́̇̓͑̒̊͛̀̒̕̕","†WÌ§†ÈÐ","ＴＷＩＳＴΞＤ","TWISTED","TWISTED","TWISTED","TWISTED","TWISTED","TWISTED","TWISTED","TWISTED","₮̷̲́₩̵̲̐ł̶̤͠₴̷̬͝₮̷̼̌Ɇ̶̪͆Đ̴̲͐","₮̷̲́₩̵̲̐ł̶̤͠₴̷̬͝₮̷̼̌Ɇ̶̪͆Đ̴̲͐","₮̷̲́₩̵̲̐ł̶̤͠₴̷̬͝₮̷̼̌Ɇ̶̪͆Đ̴̲͐","T̸͖͝Ẇ̷̪I̴̟̓S̶̠̒Ṫ̸͎Ȅ̵̮Ḓ̸̊","T̸͖͝Ẇ̷̪I̴̟̓S̶̠̒Ṫ̸͎Ȅ̵̮Ḓ̸̊","T̸͖͝Ẇ̷̪I̴̟̓S̶̠̒Ṫ̸͎Ȅ̵̮Ḓ̸̊","T̸͖͝Ẇ̷̪I̴̟̓S̶̠̒Ṫ̸͎Ȅ̵̮Ḓ̸̊","Ț̷̪̟̮̮͓̜́̐͊̔̅̇̿͐̌̎̀͜͠͝ͅW̷͉̝̩̐̒͊͛͛̉̆̃̋̑̀̔̎̽͠I̴̡̢͚̤͕͉̘̣̭̣̼͖̠̗̮͇͈̭̖͐̈̌͗̂̌͆̈͌̈̏̾̌͋̽̊̾͘͝Ş̶̤̭͔̰͈̥̼̫̺̬͙͋͊͑͒̈́̑̑͌̆͛̅͑̚T̵̙̗͎̟̖̮̪͉͔̮̂̈́̑͛͋͆̕͠E̸̡̡̬̫̬͕͓͙̼̼͒͋͊̊́͊͆͒̊͌̎͋͠͝ͅD̷͓͙̻̳̫̥̫̥̝͖̈͋̔̈́̔̋̉̈́̇̓͑̒̊͛̀̒̕̕","Ț̷̪̟̮̮͓̜́̐͊̔̅̇̿͐̌̎̀͜͠͝ͅW̷͉̝̩̐̒͊͛͛̉̆̃̋̑̀̔̎̽͠I̴̡̢͚̤͕͉̘̣̭̣̼͖̠̗̮͇͈̭̖͐̈̌͗̂̌͆̈͌̈̏̾̌͋̽̊̾͘͝Ş̶̤̭͔̰͈̥̼̫̺̬͙͋͊͑͒̈́̑̑͌̆͛̅͑̚T̵̙̗͎̟̖̮̪͉͔̮̂̈́̑͛͋͆̕͠E̸̡̡̬̫̬͕͓͙̼̼͒͋͊̊́͊͆͒̊͌̎͋͠͝ͅD̷͓͙̻̳̫̥̫̥̝͖̈͋̔̈́̔̋̉̈́̇̓͑̒̊͛̀̒̕̕","Ț̷̪̟̮̮͓̜́̐͊̔̅̇̿͐̌̎̀͜͠͝ͅW̷͉̝̩̐̒͊͛͛̉̆̃̋̑̀̔̎̽͠I̴̡̢͚̤͕͉̘̣̭̣̼͖̠̗̮͇͈̭̖͐̈̌͗̂̌͆̈͌̈̏̾̌͋̽̊̾͘͝Ş̶̤̭͔̰͈̥̼̫̺̬͙͋͊͑͒̈́̑̑͌̆͛̅͑̚T̵̙̗͎̟̖̮̪͉͔̮̂̈́̑͛͋͆̕͠E̸̡̡̬̫̬͕͓͙̼̼͒͋͊̊́͊͆͒̊͌̎͋͠͝ͅD̷͓͙̻̳̫̥̫̥̝͖̈͋̔̈́̔̋̉̈́̇̓͑̒̊͛̀̒̕̕","†WÌ§†ÈÐ","ＴＷＩＳＴΞＤ","TWISTED","TWISTED","TWISTED","TWISTED","TWISTED","TWISTED","TWISTED","TWISTED","₮̷̲́₩̵̲̐ł̶̤͠₴̷̬͝₮̷̼̌Ɇ̶̪͆Đ̴̲͐","₮̷̲́₩̵̲̐ł̶̤͠₴̷̬͝₮̷̼̌Ɇ̶̪͆Đ̴̲͐","₮̷̲́₩̵̲̐ł̶̤͠₴̷̬͝₮̷̼̌Ɇ̶̪͆Đ̴̲͐","T̸͖͝Ẇ̷̪I̴̟̓S̶̠̒Ṫ̸͎Ȅ̵̮Ḓ̸̊","T̸͖͝Ẇ̷̪I̴̟̓S̶̠̒Ṫ̸͎Ȅ̵̮Ḓ̸̊","T̸͖͝Ẇ̷̪I̴̟̓S̶̠̒Ṫ̸͎Ȅ̵̮Ḓ̸̊","T̸͖͝Ẇ̷̪I̴̟̓S̶̠̒Ṫ̸͎Ȅ̵̮Ḓ̸̊","Ț̷̪̟̮̮͓̜́̐͊̔̅̇̿͐̌̎̀͜͠͝ͅW̷͉̝̩̐̒͊͛͛̉̆̃̋̑̀̔̎̽͠I̴̡̢͚̤͕͉̘̣̭̣̼͖̠̗̮͇͈̭̖͐̈̌͗̂̌͆̈͌̈̏̾̌͋̽̊̾͘͝Ş̶̤̭͔̰͈̥̼̫̺̬͙͋͊͑͒̈́̑̑͌̆͛̅͑̚T̵̙̗͎̟̖̮̪͉͔̮̂̈́̑͛͋͆̕͠E̸̡̡̬̫̬͕͓͙̼̼͒͋͊̊́͊͆͒̊͌̎͋͠͝ͅD̷͓͙̻̳̫̥̫̥̝͖̈͋̔̈́̔̋̉̈́̇̓͑̒̊͛̀̒̕̕","Ț̷̪̟̮̮͓̜́̐͊̔̅̇̿͐̌̎̀͜͠͝ͅW̷͉̝̩̐̒͊͛͛̉̆̃̋̑̀̔̎̽͠I̴̡̢͚̤͕͉̘̣̭̣̼͖̠̗̮͇͈̭̖͐̈̌͗̂̌͆̈͌̈̏̾̌͋̽̊̾͘͝Ş̶̤̭͔̰͈̥̼̫̺̬͙͋͊͑͒̈́̑̑͌̆͛̅͑̚T̵̙̗͎̟̖̮̪͉͔̮̂̈́̑͛͋͆̕͠E̸̡̡̬̫̬͕͓͙̼̼͒͋͊̊́͊͆͒̊͌̎͋͠͝ͅD̷͓͙̻̳̫̥̫̥̝͖̈͋̔̈́̔̋̉̈́̇̓͑̒̊͛̀̒̕̕","Ț̷̪̟̮̮͓̜́̐͊̔̅̇̿͐̌̎̀͜͠͝ͅW̷͉̝̩̐̒͊͛͛̉̆̃̋̑̀̔̎̽͠I̴̡̢͚̤͕͉̘̣̭̣̼͖̠̗̮͇͈̭̖͐̈̌͗̂̌͆̈͌̈̏̾̌͋̽̊̾͘͝Ş̶̤̭͔̰͈̥̼̫̺̬͙͋͊͑͒̈́̑̑͌̆͛̅͑̚T̵̙̗͎̟̖̮̪͉͔̮̂̈́̑͛͋͆̕͠E̸̡̡̬̫̬͕͓͙̼̼͒͋͊̊́͊͆͒̊͌̎͋͠͝ͅD̷͓͙̻̳̫̥̫̥̝͖̈͋̔̈́̔̋̉̈́̇̓͑̒̊͛̀̒̕̕","†WÌ§†ÈÐ","ＴＷＩＳＴΞＤ"}
local visu = {}
local stupidbguvis = {}
local stupidbguvis2 = {}
local Mode = 1
cooldown = 0
level = 0
levelnum = 0
local attackmultiplier = 1
local DefenceHealthMax = 8000
local DefenceHealth = 8000
local MAINRUINCOLOR = BrickColor.new("Really red").Color
local MAINRUINCOLOR2 = BrickColor.new("Maroon").Color
barrier1 = 0
barrier2 = 0
local ShieldYes = true
barrier3 = 0
sine1 = 0
sine2 = 0
sine3 = 0
rotatio = 0
local EffectsF = script.Effects
local stupidgui = script.yes
stupidgui.Parent = plr.PlayerGui
local MLT = script.ML
MLT.Parent = plr.PlayerGui
switchb = false
local BarrierEnabled = true

local AttachmentHolder = script.AttachmentH
local HealEff = AttachmentHolder.Torso
HealEff.Parent = tors
local Refit = AttachmentHolder.Refit
Refit.Parent = tors
local twistedcolors = {"Bright blue","Institutional White","Storm blue","Electric blue","Medium blue"}

local Movemento = script.Movement
Movemento.Parent = char
Movemento.Disabled = false

local Gui = script.Legacy
Gui.Parent = plr.PlayerGui
Gui.Enabled = true

for i,v in pairs(Gui:GetDescendants())do
if v:IsA("Frame") then
v.BackgroundColor3 = MAINRUINCOLOR
if v.Name == "Line" or v.Name == "Line2" then
v.BackgroundColor3 = MAINRUINCOLOR2
end
end
if v:IsA("TextLabel") then
v.TextColor3 = MAINRUINCOLOR
end
if v.Name == "Vis" and v:IsA("Frame") then
table.insert(visu,v)
end
end

local Booleans = {
  CamFollow = false,
  GyroUse = true
}

function lerp(object, newCFrame, alpha)
  return object:lerp(newCFrame, alpha)
end

local Directer = Inst("BodyGyro", root)
Directer.MaxTorque = Vec3(0, 0, 0)
Directer.P = 600000
local CPart = Inst("Part")
CPart.Anchored = true
CPart.CanCollide = false
CPart.Locked = true
CPart.Transparency = 1

local rainbowmode = false
local chaosmode = false

local ORGID = 0
local ORVOL = 1.15
local ORPIT = 1.01

local currentThemePlaying = kan.SoundId
local currentPitch = kan.Pitch
local currentVol = kan.Volume
function newTheme(ID,timepos,pitch,vol)
local kanz = kan
--kanz:Stop()
kanz.Volume = vol
--kanz.TimePosition = timepos
kanz.PlaybackSpeed = pitch
kanz.Pitch = pitch
kanz.SoundId = ID
kanz.Name = "Legacy"
kanz.Looped = true
currentThemePlaying = kanz.SoundId
currentVol = kanz.Volume
currentPitch = kanz.Pitch
musicc()
--kanz:Play()
--spawn(function()
--wait(0.05)
--end)
end


function newThemeCust(ID,timepos,pitch,vol)
local kanz = kan
kanz:Stop()
kanz.Volume = vol
kanz.TimePosition = timepos
kanz.PlaybackSpeed = pitch
kanz.Pitch = pitch
kanz.SoundId = ID
kanz.Name = "Legacy"
kanz.Looped = true
currentThemePlaying = kanz.SoundId
currentVol = kanz.Volume
currentPitch = kanz.Pitch
kanz:Play()
spawn(function()
wait(0.05)
end)
end

local mutedtog = false
local bilguit = script.bgu
bilguit.Adornee = hed
bilguit.Parent = hed
bilguit.Enabled = true
bilguit.Name = "ModeName"
local modet = bilguit.Namer
modet.TextScaled = true
modet.TextTransparency = 0
modet.BackgroundTransparency = 1 
modet.TextTransparency = 0
modet.TextStrokeTransparency = 0
modet.Font = "Gotham"
modet.TextStrokeColor3 = Color3.new(1,0,0)
modet.TextColor3 = Color3.new(0.5,0,0)
modet.Text = "SANCTUARY"
local fx1 = bilguit.FX1
local fx2 = bilguit.FX2

function CameraEnshaking(Length,Intensity)
spawn(function()
      local intensity = 1*Intensity
      local rotM = 0.01*Intensity
for i = 0, Length, 0.1 do
swait()
intensity = intensity - 0.05*Intensity/Length
rotM = rotM - 0.0005*Intensity/Length
      hum.CameraOffset = Vec3(radian(random(-intensity, intensity)), radian(random(-intensity, intensity)), radian(random(-intensity, intensity)))
      cam.CFrame = cam.CFrame * cFrame(radian(random(-intensity, intensity)), radian(random(-intensity, intensity)), radian(random(-intensity, intensity))) * Euler(radian(random(-intensity, intensity)) * rotM, radian(random(-intensity, intensity)) * rotM, radian(random(-intensity, intensity)) * rotM)
end
Humanoid.CameraOffset = Vec3(0, 0, 0)
end)
end
CamShake=function(Part,Distan,Power,Times) 
local de=Part.Position
for i,v in pairs(workspace:children()) do
 if v:IsA("Model") and v:findFirstChild("Humanoid") then
for _,c in pairs(v:children()) do
if c.ClassName=="Part" and (c.Position - de).magnitude < Distan then
local Noob=v.Humanoid
if Noob~=nil then
spawn(function()
FV = Instance.new("BoolValue", Noob)
FV.Name = "CameraShake"
for ShakeNum=1,Times do
swait()
local ef=Power
  if ef>=1 then
   Humanoid.CameraOffset = Vector3.new(math.random(-ef,ef),math.random(-ef,ef),math.random(-ef,ef))
  else
   ef=Power*10
   Humanoid.CameraOffset = Vector3.new(math.random(-ef,ef)/10,math.random(-ef,ef)/10,math.random(-ef,ef)/10)
  end	
end
Humanoid.CameraOffset = Vector3.new(0,0,0)
FV:Destroy()
end)
CameraShake(Times, Power, Noob)
end
end
end
end
end
end

    local NewInstance = function(instance,parent,properties)
        local inst = Instance.new(instance,parent)
        if(properties)then
            for i,v in next, properties do
                pcall(function() inst[i] = v end)
            end
        end
        return inst;
    end
FXFolder=script.Effects
function CamShake2(who,data)
    coroutine.wrap(function()
        if(FXFolder:FindFirstChild'CamShake')then
            local cam = FXFolder.CamShake:Clone()
            cam:WaitForChild'intensity'.Value = data.Intensity or 5
            cam:WaitForChild'duration'.Value = data.Duration or 5
            cam:WaitForChild'speed'.Value = data.Speed or 10;
             if(data.Origin)then NewInstance((typeof(data.Origin) == 'Instance' and "ObjectValue" or typeof(data.Origin) == 'Vector3' and 'Vector3Value' or typeof(data.Origin)=='CFrame' and 'CFrameValue'),cam,{Name='origin',Value=data.Origin}) end
            cam:WaitForChild'rot'.Value = data.Rotation or Vector3.new(1,1,5)
            cam:WaitForChild'pos'.Value = data.Position or Vector3.new(.5,.5,.5)
            cam:WaitForChild'startdist'.Value = data.DropDist or 25;
            cam:WaitForChild'enddist'.Value = data.IneffectiveDist or 150;
            
            cam.Parent = who
            wait()
            cam.Disabled = false
            wait(3)
            cam:Destroy()
        end
    end)()
end

function CamShakeAll2(data)
    for _,v in next, game:service'Players':players() do
        CamShake2(v:FindFirstChildOfClass'PlayerGui' or v:FindFirstChildOfClass'Backpack' or v.Character,data)
    end
end

--[[
CamShakeAll2({
    Duration=0.6; -- Lasts for .1 seconds
    Intensity=3; -- Intensity of 5
    Position=Vector3.new(2,2,2); -- What axises the shake effects and how much (position)
    Rotation=Vector3.new(2,2,6); -- What axises the shake effects and how much (rotation)
    DropDist=60; -- Camera dist from origin when the shake starts to gradually get weaker
    IneffectiveDist=80; -- Camera dist from origin when the shake goes away
    Origin=tors.Position; -- Where the shake is coming from (Part, CFrame, or Vector3)
})
]]--

function chatfunc(text,color,typet,font,timeex)
local chat = coroutine.wrap(function()
if Character:FindFirstChild("TalkingBillBoard")~= nil then
Character:FindFirstChild("TalkingBillBoard"):destroy()
end
local naeeym2 = Instance.new("BillboardGui",Character)
naeeym2.Size = UDim2.new(0,100,0,40)
naeeym2.StudsOffset = Vector3.new(0,3,0)
naeeym2.Adornee = Character.Head
naeeym2.Name = "TalkingBillBoard"
local tecks2 = Instance.new("TextLabel",naeeym2)
tecks2.BackgroundTransparency = 1
tecks2.BorderSizePixel = 0
tecks2.Text = ""
tecks2.Font = font
tecks2.TextSize = 30
tecks2.TextStrokeTransparency = 0
tecks2.TextColor3 = color
tecks2.TextStrokeColor3 = Color3.new(0,0,0)
tecks2.Size = UDim2.new(1,0,0.5,0)
local tecks3 = Instance.new("TextLabel",naeeym2)
tecks3.BackgroundTransparency = 1
tecks3.BorderSizePixel = 0
tecks3.Text = ""
tecks3.Font = font
tecks3.TextSize = 30
tecks3.TextStrokeTransparency = 0
if typet == "Inverted" then
tecks3.TextColor3 = Color3.new(0,0,0)
tecks3.TextStrokeColor3 = color
elseif typet == "Normal" then
tecks3.TextColor3 = color
tecks3.TextStrokeColor3 = Color3.new(0,0,0)
end
tecks3.Size = UDim2.new(1,0,0.5,0)
spawn(function()
while true do
swait(1)
if chaosmode == true then
tecks2.TextColor3 = BrickColor.random().Color
tecks3.TextStrokeColor3 = BrickColor.random().Color
end
end
end)
for i = 0, 74*timeex do
swait()
tecks2.Text = text
tecks3.Text = text
end
local randomrot = math.random(1,2)
if randomrot == 1 then
for i = 1, 50 do
swait()
tecks2.Text = text
tecks3.Text = text
tecks2.TextStrokeTransparency = tecks2.TextStrokeTransparency +.04
tecks2.TextTransparency = tecks2.TextTransparency + .04
tecks3.TextStrokeTransparency = tecks2.TextStrokeTransparency +.04
tecks3.TextTransparency = tecks2.TextTransparency + .04
end
elseif randomrot == 2 then
	for i = 1, 50 do
swait()
tecks2.Text = text
tecks3.Text = text
tecks2.TextStrokeTransparency = tecks2.TextStrokeTransparency +.04
tecks2.TextTransparency = tecks2.TextTransparency + .04
tecks3.TextStrokeTransparency = tecks2.TextStrokeTransparency +.04
tecks3.TextTransparency = tecks2.TextTransparency + .04
end
end
if toggleTag == false then
end
naeeym2:Destroy()
end)
chat()
end

function newbosschatfunc(text,color1,color2,delay)
	for _,v in next, game:service'Players':players() do
		coroutine.wrap(function()
			if(EffectsF:FindFirstChild'BossChat' and v.Character)then
				local cha = EffectsF.BossChat:Clone()
				cha.Color1.Value=color1
				cha.Color2.Value=color2
				cha.Text.Value=text
				cha.Ghghghghgh.Value=delay
				cha.Mode.Value=Mode
				cha.ModeName.Value=modet.Text
				cha.Music.Value=kan
				cha.Parent=v.Character
				swait()
				cha.Disabled = false
				game:service'Debris':AddItem(cha,(delay/60)*4)
			end
		end)()
	end
end

function bosschatfunc(text,color,watval)
for i,v in pairs(game:GetService("Players"):GetPlayers()) do
spawn(function()
if v.PlayerGui:FindFirstChild("Dialog")~= nil then
v.PlayerGui:FindFirstChild("Dialog"):destroy()
end
local scrg = Instance.new("ScreenGui",v.PlayerGui)
CFuncs["EchoSound"].Create("rbxassetid://525200869", scrg, 0.5, 1,0,10,0.1,0.25,1)
scrg.Name = "Dialog"
local txtlb = Instance.new("TextLabel",scrg)
txtlb.Text = ""
txtlb.Font = "Bodoni"
txtlb.TextColor3 = Color3.new(0,0,0)
txtlb.TextStrokeTransparency = 0
txtlb.BackgroundTransparency = 0.75
txtlb.BackgroundColor3 = Color3.new(0,0,0)
txtlb.TextStrokeColor3 = color
txtlb.TextScaled = true
txtlb.Size = UDim2.new(1,0,0.25,0)
txtlb.TextXAlignment = "Left"
txtlb.Position = UDim2.new(0,0,0.75 + 1,0)
local txtlb2 = Instance.new("TextLabel",scrg)
txtlb2.Text = "???:"
txtlb2.Font = "Arcade"
txtlb2.TextColor3 = Color3.new(0,0,0)
txtlb2.TextStrokeTransparency = 0
txtlb2.BackgroundTransparency = 1
txtlb2.TextStrokeColor3 = color
txtlb2.TextSize = 40
txtlb2.Size = UDim2.new(1,0,0.25,0)
txtlb2.TextXAlignment = "Left"
txtlb2.Position = UDim2.new(0,0,1,0)
local fvalen = 0.55
local fval = -0.49
spawn(function()
while true do
swait()
if chaosmode == true then
txtlb.Rotation = math.random(-1,1)
txtlb2.Rotation = math.random(-1,1)
txtlb.Position = txtlb.Position + UDim2.new(0,math.random(-1,1)/5,0,math.random(-1,1)/5)
txtlb2.Position = txtlb2.Position + UDim2.new(0,math.random(-1,1)/5,0,math.random(-1,1)/5)
txtlb.TextStrokeColor3 = BrickColor.random().Color
txtlb2.TextStrokeColor3 = BrickColor.random().Color
end
end
end)
spawn(function()
while true do
swait()
if scrg.Parent ~= nil then
	fvalen = fvalen - 0.0001
elseif scrg.Parent == nil then
break
end
end
end)
local flol = 1.75
local flil = 1.6
spawn(function()
	for i = 0, 9 do
		swait()
		fval = fval + 0.05
		flol = flol - 0.1
		flil = flil - 0.1
		txtlb.Text = ""
		txtlb.Position = UDim2.new(0,0,flol,0)
		txtlb2.Position = UDim2.new(0,0,flil,0)
	end
	txtlb.Text = text
wait(watval)
local valinc = 0
for i = 0, 99 do
swait()
valinc = valinc + 0.0001
flol = flol + valinc
flil = flil + valinc
txtlb.Rotation = txtlb.Rotation + valinc*20
txtlb2.Rotation = txtlb2.Rotation - valinc*50
txtlb.Position = UDim2.new(0,0,flol,0)
txtlb2.Position = UDim2.new(0,0,flil,0)
txtlb.TextStrokeTransparency = txtlb.TextStrokeTransparency + 0.01
txtlb.TextTransparency = txtlb.TextTransparency + 0.01
txtlb2.TextStrokeTransparency = txtlb2.TextStrokeTransparency + 0.01
txtlb2.TextTransparency = txtlb2.TextTransparency + 0.01
txtlb.BackgroundTransparency = txtlb.BackgroundTransparency + 0.0025
end
scrg:Destroy()
end)
end)
end
end


local Create = require(script:WaitForChild("LoadLibrary"):WaitForChild("RbxUtility")).Create

CFuncs = {	
	["Part"] = {
		Create = function(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
			local Part = Create("Part"){
				Parent = Parent,
				Reflectance = Reflectance,
				Transparency = Transparency,
				CanCollide = false,
				Locked = true,
				BrickColor = BrickColor.new(tostring(BColor)),
				Name = Name,
				Size = Size,
				Material = Material,
			}
			RemoveOutlines(Part)
			return Part
		end;
	};
	
	["Mesh"] = {
		Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh){
				Parent = Part,
				Offset = OffSet,
				Scale = Scale,
			}
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end;
	};
	
	["Mesh"] = {
		Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh){
				Parent = Part,
				Offset = OffSet,
				Scale = Scale,
			}
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end;
	};
	
	["Weld"] = {
		Create = function(Parent, Part0, Part1, C0, C1)
			local Weld = Create("Weld"){
				Parent = Parent,
				Part0 = Part0,
				Part1 = Part1,
				C0 = C0,
				C1 = C1,
			}
			return Weld
		end;
	};

	["Sound"] = {
		Create = function(id, par, vol, pit) 
			spawn(function()
				local S = Create("Sound"){
					Volume = vol,
                                        Name = math.random(0,2552525),
					Pitch = pit or 1,
					SoundId = id,
					Parent = par or workspace,
				}
				wait() 
				S:play() 
				game:GetService("Debris"):AddItem(S, 10)
			end)
		end;
	};

	["TimeSound"] = {
		Create = function(id, par, vol, pit, timepos) 
			spawn(function()
				local S = Create("Sound"){
					Volume = vol,
                                        Name = math.random(0,2552525),
					Pitch = pit or 1,
					SoundId = id,
                                        TimePosition = timepos,
					Parent = par or workspace,
				}
				wait() 
				S:play() 
				game:GetService("Debris"):AddItem(S, 10)
			end)
		end;
	};
		["EchoSound"] = {
		Create = function(id, par, vol, pit, timepos,delays,echodelay,fedb,dryl) 
			spawn(function()
				local Sas = Create("Sound"){
					Volume = vol,
                    Name = math.random(0,2552525),
					Pitch = pit or 1,
					SoundId = id,
                    TimePosition = timepos,
					Parent = par or workspace,
				}
				local E = Create("EchoSoundEffect"){
					Delay = echodelay,
                    Name = "Echo",
					Feedback = fedb,
                    DryLevel = dryl,
					Parent = Sas,
				}
				wait() 
				Sas:play() 
				game:GetService("Debris"):AddItem(Sas, delays)
			end)
		end;
	};

["LongSound"] = {
		Create = function(id, par, vol, pit) 
			spawn(function()
				local S = Create("Sound"){
					Volume = vol,
					Pitch = pit or 1,
					SoundId = id,
					Parent = par or workspace,
				}
				wait() 
				S:play() 
				game:GetService("Debris"):AddItem(S, 60)
			end)
		end;
	};
	
	["ParticleEmitter"] = {
		Create = function(Parent, Color1, Color2, LightEmission, Size, Texture, Transparency, ZOffset, Accel, Drag, LockedToPart, VelocityInheritance, EmissionDirection, Enabled, LifeTime, Rate, Rotation, RotSpeed, Speed, VelocitySpread)
			local fp = Create("ParticleEmitter"){
				Parent = Parent,
				Color = ColorSequence.new(Color1, Color2),
				LightEmission = LightEmission,
				Size = Size,
				Texture = Texture,
				Transparency = Transparency,
				ZOffset = ZOffset,
				Acceleration = Accel,
				Drag = Drag,
				LockedToPart = LockedToPart,
				VelocityInheritance = VelocityInheritance,
				EmissionDirection = EmissionDirection,
				Enabled = Enabled,
				Lifetime = LifeTime,
				Rate = Rate,
				Rotation = Rotation,
				RotSpeed = RotSpeed,
				Speed = Speed,
				VelocitySpread = VelocitySpread,
			}
			return fp
		end;
	};

	CreateTemplate = {
	
	};
}



New = function(Object, Parent, Name, Data)
	local Object = Instance.new(Object)
	for Index, Value in pairs(Data or {}) do
		Object[Index] = Value
	end
	Object.Parent = Parent
	Object.Name = Name
	return Object
end
local halocolor = BrickColor.new("Pastel light blue")
local halocolor2 = BrickColor.new("Cool yellow")
local starcolor = BrickColor.new("Bright yellow")
local lunacolor = BrickColor.new("Navy blue")
local lunacolor2 = BrickColor.new("Bright blue")
local wepcolor = BrickColor.new("Really black")
local maincolor = BrickColor.new("Really black")
local m = Instance.new("Model",char)
local m2 = Instance.new("Model",char)
local m3 = Instance.new("Model",char)
local mw1 = Instance.new("Model",char)
local mw2 = Instance.new("Model",char)
local effectz = Instance.new("Folder",char)
effectz.Name = "Effects"

gui = function(GuiType, parent, text, backtrans, backcol, pos, size)
  local gui = it(GuiType)
  gui.Parent = parent
  gui.Text = text
  gui.BackgroundTransparency = backtrans
  gui.BackgroundColor3 = backcol
  gui.SizeConstraint = "RelativeXY"
  gui.TextXAlignment = "Center"
  gui.TextYAlignment = "Center"
  gui.Position = pos
  gui.Size = size
  gui.Font = "SourceSans"
  gui.FontSize = "Size14"
  gui.TextWrapped = false
  gui.TextStrokeTransparency = 0
  gui.TextColor = BrickColor.new("White")
  return gui
end
--------------------------- GUI STUFF
local basgui = it("GuiMain")
basgui.Parent = plr.PlayerGui
basgui.Name = "VISgui"
local fullscreenz = it("Frame")
fullscreenz.Parent = basgui
fullscreenz.BackgroundColor3 = Color3.new(255, 255, 255)
fullscreenz.BackgroundTransparency = 1
fullscreenz.BorderColor3 = Color3.new(17, 17, 17)
fullscreenz.Size = UDim2.new(1, 0, 1, 0)
fullscreenz.Position = UDim2.new(0, 0, 0, 0)
local vis1 = Instance.new("Frame",fullscreenz)
vis1.BackgroundTransparency = 1
vis1.BorderSizePixel = 0
vis1.BackgroundColor3 = MAINRUINCOLOR
vis1.Size = UDim2.new(0,0.04,0,0)
vis1.Position = UDim2.new(0,0,1,0)

local extrawingmod1 = Instance.new("Model",char)
local extrawingmod2 = Instance.new("Model",char)

function CreateParta(parent,transparency,reflectance,material,brickcolor)
local p = Instance.new("Part")
p.TopSurface = 0
p.BottomSurface = 0
p.Parent = parent
p.Size = Vector3.new(0.1,0.1,0.1)
p.Transparency = transparency
p.Reflectance = reflectance
p.CanCollide = false
p.Locked = true
p.BrickColor = brickcolor
p.Material = material
return p
end

function CreateMesh(parent,meshtype,x1,y1,z1)
local mesh = Instance.new("SpecialMesh",parent)
mesh.MeshType = meshtype
mesh.Scale = Vector3.new(x1*10,y1*10,z1*10)
return mesh
end

function CreateSpecialMesh(parent,meshid,x1,y1,z1)
local mesh = Instance.new("SpecialMesh",parent)
mesh.MeshType = "FileMesh"
mesh.MeshId = meshid
mesh.Scale = Vector3.new(x1,y1,z1)
return mesh
end


function CreateSpecialGlowMesh(parent,meshid,x1,y1,z1)
local mesh = Instance.new("SpecialMesh",parent)
mesh.MeshType = "FileMesh"
mesh.MeshId = meshid
mesh.TextureId = "http://www.roblox.com/asset/?id=269748808"
mesh.Scale = Vector3.new(x1,y1,z1)
mesh.VertexColor = Vector3.new(parent.BrickColor.r, parent.BrickColor.g, parent.BrickColor.b)
return mesh
end

function CreateWeld(parent,part0,part1,C1X,C1Y,C1Z,C1Xa,C1Ya,C1Za,C0X,C0Y,C0Z,C0Xa,C0Ya,C0Za)
local weld = Instance.new("Weld")
weld.Parent = parent
weld.Part0 = part0
weld.Part1 = part1
weld.C1 = CFrame.new(C1X,C1Y,C1Z)*CFrame.Angles(C1Xa,C1Ya,C1Za)
weld.C0 = CFrame.new(C0X,C0Y,C0Z)*CFrame.Angles(C0Xa,C0Ya,C0Za)
return weld
end


--------------
--------------
local sorb = CreateParta(m,1,1,"SmoothPlastic",BrickColor.random())
CreateWeld(sorb,rarm,sorb,0,1,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
local sorb2 = CreateParta(m,1,1,"SmoothPlastic",BrickColor.random())
CreateWeld(sorb2,larm,sorb2,0,1,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

local xae = Instance.new("Part",char)
xae.Transparency = 1
xae.Anchored = true
xae.CanCollide = false

local handlex = CreateParta(mw1,1,1,"Neon",maincolor)
CreateMesh(handlex,"Brick",0,0,0)
local handlexweld = CreateWeld(handlex,tors,handlex,0,0,-0.5,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

local handle = CreateParta(m,1,1,"Neon",maincolor)
CreateMesh(handle,"Brick",0.5,0.5,0.5)
local handleweld = CreateWeld(handle,handlex,handle,0,0,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

local handler = CreateParta(mw2,1,1,"Neon",maincolor)
CreateMesh(handler,"Brick",0,0,0)
local rotweld = CreateWeld(handler,handlex,handler,0,0,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

local ringgu = script.Core:Clone()
ringgu.Parent = mw2
for i,v in pairs(ringgu:GetChildren())do
	if v:IsA("BasePart") or v:IsA("MeshPart") or v:IsA("UnionOperation") then
v.Anchored = false
end
end
CreateWeld(ringgu.Main,handler,ringgu.Main,0,0,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

local halohh = CreateParta(m,1,1,"Neon",maincolor)
CreateMesh(handle,"Brick",0.5,0.5,0.5)
local haloweld = CreateWeld(halohh,hed,halohh,0,0,0,math.rad(5),math.rad(0),math.rad(12.5),0,0,0,math.rad(0),math.rad(0),math.rad(0))

local Cresc = script.Ces:Clone()
Cresc.Parent = mw2
Cresc.Anchored = false
for i,v in pairs(Cresc:GetChildren())do
	if v:IsA("BasePart") or v:IsA("MeshPart") or v:IsA("UnionOperation") then
v.Anchored = false
end
end
local CresWeld = CreateWeld(Cresc,char.HumanoidRootPart,Cresc,0,0,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

local Hall = script.Halo:Clone()
Hall.Parent = mw2
for i,v in pairs(Hall:GetChildren())do
	if v:IsA("BasePart") or v:IsA("MeshPart") or v:IsA("UnionOperation") then
v.Anchored = false
end
end
CreateWeld(Hall.Main,halohh,Hall.Main,0,-1.5,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
local gauntneon = {}
local mov = 0
local Har = script.Har:Clone()
if armorexist == true then
for i,v in pairs(char:GetChildren())do
	if v:IsA("Accessory") then
		v:Destroy()
	elseif v:IsA("BodyColors") then
		v:Destroy()
	end
end
for i,v in pairs(char:GetChildren())do
	if v:IsA("Shirt") or v:IsA("Pants") then
	v:Destroy()
	end
end
tors.BrickColor = BrickColor.new("Nougat")
larm.BrickColor = BrickColor.new("Nougat")
rarm.BrickColor = BrickColor.new("Nougat")
rleg.BrickColor = BrickColor.new("Nougat")
lleg.BrickColor = BrickColor.new("Nougat")
hed.BrickColor = BrickColor.new("Nougat")
hed.Transparency = 1
for i,v in pairs(Character:GetChildren())do
if v:IsA("CharacterMesh") or v:IsA("CharacterAppearance") then
v:Destroy()
end
end
tors.Transparency = 1
clothings = {}
Har.Parent = hed
for i,v in pairs(Har:GetChildren())do
if v:IsA("BasePart") or v:IsA("MeshPart") or v:IsA("UnionOperation") then
v.Anchored = false
end
end
CreateWeld(Har.Main,hed,Har.Main,0,0,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))


local Sweater = script.Sweater:Clone()
Sweater.Parent = tors
for i,v in pairs(Sweater:GetChildren())do
if v:IsA("BasePart") or v:IsA("MeshPart") or v:IsA("UnionOperation") then
v.Anchored = false
if v.Material == Enum.Material.Neon and v.BrickColor ~= BrickColor.new("Really black") then
table.insert(gauntneon,v)
end
end
end
CreateWeld(Sweater.Main,tors,Sweater.Main,0,0,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))


local rleb = script.RLeg:Clone()
rleb.Parent = rleg
for i,v in pairs(rleb:GetChildren())do
if v:IsA("BasePart") or v:IsA("MeshPart") or v:IsA("UnionOperation") then
v.Anchored = false
if v.Material == Enum.Material.Neon then
table.insert(gauntneon,v)
end
end
end
CreateWeld(rleb.Main,rleg,rleb.Main,0,0,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

local lleb = script.LLeg:Clone()
lleb.Parent = lleg
for i,v in pairs(lleb:GetChildren())do
if v:IsA("BasePart") or v:IsA("MeshPart") or v:IsA("UnionOperation") then
v.Anchored = false
if v.Material == Enum.Material.Neon then
table.insert(gauntneon,v)
end
end
end
CreateWeld(lleb.Main,lleg,lleb.Main,0,0,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

local rarb = script.Arm:Clone()
rarb.Parent = rarm
for i,v in pairs(rarb:GetChildren())do
if v:IsA("BasePart") or v:IsA("MeshPart") or v:IsA("UnionOperation") then
v.Anchored = false
if v.Material == Enum.Material.Neon then
table.insert(gauntneon,v)
end
end
end
CreateWeld(rarb.Weld,rarm,rarb.Weld,0,0,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

local larb = script.Arm:Clone()
larb.Parent = larm
for i,v in pairs(larb:GetChildren())do
if v:IsA("BasePart") or v:IsA("MeshPart") or v:IsA("UnionOperation") then
v.Anchored = false
if v.Material == Enum.Material.Neon then
table.insert(gauntneon,v)
end
end
end
CreateWeld(larb.Weld,larm,larb.Weld,0,0,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

end


------
local ringatt = ringgu.Main.Attachment

local lwing1 = CreateParta(m,1,1,"Neon",maincolor)
CreateMesh(handle,"Brick",0.5,0.5,0.5)
local lwing1weld = CreateWeld(lwing1,handle,lwing1,1,0,0,math.rad(5),math.rad(0),math.rad(12.5),0,0,0,math.rad(0),math.rad(0),math.rad(0))

local ae = script.Wing:Clone()
ae.Parent = mw1
for i,v in pairs(ae:GetDescendants())do
if v:IsA("BasePart")then
	v.Anchored = false
end
end
ae.Main.Beam.Attachment1 = ringatt 
CreateWeld(ae.Main,lwing1,ae.Main,0,0,-1.75,math.rad(0),math.rad(0),math.rad(-0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

local lwing2 = CreateParta(m,1,1,"Neon",maincolor)
CreateMesh(handle,"Brick",0.5,0.5,0.5)
local lwing2weld = CreateWeld(lwing2,handle,lwing2,1,1,0,math.rad(10),math.rad(0),math.rad(25),0,0,0,math.rad(0),math.rad(0),math.rad(0))

local ae = script.Wing:Clone()
ae.Parent = mw1
for i,v in pairs(ae:GetDescendants())do
if v:IsA("BasePart")then
	v.Anchored = false
end
end
ae.Main.Beam.Attachment1 = ringatt
CreateWeld(ae.Main,lwing2,ae.Main,0,0,-1.75,math.rad(0),math.rad(0),math.rad(-0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

local lwing3 = CreateParta(m,1,1,"Neon",maincolor)
CreateMesh(handle,"Brick",0.5,0.5,0.5)
local lwing3weld = CreateWeld(lwing3,handle,lwing3,1,2,0,math.rad(15),math.rad(0),math.rad(37.5),0,0,0,math.rad(0),math.rad(0),math.rad(0))

local ae = script.Wing:Clone()
ae.Parent = mw1
for i,v in pairs(ae:GetDescendants())do
if v:IsA("BasePart")then
	v.Anchored = false
end
end
ae.Main.Beam.Attachment1 = ringatt
CreateWeld(ae.Main,lwing3,ae.Main,0,0,-1.75,math.rad(0),math.rad(0),math.rad(-0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

-- Right wing.

local rwing1 = CreateParta(m,1,1,"Neon",maincolor)
CreateMesh(handle,"Brick",0.5,0.5,0.5)
local rwing1weld = CreateWeld(rwing1,handle,rwing1,-1,0,0,math.rad(5),math.rad(0),math.rad(-12.5),0,0,0,math.rad(0),math.rad(0),math.rad(0))

local ae = script.Wing:Clone()
ae.Parent = mw2
for i,v in pairs(ae:GetDescendants())do
if v:IsA("BasePart")then
	v.Anchored = false
end
end
ae.Main.Beam.Attachment1 = ringatt
CreateWeld(ae.Main,rwing1,ae.Main,0,0,-1.75,math.rad(0),math.rad(0),math.rad(-0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

local rwing2 = CreateParta(m,1,1,"Neon",maincolor)
CreateMesh(handle,"Brick",0.5,0.5,0.5)
local rwing2weld = CreateWeld(rwing2,handle,rwing2,-1,1,0,math.rad(10),math.rad(0),math.rad(-25),0,0,0,math.rad(0),math.rad(0),math.rad(0))

local ae = script.Wing:Clone()
ae.Parent = mw2
for i,v in pairs(ae:GetDescendants())do
if v:IsA("BasePart")then
	v.Anchored = false
end
end
ae.Main.Beam.Attachment1 = ringatt
CreateWeld(ae.Main,rwing2,ae.Main,0,0,-1.75,math.rad(0),math.rad(0),math.rad(-0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

local rwing3 = CreateParta(m,1,1,"Neon",maincolor)
CreateMesh(handle,"Brick",0.5,0.5,0.5)
local rwing3weld = CreateWeld(rwing3,handle,rwing3,-1,2,0,math.rad(15),math.rad(0),math.rad(-37.5),0,0,0,math.rad(0),math.rad(0),math.rad(0))

local ae = script.Wing:Clone()
ae.Parent = mw2
for i,v in pairs(ae:GetDescendants())do
if v:IsA("BasePart")then
	v.Anchored = false
end
end
ae.Main.Beam.Attachment1 = ringatt
CreateWeld(ae.Main,rwing3,ae.Main,0,0,-1.75,math.rad(0),math.rad(0),math.rad(-0),0,0,0,math.rad(0),math.rad(0),math.rad(0))



function RemoveOutlines(part)
  part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
end
function CreatePart(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
  local Part = Create("Part")({
    Parent = Parent,
    Reflectance = Reflectance,
    Transparency = Transparency,
    CanCollide = false,
    Locked = true,
    BrickColor = BrickColor.new(tostring(BColor)),
    Name = Name,
    Size = Size,
    Material = Material
  })
  Part.CustomPhysicalProperties = PhysicalProperties.new(0.001, 0.001, 0.001, 0.001, 0.001)
  RemoveOutlines(Part)
  return Part
end
function CreateMesha(Mesh, Part, MeshType, MeshId, OffSet, Scale)
  local Msh = Create(Mesh)({
    Parent = Part,
    Offset = OffSet,
    Scale = Scale
  })
  if Mesh == "SpecialMesh" then
    Msh.MeshType = MeshType
    Msh.MeshId = MeshId
  end
  return Msh
end
function CreateWeld(Parent, Part0, Part1, C0, C1)
  local Weld = Create("Weld")({
    Parent = Parent,
    Part0 = Part0,
    Part1 = Part1,
    C0 = C0,
    C1 = C1
  })
  return Weld
end

Character=Player.Character 
PlayerGui=Player.PlayerGui 
Backpack=Player.Backpack 
Torso=Character.Torso 
Head=Character.Head 
Humanoid=Character.Humanoid
m=Instance.new('Model',Character)
LeftArm=Character["Left Arm"] 
LeftLeg=Character["Left Leg"] 
RightArm=Character["Right Arm"] 
RightLeg=Character["Right Leg"] 
LW=Torso["Left Shoulder"] 
LH=Torso["Left Hip"] 
RW=Torso["Right Shoulder"] 
RH=Torso["Right Hip"] 
Face = Head.face
Neck=Torso.Neck
it=Instance.new
attacktype=1
vt=Vector3.new
cf=CFrame.new
euler=CFrame.fromEulerAnglesXYZ
angles=CFrame.Angles
cloaked=false
necko=cf(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
necko2=cf(0, -0.5, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
LHC0=cf(-1,-1,0,-0,-0,-1,0,1,0,1,0,0)
LHC1=cf(-0.5,1,0,-0,-0,-1,0,1,0,1,0,0)
RHC0=cf(1,-1,0,0,0,1,0,1,0,-1,-0,-0)
RHC1=cf(0.5,1,0,0,0,1,0,1,0,-1,-0,-0)
RootPart=Character.HumanoidRootPart
RootJoint=RootPart.RootJoint
RootCF=euler(-1.57,0,3.14)
attack = false 
attackdebounce = false 
deb=false
equipped=true
hand=false
MMouse=nil
combo=0
mana=0
trispeed=.2
attackmode='none'
local idle=0
local Anim="Idle"
local Effects={}
local gun=false
local shoot=false
local sine = 0
local change = 1

Head.face:Destroy()
for i,v in pairs(script.Face:GetChildren())do
--v.Parent = Head
end

function warnedpeople(text,represfont,color,color2)
CFuncs["Sound"].Create("rbxassetid://534859368", char, 2.5,1)
CFuncs["Sound"].Create("rbxassetid://963718869", char, 1,1)
for i,v in pairs(game:GetService("Players"):GetPlayers()) do
spawn(function()
if v.PlayerGui:FindFirstChild("Spinny")~= nil then
v.PlayerGui:FindFirstChild("Spinny"):destroy()
end
local scrg = Instance.new("ScreenGui",v.PlayerGui)
scrg.Name = "Spinny"
local frm = Instance.new("Frame",scrg)
frm.BackgroundTransparency = 0.25
frm.BackgroundColor3 = color
frm.BorderSizePixel = 0
frm.Rotation = 45
frm.Size = UDim2.new(3,0,0,100)
frm.Position = UDim2.new(-4,0,0,0)
local frm2 = frm:Clone()
frm2.Parent = scrg
frm2.BackgroundColor3 = color2
frm2.Position = UDim2.new(-4.05,0,0,0)
local imlb = Instance.new("ImageLabel",scrg)
imlb.BackgroundTransparency = 1
imlb.BackgroundColor3 = Color3.new(0,0,0)
imlb.Image = "rbxassetid://2344851144"
imlb.Size = UDim2.new(0,750,0,750)
imlb.ImageColor3 = color2
imlb.ImageTransparency = 0.25
imlb.Position = UDim2.new(-2.5,0,-2.5,0)
local imlb2 = imlb:Clone()
imlb2.Image = "rbxassetid://2325939897"
imlb2.Size = UDim2.new(1,0,1,0)
imlb2.ImageColor3 = color
imlb2.ImageTransparency = 0
imlb2.Position = UDim2.new(0,0,0,0)
local imlb3 = imlb:Clone()
imlb3.Image = "rbxassetid://2344830904"
imlb3.Size = UDim2.new(1,0,1,0)
imlb3.ImageColor3 = color2
imlb3.ImageTransparency = 0
imlb3.Position = UDim2.new(0,0,0,0)
local imlb4 = imlb:Clone()
imlb4.Image = "rbxassetid://2344870656"
imlb4.Size = UDim2.new(1,0,1,0)
imlb4.ImageColor3 = Color3.new(1,1,1)
imlb4.ImageTransparency = 0
imlb4.Position = UDim2.new(0,0,0,0)
imlb2.Parent = imlb
imlb3.Parent = imlb
imlb4.Parent = imlb
local txtlb2 = Instance.new("TextLabel",imlb)
txtlb2.Text = text
txtlb2.Font = represfont
txtlb2.TextColor3 = color
txtlb2.TextStrokeTransparency = 0
txtlb2.BackgroundTransparency = 1
txtlb2.TextStrokeColor3 = color2
txtlb2.TextScaled = true
txtlb2.Size = UDim2.new(1,0,1,0)
txtlb2.Position = UDim2.new(0,0,0,0)
local fvalen = 0.55
local fval = -0.49
spawn(function()
while true do
swait()
if chaosmode == true then
txtlb2.Rotation = math.random(-1,1)
imlb.Position = imlb.Position + UDim2.new(0,math.random(-1,1)/5,0,math.random(-1,1)/5)
txtlb2.Position = txtlb2.Position + UDim2.new(0,math.random(-1,1)/5,0,math.random(-1,1)/5)
imlb.ImageColor3 = BrickColor.random().Color
txtlb2.TextStrokeColor3 = BrickColor.random().Color
end
end
end)
spawn(function()
while true do
swait()
if scrg.Parent ~= nil then
	fvalen = fvalen - 0.0001
elseif scrg.Parent == nil then
break
end
end
end)
local flol = -5
local flil = 1.6
spawn(function()
	for i = 0, 49 do
		swait()
		flol = flol + 0.125
		flil = flil - 0.1
		frm.Size = frm.Size + UDim2.new(0.1,0,0,0)
		frm.Rotation = frm.Rotation - 0.25
		frm2.Size = frm2.Size + UDim2.new(0.1,0,0,0)
		frm2.Rotation = frm.Rotation + 0.325
		imlb3.Rotation = imlb3.Rotation - 10
		imlb2.Rotation = imlb.Rotation + 7.5
		imlb.Rotation = imlb.Rotation + 5
		txtlb2.Rotation = txtlb2.Rotation - 5.125
		imlb.Position = imlb.Position + UDim2.new(0.05125,0,0.04775,0)
	end
	for i = 0, 99 do
		swait()
		fval = fval + 0.05
		flol = flol + 0.005
		frm.Size = frm.Size + UDim2.new(0.005,0,0,0)
		frm.Rotation = frm.Rotation - 0.075
		frm2.Size = frm2.Size + UDim2.new(0.005,0,0,0)
		frm2.Rotation = frm2.Rotation + 0.125
		imlb3.Rotation = imlb3.Rotation - 2
		imlb2.Rotation = imlb.Rotation + 1.5
		imlb.Rotation = imlb.Rotation + 1
		txtlb2.Rotation = txtlb2.Rotation - 1.125
		imlb.Position = imlb.Position + UDim2.new(0.0015,0,0.00075,0)
	end
local valinc = 0
local vinc2 = 1
for i = 0, 99 do
swait()
vinc2 = vinc2 + 0.25
valinc = valinc + 0.0001
flol = flol + valinc
flil = flil + valinc
txtlb2.Rotation = txtlb2.Rotation - 1.125*vinc2
imlb3.Rotation = imlb3.Rotation - 2*vinc2
imlb.Rotation = imlb.Rotation + 1*vinc2
imlb.Position = imlb.Position + UDim2.new(0.0015*vinc2,0,0.0005*vinc2,0)
frm.Size = frm.Size + UDim2.new(0.005*vinc2,0,0,0)
frm.Rotation = frm.Rotation + 0.1*vinc2
frm2.Size = frm2.Size + UDim2.new(0.005*vinc2,0,0,0)
frm2.Rotation = frm2.Rotation + 0.225*vinc2
frm2.BackgroundTransparency = frm2.BackgroundTransparency + 0.0075
frm.BackgroundTransparency = frm.BackgroundTransparency + 0.0075
imlb.ImageTransparency = imlb.ImageTransparency + 0.005
imlb2.ImageTransparency = imlb2.ImageTransparency + 0.01
imlb3.ImageTransparency = imlb3.ImageTransparency + 0.01
imlb4.ImageTransparency = imlb4.ImageTransparency + 0.01
txtlb2.TextStrokeTransparency = txtlb2.TextStrokeTransparency + 0.01
txtlb2.TextTransparency = txtlb2.TextTransparency + 0.01
end
scrg:Destroy()
end)
end)
end
end



--save shoulders 
--[[RSH, LSH=nil, nil 
--welds 
RW, LW=Instance.new("Weld"), Instance.new("Weld") 
RW.Name="Right Shoulder" LW.Name="Left Shoulder"
LH=Torso["Left Hip"]
RH=Torso["Right Hip"]
TorsoColor=Torso.BrickColor
function NoOutline(Part)
Part.TopSurface,Part.BottomSurface,Part.LeftSurface,Part.RightSurface,Part.FrontSurface,Part.BackSurface = 10,10,10,10,10,10
end
ch=Character
RSH=ch.Torso["Right Shoulder"] 
LSH=ch.Torso["Left Shoulder"] 
-- 
RSH.Parent=nil 
LSH.Parent=nil ]]--
-- 
RW.Name="Right Shoulder"
RW.Part0=char.Torso 
RW.C0=cf(1.5, 0.5, 0) --* CFrame.fromEulerAnglesXYZ(1.3, 0, -0.5) 
RW.C1=cf(0, 0.5, 0) 
RW.Part1=char["Right Arm"] 
RW.Parent=char.Torso 
-- 
LW.Name="Left Shoulder"
LW.Part0=char.Torso 
LW.C0=cf(-1.5, 0.5, 0) --* CFrame.fromEulerAnglesXYZ(1.7, 0, 0.8) 
LW.C1=cf(0, 0.5, 0) 
LW.Part1=char["Left Arm"] 
LW.Parent=char.Torso

local donum=0
 

function part(formfactor,parent,reflectance,transparency,brickcolor,name,size)
local fp=it("Part")
fp.formFactor=formfactor 
fp.Parent=parent
fp.Reflectance=reflectance
fp.Transparency=transparency
fp.CanCollide=false 
fp.Locked=true
fp.BrickColor=brickcolor
fp.Name=name
fp.Size=size
fp.Position=Torso.Position 
NoOutline(fp)
fp.Material="SmoothPlastic"
fp:BreakJoints()
return fp 
end 
 
function mesh(Mesh,part,meshtype,meshid,offset,scale)
local mesh=it(Mesh) 
mesh.Parent=part
if Mesh=="SpecialMesh" then
mesh.MeshType=meshtype
if meshid~="nil" then
mesh.MeshId="http://www.roblox.com/asset/?id="..meshid
end
end
mesh.Offset=offset
mesh.Scale=scale
return mesh
end
 
function weld(parent,part0,part1,c0)
local weld=it("Weld") 
weld.Parent=parent
weld.Part0=part0 
weld.Part1=part1 
weld.C0=c0
return weld
end
 
local Color1=Torso.BrickColor

local bodvel=Instance.new("BodyVelocity")
local bg=Instance.new("BodyGyro")

--------- SazEreno's Artificial HB --------------
ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "ArtificialHB"

script:WaitForChild("ArtificialHB")
Frame_Speed = 1 / 60
frame = Frame_Speed
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.ArtificialHB:Fire()

game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.ArtificialHB:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.ArtificialHB:Fire()
			end
		lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)

------------------
function swait(num)
if num == 0 or num == nil then
		ArtificialHB.Event:wait()
	else
		for i = 1, num do
			ArtificialHB.Event:wait()
		end
	end
end
-------- RAINBOW LEAVE IT TO ME
local r = 255
local g = 0
local b = 0
spawn(function()
while wait() do
	for i = 0, 254/5 do
		swait()
		g = g + 5
	end
	for i = 0, 254/5 do
		swait()
		r = r - 5
	end
	for i = 0, 254/5 do
		swait()
		b = b + 5
	end
	for i = 0, 254/5 do
		swait()
		g = g - 5
	end
	for i = 0, 254/5 do
		swait()
		r = r + 5
	end
	for i = 0, 254/5 do
		swait()
		b = b - 5
	end
end
end)
 
 
so = function(id,par,vol,pit) 
spawn(function()
local sou = Instance.new("Sound",par or workspace)
sou.Volume=vol
sou.Pitch=pit or 1
sou.SoundId=id
swait() 
sou:play() 
game:GetService("Debris"):AddItem(sou,6)
end)
end
 
function clerp(a,b,t) 
local qa = {QuaternionFromCFrame(a)}
local qb = {QuaternionFromCFrame(b)} 
local ax, ay, az = a.x, a.y, a.z 
local bx, by, bz = b.x, b.y, b.z
local _t = 1-t
return QuaternionToCFrame(_t*ax + t*bx, _t*ay + t*by, _t*az + t*bz,QuaternionSlerp(qa, qb, t)) 
end 
 
function QuaternionFromCFrame(cf) 
local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components() 
local trace = m00 + m11 + m22 
if trace > 0 then 
local s = math.sqrt(1 + trace) 
local recip = 0.5/s 
return (m21-m12)*recip, (m02-m20)*recip, (m10-m01)*recip, s*0.5 
else 
local i = 0 
if m11 > m00 then
i = 1
end
if m22 > (i == 0 and m00 or m11) then 
i = 2 
end 
if i == 0 then 
local s = math.sqrt(m00-m11-m22+1) 
local recip = 0.5/s 
return 0.5*s, (m10+m01)*recip, (m20+m02)*recip, (m21-m12)*recip 
elseif i == 1 then 
local s = math.sqrt(m11-m22-m00+1) 
local recip = 0.5/s 
return (m01+m10)*recip, 0.5*s, (m21+m12)*recip, (m02-m20)*recip 
elseif i == 2 then 
local s = math.sqrt(m22-m00-m11+1) 
local recip = 0.5/s return (m02+m20)*recip, (m12+m21)*recip, 0.5*s, (m10-m01)*recip 
end 
end 
end
 
function QuaternionToCFrame(px, py, pz, x, y, z, w) 
local xs, ys, zs = x + x, y + y, z + z 
local wx, wy, wz = w*xs, w*ys, w*zs 
local xx = x*xs 
local xy = x*ys 
local xz = x*zs 
local yy = y*ys 
local yz = y*zs 
local zz = z*zs 
return CFrame.new(px, py, pz,1-(yy+zz), xy - wz, xz + wy,xy + wz, 1-(xx+zz), yz - wx, xz - wy, yz + wx, 1-(xx+yy)) 
end
 
function QuaternionSlerp(a, b, t) 
local cosTheta = a[1]*b[1] + a[2]*b[2] + a[3]*b[3] + a[4]*b[4] 
local startInterp, finishInterp; 
if cosTheta >= 0.0001 then 
if (1 - cosTheta) > 0.0001 then 
local theta = math.acos(cosTheta) 
local invSinTheta = 1/math.sin(theta) 
startInterp = math.sin((1-t)*theta)*invSinTheta 
finishInterp = math.sin(t*theta)*invSinTheta  
else 
startInterp = 1-t 
finishInterp = t 
end 
else 
if (1+cosTheta) > 0.0001 then 
local theta = math.acos(-cosTheta) 
local invSinTheta = 1/math.sin(theta) 
startInterp = math.sin((t-1)*theta)*invSinTheta 
finishInterp = math.sin(t*theta)*invSinTheta 
else 
startInterp = t-1 
finishInterp = t 
end 
end 
return a[1]*startInterp + b[1]*finishInterp, a[2]*startInterp + b[2]*finishInterp, a[3]*startInterp + b[3]*finishInterp, a[4]*startInterp + b[4]*finishInterp 
end

local function CFrameFromTopBack(at, top, back)
local right = top:Cross(back)
return CFrame.new(at.x, at.y, at.z,
right.x, top.x, back.x,
right.y, top.y, back.y,
right.z, top.z, back.z)
end

function Triangle(a, b, c)
local edg1 = (c-a):Dot((b-a).unit)
local edg2 = (a-b):Dot((c-b).unit)
local edg3 = (b-c):Dot((a-c).unit)
if edg1 <= (b-a).magnitude and edg1 >= 0 then
a, b, c = a, b, c
elseif edg2 <= (c-b).magnitude and edg2 >= 0 then
a, b, c = b, c, a
elseif edg3 <= (a-c).magnitude and edg3 >= 0 then
a, b, c = c, a, b
else
assert(false, "unreachable")
end
 
local len1 = (c-a):Dot((b-a).unit)
local len2 = (b-a).magnitude - len1
local width = (a + (b-a).unit*len1 - c).magnitude
 
local maincf = CFrameFromTopBack(a, (b-a):Cross(c-b).unit, -(b-a).unit)
 
local list = {}
 
if len1 > 0.01 then
local w1 = Instance.new('WedgePart', m)
game:GetService("Debris"):AddItem(w1,5)
w1.Material = "SmoothPlastic"
w1.FormFactor = 'Custom'
w1.BrickColor = BrickColor.new("Really red")
w1.Transparency = 0
w1.Reflectance = 0
w1.Material = "SmoothPlastic"
w1.CanCollide = false
local l1 = Instance.new("PointLight",w1)
l1.Color = Color3.new(170,0,0)
NoOutline(w1)
local sz = Vector3.new(0.2, width, len1)
w1.Size = sz
local sp = Instance.new("SpecialMesh",w1)
sp.MeshType = "Wedge"
sp.Scale = Vector3.new(0,1,1) * sz/w1.Size
w1:BreakJoints()
w1.Anchored = true
w1.Parent = workspace
w1.Transparency = 0.7
table.insert(Effects,{w1,"Disappear",.01})
w1.CFrame = maincf*CFrame.Angles(math.pi,0,math.pi/2)*CFrame.new(0,width/2,len1/2)
table.insert(list,w1)
end
 
if len2 > 0.01 then
local w2 = Instance.new('WedgePart', m)
game:GetService("Debris"):AddItem(w2,5)
w2.Material = "SmoothPlastic"
w2.FormFactor = 'Custom'
w2.BrickColor = BrickColor.new("Really red")
w2.Transparency = 0
w2.Reflectance = 0
w2.Material = "SmoothPlastic"
w2.CanCollide = false
local l2 = Instance.new("PointLight",w2)
l2.Color = Color3.new(170,0,0)
NoOutline(w2)
local sz = Vector3.new(0.2, width, len2)
w2.Size = sz
local sp = Instance.new("SpecialMesh",w2)
sp.MeshType = "Wedge"
sp.Scale = Vector3.new(0,1,1) * sz/w2.Size
w2:BreakJoints()
w2.Anchored = true
w2.Parent = workspace
w2.Transparency = 0.7
table.insert(Effects,{w2,"Disappear",.01})
w2.CFrame = maincf*CFrame.Angles(math.pi,math.pi,-math.pi/2)*CFrame.new(0,width/2,-len1 - len2/2)
table.insert(list,w2)
end
return unpack(list)
end
 

function Damagefunc(Part, hit, minim, maxim, knockback, Type, Property, Delay, HitSound, HitPitch)
  if hit.Parent == nil then
    return
  end
  local h = hit.Parent:FindFirstChildOfClass("Humanoid")
  for _, v in pairs(hit.Parent:children()) do
    if v:IsA("Humanoid") then
      h = v
    end
  end
  if h ~= nil and hit.Parent.Name ~= Character.Name and hit.Parent:FindFirstChild("Head") ~= nil then
    if hit.Parent:findFirstChild("DebounceHit") ~= nil and hit.Parent.DebounceHit.Value == true then
      return
    end
    local c = Create("ObjectValue")({
      Name = "creator",
      Value = Player,
      Parent = h
    })
    game:GetService("Debris"):AddItem(c, 0.5)
    if HitSound ~= nil and HitPitch ~= nil then
      CFuncs.Sound.Create(HitSound, hit, 1, HitPitch)
    end
    local Damage = math.random(minim, maxim)
    local blocked = false
    local block = hit.Parent:findFirstChild("Block")
    if block ~= nil and block.className == "IntValue" and block.Value > 0 then
      blocked = true
      block.Value = block.Value - 1
      print(block.Value)
    end
    if blocked == false then
      HitHealth = h.Health
      h.MaxHealth = 100
      h.Health = h.Health - Damage
      if HitHealth ~= h.Health and HitHealth ~= 0 and 0 >= h.Health and h.Parent.Name ~= "Hologram" then
        print("gained kill")
        dmg(h.Parent)
levelnum = levelnum + 50
      end
      ShowDamage(Part.CFrame * CFrame.new(0, 0, Part.Size.Z / 2).p + Vector3.new(0, 1.5, 0), Damage, .03, Part.BrickColor.Color)
    else
      h.Health = h.Health - Damage / 2
      ShowDamage(Part.CFrame * CFrame.new(0, 0, Part.Size.Z / 2).p + Vector3.new(0, 1.5, 0), Damage, .03, Part.BrickColor.Color)
    end
    if Type == "Knockdown" then
      local hum = hit.Parent.Humanoid
      hum.PlatformStand = true
      coroutine.resume(coroutine.create(function(HHumanoid)
        swait(1)
        HHumanoid.PlatformStand = false
      end), hum)
      local angle = hit.Position - (Property.Position + Vector3.new(0, 0, 0)).unit
      local bodvol = Create("BodyVelocity")({
        velocity = angle * knockback,
        P = 5000,
        maxForce = Vector3.new(8000, 8000, 8000),
        Parent = hit
      })
      local rl = Create("BodyAngularVelocity")({
        P = 3000,
        maxTorque = Vector3.new(500000, 500000, 500000) * 50000000000000,
        angularvelocity = Vector3.new(math.random(-10, 10), math.random(-10, 10), math.random(-10, 10)),
        Parent = hit
      })
      game:GetService("Debris"):AddItem(bodvol, 0.5)
      game:GetService("Debris"):AddItem(rl, 0.5)
    elseif Type == "Normal" then
      local vp = Create("BodyVelocity")({
        P = 500,
        maxForce = Vector3.new(math.huge, 0, math.huge),
        velocity = Property.CFrame.lookVector * knockback + Property.Velocity / 1.05
      })
      if knockback > 0 then
        vp.Parent = hit.Parent.Head
      end
      game:GetService("Debris"):AddItem(vp, 0.5)
    elseif Type == "Up" then
      local bodyVelocity = Create("BodyVelocity")({
        velocity = Vector3.new(0, 20, 0),
        P = 5000,
        maxForce = Vector3.new(8000, 8000, 8000),
        Parent = hit
      })
      game:GetService("Debris"):AddItem(bodyVelocity, 0.5)
      local bodyVelocity = Create("BodyVelocity")({
        velocity = Vector3.new(0, 20, 0),
        P = 5000,
        maxForce = Vector3.new(8000, 8000, 8000),
        Parent = hit
      })
      game:GetService("Debris"):AddItem(bodyVelocity, 1)
    elseif Type == "Leech" then
      local hum = hit.Parent.Humanoid
      if hum ~= nil then
        for i = 0, 2 do
          Effects.Sphere.Create(BrickColor.new("Bright red"), hit.Parent.Torso.CFrame * cn(0, 0, 0) * angles(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 1, 15, 1, 0, 5, 0, 0.02)
        end
        Humanoid.Health = Humanoid.Health + 10
      end
    elseif Type == "UpKnock" then
      local hum = hit.Parent.Humanoid
      hum.PlatformStand = true
      if hum ~= nil then
        hitr = true
      end
      coroutine.resume(coroutine.create(function(HHumanoid)
        swait(5)
        HHumanoid.PlatformStand = false
        hitr = false
      end), hum)
      local bodyVelocity = Create("BodyVelocity")({
        velocity = Vector3.new(0, 20, 0),
        P = 5000,
        maxForce = Vector3.new(8000, 8000, 8000),
        Parent = hit
      })
      game:GetService("Debris"):AddItem(bodyVelocity, 0.5)
      local bodyVelocity = Create("BodyVelocity")({
        velocity = Vector3.new(0, 20, 0),
        P = 5000,
        maxForce = Vector3.new(8000, 8000, 8000),
        Parent = hit
      })
      game:GetService("Debris"):AddItem(bodyVelocity, 1)
    elseif Type == "Snare" then
      local bp = Create("BodyPosition")({
        P = 2000,
        D = 100,
        maxForce = Vector3.new(math.huge, math.huge, math.huge),
        position = hit.Parent.Torso.Position,
        Parent = hit.Parent.Torso
      })
      game:GetService("Debris"):AddItem(bp, 1)
    elseif Type == "Slashnare" then
      Effects.Block.Create(BrickColor.new("Pastel Blue"), hit.Parent.Torso.CFrame * cn(0, 0, 0), 15*4, 15*4, 15*4, 3*4, 3*4, 3*4, 0.07)
      for i = 1, math.random(4, 5) do
        Effects.Sphere.Create(BrickColor.new("Teal"), hit.Parent.Torso.CFrame * cn(math.random(-5, 5), math.random(-5, 5), math.random(-5, 5)) * angles(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 1, 15, 1, 0, 5, 0, 0.02)
      end
      local bp = Create("BodyPosition")({
        P = 2000,
        D = 100,
        maxForce = Vector3.new(math.huge, math.huge, math.huge),
        position = hit.Parent.Torso.Position,
        Parent = hit.Parent.Torso
      })
      game:GetService("Debris"):AddItem(bp, 1)
	elseif Type == "Burn" then

      local humss = hit.Parent:findFirstChildOfClass("Humanoid")
      humss.PlatformStand = true
      coroutine.resume(coroutine.create(function(HHumanoid)
        swait(60)
        HHumanoid.PlatformStand = false
      end), humss)
      local angle = hit.Position - (Property.Position + Vector3.new(0, 0, 0)).unit
      local bodvol = Create("BodyVelocity")({
        velocity = angle * knockback,
        P = 5000,
        maxForce = Vector3.new(8000, 8000, 8000),
        Parent = hit
      })
      local rl = Create("BodyAngularVelocity")({
        P = 3000,
        maxTorque = Vector3.new(500000, 500000, 500000) * 50000000000000,
        angularvelocity = Vector3.new(math.random(-10, 10), math.random(-10, 10), math.random(-10, 10)),
        Parent = hit
      })
      game:GetService("Debris"):AddItem(bodvol, 0.5)
      game:GetService("Debris"):AddItem(rl, 0.5)

	coroutine.resume(coroutine.create(function()
		if hit.Parent:findFirstChild("Torso")then
			local hitoor=hit.Parent:findFirstChild("Torso")
		local da = freemodelflame:Clone()
		da.Parent = hitoor
		da.Enabled = true
				local BURNBABYBURN = Create("Sound"){
					Volume = 1,
                    Name = "asdawdwadadw",
					Pitch = 1.2,
					Looped = true,
					SoundId = "rbxassetid://1601946639",
					Parent = hitoor,
				}
				BURNBABYBURN:play()
		for i=1, 150 do
		swait(5)
		humss.Health = humss.Health - .4
		end
		da.Enabled = false
		BURNBABYBURN:Remove()
 	     game:GetService("Debris"):AddItem(da, 2)
		end
	end))
	
    elseif Type == "Spike" then
      CreateBigIceSword(hit.Parent.Torso.CFrame)
      local bp = Create("BodyPosition")({
        P = 2000,
        D = 100,
        maxForce = Vector3.new(math.huge, math.huge, math.huge),
        position = hit.Parent.Torso.Position,
        Parent = hit.Parent.Torso
      })
      game:GetService("Debris"):AddItem(bp, 1)
    elseif Type == "Freeze" then
      local BodPos = Create("BodyPosition")({
        P = 50000,
        D = 1000,
        maxForce = Vector3.new(math.huge, math.huge, math.huge),
        position = hit.Parent.Torso.Position,
        Parent = hit.Parent.Torso
      })
      local BodGy = Create("BodyGyro")({
        maxTorque = Vector3.new(400000, 400000, 400000) * math.huge,
        P = 20000,
        Parent = hit.Parent.Torso,
        cframe = hit.Parent.Torso.CFrame
      })
      hit.Parent.Torso.Anchored = true
      coroutine.resume(coroutine.create(function(Part)
        swait(1.5)
        Part.Anchored = false
      end), hit.Parent.Torso)
      game:GetService("Debris"):AddItem(BodPos, 3)
      game:GetService("Debris"):AddItem(BodGy, 3)
    end
    local debounce = Create("BoolValue")({
      Name = "DebounceHit",
      Parent = hit.Parent,
      Value = true
    })
    game:GetService("Debris"):AddItem(debounce, Delay)
    c = Instance.new("ObjectValue")
    c.Name = "creator"
    c.Value = Player
    c.Parent = h
    game:GetService("Debris"):AddItem(c, 0.5)
  end
end
function ShowDamage(Pos, Text, Time, Color)
coroutine.resume(coroutine.create(function()
  local Rate = 0.03333333333333333
  local Pos = Pos or Vector3.new(0, 0, 0)
  local Text = Text or ""
  local Color = Color or Color3.new(1, 0, 1)
  local EffectPart = CreatePart(Character, "SmoothPlastic", 0, 1, BrickColor.new(Color), "Effect", Vector3.new(0, 0, 0))
  EffectPart.Anchored = true
  EffectPart.CFrame = CFrame.new(Pos)
  local BillboardGui = Create("BillboardGui")({
    Size = UDim2.new(6, 0, 6, 0),
    Adornee = EffectPart,
    Parent = EffectPart,
	AlwaysOnTop=true,
	Active=true
  })
  local TextLabel = Create("TextLabel")({
    BackgroundTransparency = 1,
	AnchorPoint=Vector2.new(.5,.5),
    Position = UDim2.new(.5, 0, .5, 0),
    Size = UDim2.new(1, 0, 1, 0),
    Text = Text,
    TextColor3 = MAINRUINCOLOR,
   	TextStrokeColor3 = MAINRUINCOLOR2,
	TextStrokeTransparency=0,
    TextScaled = true,
    Font = Enum.Font.Bodoni,
    Parent = BillboardGui,
	ZIndex=4,
  })

local aaa=math.random(-360,360)
local bbb=math.random(-360,360)

  local F1 = Create("Frame")({
	AnchorPoint=Vector2.new(.5,.5),
    Position = UDim2.new(.5, 0, .5, 0),
    Size = UDim2.new(.4,0,.4,0),
    BackgroundColor3 =MAINRUINCOLOR,
    BorderColor3 =MAINRUINCOLOR2,
	BorderSizePixel=4,
    Parent = BillboardGui,
	Rotation=aaa
  })
  local F2 = Create("Frame")({
	AnchorPoint=Vector2.new(.5,.5),
    Position = UDim2.new(.5, 0, .5, 0),
    Size = UDim2.new(.4,0,.4,0),
    BackgroundColor3 =MAINRUINCOLOR,
    BorderColor3 =MAINRUINCOLOR2,
	BorderSizePixel=4,
     Parent = BillboardGui,
	Rotation=-aaa
  })
  local F3 = Create("Frame")({
	AnchorPoint=Vector2.new(.5,.5),
    Position = UDim2.new(.5, 0, .5, 0),
    Size = UDim2.new(.2,0,.2,0),
    BackgroundColor3 =MAINRUINCOLOR,
    BorderColor3 =MAINRUINCOLOR2,
	BorderSizePixel=4,
    Parent = BillboardGui,
	ZIndex=2,
	Rotation=bbb
   })
  local F4 = Create("Frame")({
	AnchorPoint=Vector2.new(.5,.5),
    Position = UDim2.new(.5, 0, .5, 0),
    Size = UDim2.new(.2,0,.2,0),
    BackgroundColor3 =MAINRUINCOLOR,
    BorderColor3 =MAINRUINCOLOR2,
	BorderSizePixel=4,
    Parent = BillboardGui,
	ZIndex=2,
 	Rotation=-bbb
   })

 --[[delay(0, function() -- no thank
    local Frames = Time / Rate
    for Frame = 1, Frames do
      wait(Rate)
      local Percent = Frame / Frames
      EffectPart.CFrame = CFrame.new(Pos) + Vector3.new(0, Percent, 0)
      TextLabel.TextTransparency = Percent
    end
    if EffectPart and EffectPart.Parent then
      EffectPart:Destroy()
    end
  end)]]
local ha=EffectPart
local oring=ha.CFrame*CFrame.new(0,3.4,0)
F1:TweenPosition(UDim2.new(.2,0,.5,0), "Out", "Quint", 1,true)
F2:TweenPosition(UDim2.new(.8,0,.5,0), "Out", "Quint", 1,true)
F3:TweenPosition(UDim2.new(-.1,0,.5,0), "Out", "Quint", 1.5,true)
F4:TweenPosition(UDim2.new(1.1,0,.5,0), "Out", "Quint", 1.5,true)
for aaa=0,1.1,Time do
swait()
ha.CFrame=clerp(ha.CFrame,oring,.1)
F1.BackgroundTransparency=0+1*aaa
F2.BackgroundTransparency=0+1*aaa
F3.BackgroundTransparency=0+.5*aaa
F4.BackgroundTransparency=0+.5*aaa
F1.Rotation=F1.Rotation+math.random(5,10)
F2.Rotation=F2.Rotation-math.random(5,10)
F3.Rotation=F3.Rotation+math.random(3,6)
F4.Rotation=F4.Rotation-math.random(3,6)
end
for aaa=0,1,.1 do
swait()
TextLabel.TextTransparency=aaa
TextLabel.TextStrokeTransparency=aaa
F3.BackgroundTransparency=.5+.5*aaa
F4.BackgroundTransparency=.5+.5*aaa
F3.Rotation=F3.Rotation+math.random(3,6)
F4.Rotation=F4.Rotation-math.random(3,6)
end
--ha:Remove()
end))
end
function MagniDamage(Part, magni, mindam, maxdam, knock, Type)
  for _, c in pairs(workspace:children()) do
    local hum = c:findFirstChildOfClass("Humanoid")
    if hum ~= nil then
      local head = c:findFirstChild("Torso")
      if head ~= nil then
        local targ = head.Position - Part.Position
        local mag = targ.magnitude
        if magni >= mag and c.Name ~= Player.Name then
          Damagefunc(head, head, mindam*attackmultiplier, maxdam*attackmultiplier, knock, Type, RootPart, 0.1, "rbxassetid://231917784", 1)
        end
      end
      local head = c:findFirstChild("UpperTorso")
      if head ~= nil then
        local targ = head.Position - Part.Position
        local mag = targ.magnitude
        if magni >= mag and c.Name ~= Player.Name then
          Damagefunc(head, head, mindam*attackmultiplier, maxdam*attackmultiplier, knock, Type, RootPart, 0.1, "rbxassetid://231917784", 1)
        end
      end
    end
  end
end


function MagniDamageWithEffect(Part, magni, mindam, maxdam, knock, Type)
  for _, c in pairs(workspace:children()) do
    local hum = c:findFirstChild("Humanoid")
    if hum ~= nil then
      local head = c:findFirstChild("Torso")
      if head ~= nil then
        local targ = head.Position - Part.Position
        local mag = targ.magnitude
        if magni >= mag and c.Name ~= Player.Name then
	MagicBlock(BrickColor.new("Pastel light blue"),head.CFrame,5,5,5,1,1,1,0.05)
          Damagefunc(head, head, mindam, maxdam, knock, Type, RootPart, 0.1, "rbxassetid://231917784", 1)
        end
      end
    end
  end
end

function rayCast(Pos, Dir, Max, Ignore)  -- Origin Position , Direction, MaxDistance , IgnoreDescendants
return game:service("Workspace"):FindPartOnRay(Ray.new(Pos, Dir.unit * (Max or 999.999)), Ignore) 
end 

function SkullEffect(brickcolor,cframe,x1,y1,z1,delay)
local prt=part(3,effectz,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=true
prt.CFrame=cframe
local msh=mesh("SpecialMesh",prt,"FileMesh","http://www.roblox.com/asset/?id=4770583",vt(0,0,0),vt(x1,y1,z1))
--http://www.roblox.com/asset/?id=4770560
game:GetService("Debris"):AddItem(prt,2)
CF=prt.CFrame
coroutine.resume(coroutine.create(function(Part,Mesh,TehCF) 
for i=0,1,0.2 do
wait()
Part.CFrame=CF*cf(0,0,-0.4)
end
for i=0,1,delay do
wait()
--Part.CFrame=CF*cf((math.random(-1,0)+math.random())/5,(math.random(-1,0)+math.random())/5,(math.random(-1,0)+math.random())/5)
Mesh.Scale=Mesh.Scale
end
for i=0,1,0.1 do
wait()
Part.Transparency=i
end
Part.Parent=nil
end),prt,msh,CF)
end
 
function MagicBlock(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay)
local prt=part(3,effectz,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=true
prt.Material = "Neon"
prt.CFrame=cframe
prt.CFrame=prt.CFrame*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))
msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
game:GetService("Debris"):AddItem(prt,5)
coroutine.resume(coroutine.create(function(Part,Mesh) 
for i=0,1,delay do
swait()
Part.CFrame=Part.CFrame*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))
Part.Transparency=i
Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
end
Part.Parent=nil
end),prt,msh)
end

function MagicBlockSteady(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay,rottype)
local prt=part(3,effectz,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=true
prt.Material = "Neon"
prt.CFrame=cframe
msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
game:GetService("Debris"):AddItem(prt,5)
coroutine.resume(coroutine.create(function(Part,Mesh) 
	local rtype = rottype
for i=0,1,delay do
swait()
if rtype == 1 then
prt.CFrame = prt.CFrame*CFrame.Angles(0,0,0.1)
elseif rtype == 2 then
prt.CFrame = prt.CFrame*CFrame.Angles(0,0,-0.1)
end
Part.Transparency=i
Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
end
Part.Parent=nil
end),prt,msh)
end

function MagicSphere(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay)
local prt=part(3,effectz,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=true
prt.CFrame=cframe
prt.CFrame=prt.CFrame*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))
msh=mesh("SpecialMesh",prt,"Sphere","",vt(0,0,0),vt(x1,y1,z1))
game:GetService("Debris"):AddItem(prt,5)
coroutine.resume(coroutine.create(function(Part,Mesh) 
for i=0,1,delay do
wait()
Part.Transparency=i
Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
end
Part.Parent=nil
end),prt,msh)
end

function MagicBlockSteady(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay,rottype)
local prt=part(3,effectz,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=true
prt.Material = "Neon"
prt.CFrame=cframe
msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
game:GetService("Debris"):AddItem(prt,5)
coroutine.resume(coroutine.create(function(Part,Mesh) 
	local rtype = rottype
for i=0,1,delay do
swait()
if rtype == 1 then
prt.CFrame = prt.CFrame*CFrame.Angles(0,0,0.1)
elseif rtype == 2 then
prt.CFrame = prt.CFrame*CFrame.Angles(0,0,-0.1)
end
Part.Transparency=i
Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
end
Part.Parent=nil
end),prt,msh)
end

function MagicShock(brickcolor,cframe,x1,y1,x3,y3,delay,rottype)
local prt=part(3,effectz,1,1,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=true
prt.Material = "Neon"
prt.CFrame=cframe
local dec = decal(prt.Color,"http://www.roblox.com/asset/?id=874580939","Front",prt)
local dec2 = decal(prt.Color,"http://www.roblox.com/asset/?id=874580939","Front",prt)
msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,0.01))
game:GetService("Debris"):AddItem(prt,5)
coroutine.resume(coroutine.create(function(Part,Mesh) 
	local rtype = rottype
for i=0,1,delay do
swait()
if rtype == 1 then
prt.CFrame = prt.CFrame*CFrame.Angles(0,0,0.1)
elseif rtype == 2 then
prt.CFrame = prt.CFrame*CFrame.Angles(0,0,-0.1)
end
dec.Transparency=i
dec2.Transparency=i
Mesh.Scale=Mesh.Scale+vt(x3,y3,0)
end
Part.Parent=nil
end),prt,msh)
end

function MagicShockAlt(brickcolor,cframe,x1,y1,x3,y3,delay,rottype)
local prt=part(3,effectz,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=true
prt.Material = "Neon"
prt.CFrame=cframe
msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,0.01))
game:GetService("Debris"):AddItem(prt,5)
coroutine.resume(coroutine.create(function(Part,Mesh) 
	local rtype = rottype
for i=0,1,delay do
swait()
if rtype == 1 then
prt.CFrame = prt.CFrame*CFrame.Angles(0,0,0.1)
elseif rtype == 2 then
prt.CFrame = prt.CFrame*CFrame.Angles(0,0,-0.1)
end
prt.Transparency=i
Mesh.Scale=Mesh.Scale+vt(x3,y3,0)
end
Part.Parent=nil
end),prt,msh)
end

function MagicShockAltCircle(brickcolor,cframe,x1,z1,x3,z3,delay,rottype)
local prt=part(3,effectz,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=true
prt.Material = "Neon"
prt.CFrame=cframe
msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,1,z1))
game:GetService("Debris"):AddItem(prt,5)
coroutine.resume(coroutine.create(function(Part,Mesh) 
	local rtype = rottype
for i=0,1,delay do
swait()
if rtype == 1 then
prt.CFrame = prt.CFrame*CFrame.Angles(0,0.1,0)
elseif rtype == 2 then
prt.CFrame = prt.CFrame*CFrame.Angles(0,-0.1,0)
end
prt.Transparency=i
Mesh.Scale=Mesh.Scale+vt(x3,0,z3)
end
Part.Parent=nil
end),prt,msh)
end

function MagicShockTrailAlt(brickcolor,cframe,x1,y1,z1,x3,y3,delay,rottype)
local prt=part(3,effectz,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=true
prt.Material = "Neon"
prt.CFrame=cframe
msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
game:GetService("Debris"):AddItem(prt,5)
coroutine.resume(coroutine.create(function(Part,Mesh) 
	local rtype = rottype
for i=0,1,delay do
swait()
if rtype == 1 then
prt.CFrame = prt.CFrame*CFrame.Angles(0,0,0.1)
elseif rtype == 2 then
prt.CFrame = prt.CFrame*CFrame.Angles(0,0,-0.1)
end
prt.Transparency=i
Mesh.Scale=Mesh.Scale+vt(x3,y3,0)
end
Part.Parent=nil
end),prt,msh)
end

function MagicShockTrailAlt2(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay,rottype)
local prt=part(3,effectz,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=true
prt.Material = "Neon"
prt.CFrame=cframe
msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
game:GetService("Debris"):AddItem(prt,5)
coroutine.resume(coroutine.create(function(Part,Mesh) 
	local rtype = rottype
for i=0,1,delay do
swait()
if rtype == 1 then
prt.CFrame = prt.CFrame*CFrame.Angles(0,0,0.1)
elseif rtype == 2 then
prt.CFrame = prt.CFrame*CFrame.Angles(0,0,-0.1)
end
prt.Transparency=i
Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
end
Part.Parent=nil
end),prt,msh)
end
 
function MagicBlock2(brickcolor,cframe,Parent,x1,y1,z1,x3,y3,z3,delay)
local prt=part(3,effectz,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=false
prt.CFrame=cframe
msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
local wld=weld(prt,prt,Parent,cframe)
game:GetService("Debris"):AddItem(prt,5)
coroutine.resume(coroutine.create(function(Part,Mesh,Weld) 
for i=0,1,delay do
wait()
Weld.C0=euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))*cframe
--Part.CFrame=Part.CFrame*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))
Part.Transparency=i
Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
end
Part.Parent=nil
end),prt,msh,wld)
end
 
function MagicBlock3(brickcolor,cframe,Parent,x1,y1,z1,x3,y3,z3,delay)
local prt=part(3,effectz,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=false
prt.CFrame=cframe
msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
local wld=weld(prt,prt,Parent,euler(0,0,0)*cf(0,0,0))
game:GetService("Debris"):AddItem(prt,5)
coroutine.resume(coroutine.create(function(Part,Mesh,Weld) 
for i=0,1,delay do
wait()
Weld.C0=euler(i*20,0,0)
--Part.CFrame=Part.CFrame*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))
Part.Transparency=i
Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
end
Part.Parent=nil
end),prt,msh,wld)
end
 
function MagicCircle2(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay)
local prt=part(3,effectz,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=true
prt.CFrame=cframe
local msh=mesh("CylinderMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
game:GetService("Debris"):AddItem(prt,2)
coroutine.resume(coroutine.create(function(Part,Mesh) 
for i=0,1,delay do
wait()
Part.CFrame=Part.CFrame
Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
local prt2=part(3,effectz,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt2.Anchored=true
prt2.CFrame=cframe*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))
local msh2=mesh("SpecialMesh",prt2,"Sphere","",vt(0,0,0),vt(0.5,0.5,0.5))
game:GetService("Debris"):AddItem(prt2,2)
coroutine.resume(coroutine.create(function(Part,Mesh) 
for i=0,1,0.1 do
wait()
Part.CFrame=Part.CFrame*cf(0,0.5,0)
end
Part.Parent=nil
end),prt2,msh2)
end
for i=0,1,delay*2 do
wait()
Part.CFrame=Part.CFrame
Mesh.Scale=vt((x1+x3)-(x1+x3)*i,(y1+y3)-(y1+y3)*i,(z1+z3)-(z1+z3)*i)
end
Part.Parent=nil
end),prt,msh)
end
 
function MagicCircle(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay)
local prt=part(3,effectz,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=true
prt.CFrame=cframe
local msh=mesh("SpecialMesh",prt,"Sphere","",vt(0,0,0),vt(x1,y1,z1))
game:GetService("Debris"):AddItem(prt,2)
coroutine.resume(coroutine.create(function(Part,Mesh) 
for i=0,1,delay do
wait()
Part.CFrame=Part.CFrame
Part.Transparency=i
Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
end
Part.Parent=nil
end),prt,msh)
end
 
function BreakEffect(brickcolor,cframe,x1,y1,z1)
local prt=part(3,effectz,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=true
prt.CFrame=cframe*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))
local msh=mesh("SpecialMesh",prt,"Sphere","",vt(0,0,0),vt(x1,y1,z1))
game:GetService("Debris"):AddItem(prt,2)
coroutine.resume(coroutine.create(function(Part,CF,Numbb,randnumb) 
CF=Part.CFrame
Numbb=0
randnumb=math.random()/10
rand1=math.random()/10
for i=0,1,rand1 do
wait()
CF=CF*cf(0,math.random()/2,0)
--Part.CFrame=Part.CFrame*euler(0.5,0,0)*cf(0,1,0)
Part.CFrame=CF*euler(Numbb,0,0)
Part.Transparency=i
Numbb=Numbb+randnumb
end
Part.Parent=nil
end),prt,CF,Numbb,randnumb)
end
 
function MagicWaveThing(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay)
local prt=part(3,effectz,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=true
prt.CFrame=cframe
msh=mesh("SpecialMesh",prt,"FileMesh","http://www.roblox.com/asset/?id=1051557",vt(0,0,0),vt(x1,y1,z1))
game:GetService("Debris"):AddItem(prt,5)
coroutine.resume(coroutine.create(function(Part,Mesh) 
for i=0,1,delay do
wait()
Part.CFrame=Part.CFrame*euler(0,0.7,0)
Part.Transparency=i
Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
end
Part.Parent=nil
end),prt,msh)
end
 
function WaveEffect(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay)
local prt=part(3,effectz,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=true
prt.CFrame=cframe
msh=mesh("SpecialMesh",prt,"FileMesh","http://www.roblox.com/asset/?id=20329976",vt(0,0,0),vt(x1,y1,z1))
game:GetService("Debris"):AddItem(prt,2)
coroutine.resume(coroutine.create(function(Part,Mesh) 
for i=0,1,delay do
wait()
Part.CFrame=Part.CFrame*cf(0,y3/2,0)
Part.Transparency=i
Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
end
Part.Parent=nil
end),prt,msh)
end
 
function StravEffect(brickcolor,cframe,x,y,z,x1,y1,z1,delay)
local prt=part(3,effectz,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=true
prt.CFrame=cframe*cf(x,y,z)
msh=mesh("SpecialMesh",prt,"FileMesh","rbxassetid://168892363",vt(0,0,0),vt(x1,y1,z1))
game:GetService("Debris"):AddItem(prt,5)
coroutine.resume(coroutine.create(function(Part,Mesh,ex,why,zee) 
local num=math.random()
local num2=math.random(-3,2)+math.random()
local numm=0
for i=0,1,delay*2 do
swait()
Part.CFrame=cframe*euler(0,numm*num*10,0)*cf(ex,why,zee)*cf(-i*10,num2,0)
Part.Transparency=i
numm=numm+0.01
end
Part.Parent=nil
Mesh.Parent=nil
end),prt,msh,x,y,z)
end

function dmgstart(dmg,what)
	hitcon = what.Touched:connect(function(hit)
		local hum = hit.Parent:FindFirstChild("Humanoid")
		if hum and not hum:IsDescendantOf(Character) then
			hum:TakeDamage(dmg)
		end
	end)
end

function dmgstop()
	hitcon:disconnect()
end

function Cloak()
Face.Parent=nil
cloaked=true
        for _,v in pairs(Torso.Parent:children()) do
                if v.className=="Part" and v.Name~="HumanoidRootPart" then
                spawn(function() 
                for i=0,1,0.2 do
                swait()
                v.Transparency=i
                end
                v.Transparency=1
                end)
                end
                if v.className=="Hat" then
                hatp=v.Handle
                coroutine.resume(coroutine.create(function(derp) 
                for i=0,1,0.2 do
                swait()
                derp.Transparency=i
                end
                derp.Transparency=1
                end),hatp)
                end
        end
        for _,v in pairs(m:children()) do
                if v.className=="Part" then
                spawn(function() 
                for i=0,1,0.2 do
                swait()
                v.Transparency=i
                end
                v.Transparency=1
                end)
                end
        end
end
 
function UnCloak()
so("http://roblox.com/asset/?id=2767090",Torso,1,1.1) 
Face.Parent=Head 
cloaked=false
        for _,v in pairs(Torso.Parent:children()) do
                if v.className=="Part" and v.Name~="HumanoidRootPart" then
                spawn(function() 
                for i=0,1,0.1 do
                swait()
                v.Transparency=v.Transparency-0.1
                end
                v.Transparency=0
                end)
                end
                if v.className=="Hat" then
                hatp=v.Handle
                coroutine.resume(coroutine.create(function(derp) 
                for i=0,1,0.1 do
                swait()
                derp.Transparency=derp.Transparency-0.1
                end
                derp.Transparency=0
                end),hatp)
                end
        end
        for _,v in pairs(m:children()) do
                if v.className=="Part" and v.Name~="hitbox" and v.Name~='tip' then
                spawn(function() 
                for i=0,1,0.1 do
                swait()
                v.Transparency=v.Transparency-0.1
                end
                v.Transparency=0
                end)
                v.Transparency=0
                end
        end
end

local origcolor = BrickColor.new("Pastel light blue").Color
---- This section of explosions.

----


function ring(type,pos,scale,value)
local type = type
local rng = Instance.new("Part", effectz)
        rng.Anchored = true
        rng.Color = origcolor
        rng.CanCollide = false
        rng.CastShadow = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshId = "http://www.roblox.com/asset/?id=3270017"
rngm.Scale = scale
local scaler2 = 1
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
spawn(function()
for i = 0,10,0.1 do
swait()
if type == "Add" then
scaler2 = scaler2 - 0.01*value
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value
end
rng.Transparency = rng.Transparency + 0.01
rngm.Scale = rngm.Scale + Vector3.new(scaler2, scaler2, 0)
end
rng:Destroy()
end)
end


function wave(type,pos,scale,value)
local type = type
local rng = Instance.new("Part", effectz)
        rng.Anchored = true
        rng.Color = origcolor
        rng.CanCollide = false
        rng.CastShadow = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshId = "http://www.roblox.com/asset/?id=20329976"
rngm.Scale = scale
local scaler2 = 1
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
spawn(function()
for i = 0,10,0.1 do
swait()
if type == "Add" then
scaler2 = scaler2 - 0.01*value
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value
end
rng.Transparency = rng.Transparency + 0.01
rngm.Scale = rngm.Scale + Vector3.new(scaler2, scaler2, scaler2)
end
rng:Destroy()
end)
end

function wind(type,pos,scale,value,speed)
local type = type
local rng = Instance.new("Part", effectz)
        rng.Anchored = true
        rng.Color = origcolor
        rng.CanCollide = false
        rng.CastShadow = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
		rng.Color = MAINRUINCOLOR
        rng.BottomSurface = 0
        rng.CFrame = pos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshId = "http://www.roblox.com/asset/?id=1051557"
rngm.Scale = scale
local scaler2 = 1
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
spawn(function()
for i = 0,10,0.1 do
swait()
if type == "Add" then
scaler2 = scaler2 - 0.01*value
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value
end
rng.CFrame = rng.CFrame*CFrame.Angles(0,0.025*speed,0)
rng.Transparency = rng.Transparency + 0.01
rngm.Scale = rngm.Scale + Vector3.new(scaler2, scaler2, scaler2)
end
rng:Destroy()
end)
end

function groundwind(type,pos,scale,value,speed)
local type = type
local rng = Instance.new("Part", effectz)
        rng.Anchored = true
        rng.Color = origcolor
        rng.CanCollide = false
        rng.CastShadow = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshId = "http://www.roblox.com/asset/?id=1051557"
rngm.Scale = scale
local scaler2 = 1
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
spawn(function()
for i = 0,10,0.1 do
swait()
if type == "Add" then
scaler2 = scaler2 - 0.01*value
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value
end
rng.CFrame = rng.CFrame*CFrame.Angles(0,0.025*speed,0)
rng.Transparency = rng.Transparency + 0.01
rngm.Scale = rngm.Scale + Vector3.new(scaler2, scaler2/5, scaler2)
end
rng:Destroy()
end)
end

function CameraManager()
  if TwoD and not CamInterrupt then
    if Humanoid.Health > 0 then
      Camera.CameraSubject = Humanoid
      Camera.CameraType = "Scriptable"
      Humanoid.AutoRotate = false
      if Booleans.GyroUse then
        Directer.MaxTorque = Vec3(0, huge, 0)
      else
        Directer.MaxTorque = Vec3(0, 0, 0)
      end
      if TargetInfo[1] ~= nil and TargetInfo[2] ~= nil then
        if Booleans.CamFollow then
          CPart.CFrame = cFrame(RootPart.Position, Vec3(TargetInfo[1].Position.X, RootPart.Position.Y, TargetInfo[1].Position.Z))
          Directer.CFrame = cFrame((RootPart.CFrame * cFrame(0, 0, 10)).p, TargetInfo[1].Position)
        else
          CPart.Position = RootPart.Position
        end
      else
        local ahead = (RootPart.CFrame * cFrame(0, 0, -3)).p
        CPart.CFrame = cFrame(RootPart.Position, Vec3(ahead.X, RootPart.Position.Y, ahead.Z))
      end
      Camera.CFrame = lerp(Camera.CFrame, CPart.CFrame * cFrame(25, 3, 0) * Euler(0, radian(90), 0), 0.2)
    else
      Camera.CameraSubject = Humanoid
      Camera.CameraType = "Custom"
    end
  end
end

function ring(type,pos,scale,value)
local type = type
local rng = Instance.new("Part", effectz)
        rng.Anchored = true
        rng.Color = origcolor
        rng.CanCollide = false
        rng.CastShadow = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshId = "http://www.roblox.com/asset/?id=3270017"
rngm.Scale = scale
local scaler2 = 1
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
spawn(function()
for i = 0,10,0.1 do
swait()
if type == "Add" then
scaler2 = scaler2 - 0.01*value
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value
end
rng.Transparency = rng.Transparency + 0.01
rngm.Scale = rngm.Scale + Vector3.new(scaler2, scaler2, 0)
end
rng:Destroy()
end)
end


function wave(type,pos,scale,value)
local type = type
local rng = Instance.new("Part", effectz)
        rng.Anchored = true
        rng.Color = origcolor
        rng.CanCollide = false
        rng.CastShadow = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshId = "http://www.roblox.com/asset/?id=20329976"
rngm.Scale = scale
local scaler2 = 1
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
spawn(function()
for i = 0,10,0.1 do
swait()
if type == "Add" then
scaler2 = scaler2 - 0.01*value
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value
end
rng.Transparency = rng.Transparency + 0.01
rngm.Scale = rngm.Scale + Vector3.new(scaler2, scaler2, scaler2)
end
rng:Destroy()
end)
end

-- Start of Pity's Variables
IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor
local SINE = 0
local ROBLOXIDLEANIMATION = IT("Animation")
ROBLOXIDLEANIMATION.Name = "Roblox Idle Animation"
ROBLOXIDLEANIMATION.AnimationId = "http://www.roblox.com/asset/?id=180435571"
--ROBLOXIDLEANIMATION.Parent = Humanoid
local WEAPONGUI = IT("ScreenGui", PlayerGui)
WEAPONGUI.Name = "eggdog"
local Weapon = IT("Model")
Weapon.Name = "Adds"
local Effects = effectz

local S = Instance.new("Sound")
function CreateSound5(ID, PARENT, VOLUME, PITCH, DOESLOOP)
	local NEWSOUND
	coroutine.resume(coroutine.create(function()
		NEWSOUND = S:Clone()
		NEWSOUND.Parent = PARENT
		NEWSOUND.Volume = VOLUME
		NEWSOUND.Pitch = PITCH
		NEWSOUND.SoundId = "rbxassetid://" .. ID
		NEWSOUND:play()
		if DOESLOOP == true then
			NEWSOUND.Looped = true
		else
			repeat
				wait(1)
			until NEWSOUND.Playing == false
			NEWSOUND:remove()
		end
	end))
	return NEWSOUND
end

function CreateMesh5(MESH, PARENT, MESHTYPE, MESHID, TEXTUREID, SCALE, OFFSET)
    local NEWMESH = IT(MESH)
    if MESH == "SpecialMesh" then
        NEWMESH.MeshType = MESHTYPE
        if MESHID ~= "nil" and MESHID ~= "" then
            NEWMESH.MeshId = "http://www.roblox.com/asset/?id="..MESHID
        end
        if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
            NEWMESH.TextureId = "http://www.roblox.com/asset/?id="..TEXTUREID
        end
    end
    NEWMESH.Offset = OFFSET or VT(0, 0, 0)
    NEWMESH.Scale = SCALE
    NEWMESH.Parent = PARENT
    return NEWMESH
end
 
function CreatePart5(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
    local NEWPART = IT("Part")
    NEWPART.formFactor = FORMFACTOR
    NEWPART.Reflectance = REFLECTANCE
    NEWPART.Transparency = TRANSPARENCY
    NEWPART.CanCollide = false
    NEWPART.Locked = true
    NEWPART.Anchored = true
    if ANCHOR == false then
        NEWPART.Anchored = false
    end
    NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
    NEWPART.Name = NAME
    NEWPART.Size = SIZE
    NEWPART.Position = Torso.Position
    NEWPART.Material = MATERIAL
    NEWPART:BreakJoints()
    NEWPART.Parent = PARENT
    return NEWPART
end

-- End of Pity's Variables --

--WACKYEFFECT({EffectType = "", Size = VT(1,1,1), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = CF(), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
--WACKYEFFECT({EffectType = "", Size = VT(1,1,1), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = CF(), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
function WACKYEFFECT(Table)
	local TYPE = (Table.EffectType or "Sphere")
	local SIZE = (Table.Size or VT(1,1,1))
	local ENDSIZE = (Table.Size2 or VT(0,0,0))
	local TRANSPARENCY = (Table.Transparency or 0)
	local ENDTRANSPARENCY = (Table.Transparency2 or 1)
	local CFRAME = (Table.CFrame or Torso.CFrame)
	local MOVEDIRECTION = (Table.MoveToPos or nil)
	local ROTATION1 = (Table.RotationX or 0)
	local ROTATION2 = (Table.RotationY or 0)
	local ROTATION3 = (Table.RotationZ or 0)
	local MATERIAL = (Table.Material or "Neon")
	local COLORLOOP = (Table.ColorLoop or false)
	local COLOR = (Table.Color or C3(1,1,1))
	local TIME = (Table.Time or 45)
	local SOUNDID = (Table.SoundID or nil)
	local SOUNDPITCH = (Table.SoundPitch or nil)
	local SOUNDVOLUME = (Table.SoundVolume or nil)
	local USEBOOMERANGMATH = (Table.UseBoomerangMath or false)
	local BOOMERANG = (Table.Boomerang or 0)
	local SIZEBOOMERANG = (Table.SizeBoomerang or 0)
	local ndjsanfdsa,eueueu = coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND = nil
		local EFFECT = CreatePart5(3, Effects, MATERIAL, 0, TRANSPARENCY, BRICKC("Pearl"), "Effect", VT(1,1,1), true)
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = CreateSound5(SOUNDID, EFFECT, SOUNDVOLUME, SOUNDPITCH, false)
		end
		EFFECT.Color = COLOR
		local MSH = nil
		if TYPE == "Sphere" then
			MSH = CreateMesh5("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, VT(0,0,0))
		elseif TYPE == "Block" or TYPE == "Box" then
			MSH = IT("BlockMesh",EFFECT)
			MSH.Scale = SIZE
		elseif TYPE == "Wedge" then
			MSH = CreateMesh5("SpecialMesh", EFFECT, "Wedge", "", "", SIZE, VT(0,0,0))	
		elseif TYPE == "Wave" then
			MSH = CreateMesh5("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, VT(0,0,-SIZE.X/8))
		elseif TYPE == "Ring" then
			MSH = CreateMesh5("SpecialMesh", EFFECT, "FileMesh", "559831844", "", VT(SIZE.X,SIZE.X,0.1), VT(0,0,0))
		elseif TYPE == "Slash" then
			MSH = CreateMesh5("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Round Slash" then
			MSH = CreateMesh5("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Swirl" then
			MSH = CreateMesh5("SpecialMesh", EFFECT, "FileMesh", "168892432", "", SIZE, VT(0,0,0))
		elseif TYPE == "Skull" then
			MSH = CreateMesh5("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, VT(0,0,0))
		elseif TYPE == "Crystal" then
			MSH = CreateMesh5("SpecialMesh", EFFECT, "FileMesh", "9756362", "", SIZE, VT(0,0,0))
		elseif TYPE == "Heart" then
			MSH = CreateMesh5("SpecialMesh", EFFECT, "FileMesh", "105992239", "", SIZE, VT(0,0,0))
		elseif TYPE == "Note" then
			MSH = CreateMesh5("SpecialMesh", EFFECT, "FileMesh", "989516523", "", SIZE, VT(0,0,0))
		end
		if MSH ~= nil then
			local BOOMR1 = 1+BOOMERANG/50
			local BOOMR2 = 1+SIZEBOOMERANG/50
			local MOVESPEED = nil
			if MOVEDIRECTION ~= nil then
				if USEBOOMERANGMATH == true then
					MOVESPEED = ((CFRAME.p - MOVEDIRECTION).Magnitude/TIME)*BOOMR1
				else
					MOVESPEED = ((CFRAME.p - MOVEDIRECTION).Magnitude/TIME)
				end
			end
			local GROWTH = nil
			if USEBOOMERANGMATH == true then
				GROWTH = (SIZE - ENDSIZE)*(BOOMR2+1)
			else
				GROWTH = (SIZE - ENDSIZE)
			end
			local TRANS = TRANSPARENCY - ENDTRANSPARENCY
			EFFECT.CFrame = CFRAME
			if USEBOOMERANGMATH == true then
				for LOOP = 1, TIME+1 do
					swait()
					if COLORLOOP == true then
					EFFECT.Color = COLOR
					end
					MSH.Scale = MSH.Scale - (VT((GROWTH.X)*((1 - (LOOP/TIME)*BOOMR2)),(GROWTH.Y)*((1 - (LOOP/TIME)*BOOMR2)),(GROWTH.Z)*((1 - (LOOP/TIME)*BOOMR2)))*BOOMR2)/TIME
					if TYPE == "Wave" then
						MSH.Offset = VT(0,0,-MSH.Scale.Z/8)
					end
					EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
					EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
					if MOVEDIRECTION ~= nil then
						local ORI = EFFECT.Orientation
						EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-(MOVESPEED)*((1 - (LOOP/TIME)*BOOMR1)))
						EFFECT.Orientation = ORI
					end
				end
			else
				for LOOP = 1, TIME+1 do
					swait()
					if COLORLOOP == true then
						EFFECT.Color = COLOR
					end
					MSH.Scale = MSH.Scale - GROWTH/TIME
					if TYPE == "Wave" then
						MSH.Offset = VT(0,0,-MSH.Scale.Z/8)
					end
					EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
					if TYPE == "Block" then
						EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
					else
						EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
					end
					if MOVEDIRECTION ~= nil then
						local ORI = EFFECT.Orientation
						EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-MOVESPEED)
						EFFECT.Orientation = ORI
					end
				end
			end
			EFFECT.Transparency = 1
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat swait() until EFFECT:FindFirstChildOfClass("Sound") == nil
				EFFECT:remove()
			end
		else
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat swait() until EFFECT:FindFirstChildOfClass("Sound") == nil
				EFFECT:remove()
			end
		end
	end))
	if not ndjsanfdsa then
		print(eueueu)
	end
end

-- Salvo's Effect Functions
tin = TweenInfo.new
TW=game:GetService("TweenService")

function NoOutline(Part)
Part.TopSurface,Part.BottomSurface,Part.LeftSurface,Part.RightSurface,Part.FrontSurface,Part.BackSurface=10,10,10,10,10,10
end

function TAnim(obj,Aniim,tim,esty,edir,rep,go,del)
local infos=tin(tim,Enum.EasingStyle[esty],Enum.EasingDirection[edir],rep,go,del)
local tween=TW:Create(obj,infos,Aniim)
tween:Play()
return tween
end

function parts(Par,name,size,color,mat,ref,tra)
local part=Create("Part"){
Parent=Par,
Name=name,
Size=size,
CanCollide=false,
Anchored=false,
BrickColor=BrickColor.new(color),
Material=mat,
Reflectance=ref,
Transparency=tra}
--Position=Torso.Position}
NoOutline(part)
part:BreakJoints()
return part 
end

function meshs(Par,name,scale,mtype,id)
local mesh=Create("SpecialMesh"){
Parent=Par,
Name=name,
Scale=scale,
MeshType=mtype}
if id~="" then
mesh.MeshId="rbxassetid://"..id
end
return mesh
end

local e = effectz
v2n=Vector2.new
v3n=Vector3.new
cfn=CFrame.new
cfa=CFrame.Angles
mrad=math.rad
mran=math.random
c3c=Color3.new
c3frgb=Color3.fromRGB
UD2=UDim2.new
tin=TweenInfo.new


function TEffect(bc,cf,gof,x1,y1,z1,x3,y3,z3,rad,rad2,mtype,etype,etype2,etype3,tr,tr2,tim,esty,edir,gtim,gesty,gedir,x4,y4,z4)
local h1=parts(e,"Omg Its neon effects",v3n(.2,.2,.2),"Really red",Enum.Material.Neon,0,0)
h1.Color=bc
h1.CFrame=cf
h1.Anchored=true
local h2=meshs(h1,"Mesh",v3n(0,0,0),"Brick","")
h2.MeshType=mtype
h2.Scale=v3n(x1,y1,z1)
coroutine.resume(coroutine.create(function()
if tr then
h1.Transparency=1
end

local waait
TAnim(h1,{Transparency=0},tim,esty,edir,0,false,0)
if etype=="MF" then
TAnim(h1,{CFrame=gof},tim,esty,edir,0,false,0)
end

if etype3=="Feather" then --buggy af
coroutine.resume(coroutine.create(function()
local ez=h1.CFrame
local nu=0
local no=mran()-mran()
repeat
swait()
nu=nu+no
ez=ez*cfn(0,rad,0)
TAnim(h1,{CFrame=ez*cfa(nu,0,0)},.1,esty,edir,0,false,0)

--j.CFrame=ez*cfa(nu,0,0)
until h1.Parent==nil
end),h1)
end

waait=TAnim(h2,{Scale=v3n(x3,y3,z3)},tim,esty,edir,0,false,0)
waait.Completed:Wait()

if etype=="MB" then
if etype3~="Feather" then
TAnim(h1,{CFrame=gof},tim,esty,edir,0,false,0)
end
end

if etype2=="Shrink" then
waait=TAnim(h2,{Scale=v3n(0,0,0)},gtim,gesty,gedir,0,false,0)
elseif etype2=="Continue" then
waait=TAnim(h2,{Scale=v3n(x4,y4,z4)},gtim,gesty,gedir,0,false,0)
elseif etype2=="Spin" then
waait=TAnim(h2,{Scale=v3n(x4,y4,z4)},gtim,gesty,gedir,0,false,0)
coroutine.resume(coroutine.create(function(j)
local rad3=0
repeat
swait()
rad3=rad3+rad
if rad2==1 then
TAnim(j,{CFrame=gof*cfa(mrad(rad3),0,0)},.02,gesty,"Out",0,false,0)
elseif rad2==2 then
TAnim(j,{CFrame=gof*cfa(0,mrad(rad3),0)},.02,gesty,"Out",0,false,0)
elseif rad2==3 then
TAnim(j,{CFrame=gof*cfa(0,0,mrad(rad3))},.02,gesty,"Out",0,false,0)
end

until j.Parent==nil
end),h1)
end

if tr2 then
TAnim(h1,{Transparency=1},gtim,gesty,gedir,0,false,0)
end

waait.Completed:Wait()

h1:Remove()
end))
return h1
end

function TEffect2(bc,cf,gof,x1,y1,z1,x3,y3,z3,starttrans,endtrans,rad,fff,mtype,etype3,tr,tim,esty,edir,tim2,filemeshthingy)
local h1=parts(e,"Omg Its neon effects",v3n(.2,.2,.2),"Really red",Enum.Material.Neon,0,0)
h1.Color=bc
h1.CFrame=cf
h1.Transparency = starttrans
h1.Anchored=true
local h2=meshs(h1,"Mesh",v3n(0,0,0),"Brick","")
h2.MeshType=mtype
h2.Scale=v3n(x1,y1,z1)
coroutine.resume(coroutine.create(function()


local waait

if etype3=="Feather" then --buggy af
coroutine.resume(coroutine.create(function(j)
local ez=j.CFrame
local nu=0
local no=mran()-mran()
repeat
swait()
nu=nu+no
ez=ez*cfn(0,rad,0)
TAnim(h1,{CFrame=ez*cfa(nu,0,0)},.1,esty,edir,0,false,0)

--j.CFrame=ez*cfa(nu,0,0)
until j.Parent==nil
end),h1)
end

if etype3~="Feather" then
if fff then
TAnim(h2,{Scale=v3n(x3,y3,z3)},tim,esty,edir,0,false,0)
waait=TAnim(h1,{Transparency=0,CFrame=gof},tim,esty,edir,0,false,0)
waait.Completed:Wait()
else
TAnim(h2,{Scale=v3n(x3,y3,z3)},tim,esty,edir,0,false,0)
end
end

if tr then	
waait=TAnim(h1,{Transparency=endtrans,CFrame=gof},tim2,esty,edir,0,false,0)
waait.Completed:Wait()
else
waait=TAnim(h1,{Transparency=starttrans,CFrame=gof},tim2,esty,edir,0,false,0)
waait.Completed:Wait()
end



h1:Remove()
end))
return h1
end

function TEffect3(bc,cf,gof,x1,y1,z1,x3,y3,z3,rad,fff,mtype,etype3,tr,tim,esty,edir,tim2)
local h1=parts(e,"neon effects",v3n(x1,y1,z1),"Really red",Enum.Material.Neon,0,0)
h1.Color=bc
h1.CFrame=cf
h1.Anchored=true
local h2=meshs(h1,"Mesh",v3n(0,0,0),"Brick","")
h2.MeshType=mtype
h2.Scale=v3n(1,1,1)
coroutine.resume(coroutine.create(function()


local waait

if etype3=="Feather" then --buggy af
coroutine.resume(coroutine.create(function(j)
local ez=j.CFrame
local nu=0
local no=mran()-mran()
repeat
swait()
nu=nu+no
ez=ez*cfn(0,rad,0)
TAnim(h1,{CFrame=ez*cfa(nu,0,0)},.1,esty,edir,0,false,0)

--j.CFrame=ez*cfa(nu,0,0)
until j.Parent==nil
end),h1)
end

if etype3~="Feather" then
if fff then
waait=TAnim(h1,{Transparency=0,CFrame=gof,Size=v3n(x3,y3,z3)},tim,esty,edir,0,false,0)
waait.Completed:Wait()
else
TAnim(h1,{Size=v3n(x3,y3,z3)},tim,esty,edir,0,false,0)
end
end

if tr then	
waait=TAnim(h1,{Transparency=1},tim2,"Quad","In",0,false,0)
waait.Completed:Wait()
end

for _,ss in pairs(h1:children()) do
if ss:IsA("ParticleEmitter")or ss:IsA("Trail")or ss:IsA("Beam")then
ss.Enabled=false
end
end
game:GetService("Debris"):AddItem(h1,3)
--h1:Remove()
end))
return h1
end

function TEffect4(bc,cf,x1,y1,z1,x3,y3,z3,mtype,tr,tim,esty,edir)
local h1=parts(e,"neon effects",v3n(.2,.2,.2),"Really red",Enum.Material.Neon,0,0)
h1.Color=bc
h1.CFrame=cf
h1.Anchored=true
local h2=meshs(h1,"Mesh",v3n(x1,y1,z1),mtype,"")
coroutine.resume(coroutine.create(function()
local waait
if tr then	
TAnim(h2,{Scale=v3n(x3,y3,z3)},tim,esty,edir,0,false,0)
waait=TAnim(h1,{Transparency=1},tim,esty,edir,0,false,0)
waait.Completed:Wait()
else
TAnim(h2,{Scale=v3n(x3,y3,z3)},tim,esty,edir,0,false,0)
waait=TAnim(h1,{Transparency=0},tim,esty,edir,0,false,0)
waait.Completed:Wait()
end
h1:Remove()
end))
return h1
end


function sphere(bonuspeed,type,pos,scale,value,color)
local type = type
local rng = Instance.new("Part", effectz)
        rng.Anchored = true
if ModeOfGlitch ~= 9 then
        rng.Color = color
elseif ModeOfGlitch == 9 then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
end
        rng.CanCollide = false
        rng.CastShadow = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Sphere"
rngm.Scale = scale
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
if ModeOfGlitch == 9 then
spawn(function()
while true do
swait()
if rng.Parent ~= nil then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
else
break
end
end
end)
end
local scaler2 = 1
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
spawn(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
end
if chaosmode == true then
rng.Color = BrickColor.random()
end
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, scaler2*bonuspeed)
end
rng:Destroy()
end)
end


function block2(bonuspeed,type,pos,scale,value,value2,value3,color)
local type = type
local rng = Instance.new("Part", effectz)
        rng.Anchored = true
if ModeOfGlitch ~= 9 then
        rng.Color = color
elseif ModeOfGlitch == 9 then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
end
        rng.CanCollide = false
        rng.CastShadow = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Brick"
rngm.Scale = scale
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
local scaler2 = 1
local scaler2b = 1
local scaler2c = 1
if type == "Add" then
scaler2 = 1*value
scaler2b = 1*value2
scaler2c = 1*value3
elseif type == "Divide" then
scaler2 = 1/value
scaler2b = 1/value2
scaler2c = 1/value3
end
if ModeOfGlitch == 9 then
spawn(function()
while true do
swait()
if rng.Parent ~= nil then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
else
break
end
end
end)
end
spawn(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
scaler2b = scaler2b - 0.01*value/bonuspeed
scaler2c = scaler2c - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
scaler2b = scaler2b - 0.01/value*bonuspeed
scaler2c = scaler2c - 0.01/value*bonuspeed
end
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2b*bonuspeed, scaler2c*bonuspeed)
end
rng:Destroy()
end)
end


function sphere2(bonuspeed,type,pos,scale,value,value2,value3,color)
local type = type
local rng = Instance.new("Part", effectz)
        rng.Anchored = true
if ModeOfGlitch ~= 9 then
        rng.Color = color
elseif ModeOfGlitch == 9 then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
end
        rng.CanCollide = false
        rng.CastShadow = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Sphere"
rngm.Scale = scale
local scaler2 = 1
local scaler2b = 1
local scaler2c = 1
if type == "Add" then
scaler2 = 1*value
scaler2b = 1*value2
scaler2c = 1*value3
elseif type == "Divide" then
scaler2 = 1/value
scaler2b = 1/value2
scaler2c = 1/value3
end
if ModeOfGlitch == 9 then
spawn(function()
while true do
swait()
if rng.Parent ~= nil then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
else
break
end
end
end)
end
spawn(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
scaler2b = scaler2b - 0.01*value/bonuspeed
scaler2c = scaler2c - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
scaler2b = scaler2b - 0.01/value*bonuspeed
scaler2c = scaler2c - 0.01/value*bonuspeed
end
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2b*bonuspeed, scaler2c*bonuspeed)
end
rng:Destroy()
end)
end


function spherec(bonuspeed,type,pos,scale,value,value2,value3,color)
local type = type
local rng = Instance.new("Part", effectz)
        rng.Anchored = true
        rng.Color = color
        rng.CanCollide = false
        rng.CastShadow = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Sphere"
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
rngm.Scale = scale
local scaler2 = 1
local scaler2b = 1
local scaler2c = 1
if type == "Add" then
scaler2 = 1*value
scaler2b = 1*value2
scaler2c = 1*value3
elseif type == "Divide" then
scaler2 = 1/value
scaler2b = 1/value2
scaler2c = 1/value3
end
if ModeOfGlitch == 9 then
spawn(function()
while true do
swait()
if rng.Parent ~= nil then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
else
break
end
end
end)
end
spawn(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if chaosmode == true then
rng.Color = Color3.fromRGB(math.random(0,255),math.random(0,255),math.random(0,255))
end
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
scaler2b = scaler2b - 0.01*value/bonuspeed
scaler2c = scaler2c - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
scaler2b = scaler2b - 0.01/value*bonuspeed
scaler2c = scaler2c - 0.01/value*bonuspeed
end
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2b*bonuspeed, scaler2c*bonuspeed)
end
rng:Destroy()
end)
end


function shard1(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
local type = type
local rng = Instance.new("Part", effectz)
        rng.Anchored = true
if ModeOfGlitch ~= 9 then
        rng.Color = color
elseif ModeOfGlitch == 9 then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
end
        rng.CanCollide = false
        rng.CastShadow = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Wedge"
rngm.Scale = vt(x1,y1,z1)
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
if ModeOfGlitch == 9 then
spawn(function()
while true do
swait()
if rng.Parent ~= nil then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
else
break
end
end
end)
end
local scaler2 = 1
local speeder = FastSpeed
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
spawn(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
end
if chaosmode == true then
rng.Color = BrickColor.random()
end
speeder = speeder - 0.01*FastSpeed*bonuspeed
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, 0)
end
rng:Destroy()
end)
end


function slash(bonuspeed,rotspeed,rotatingop,typeofshape,type,typeoftrans,pos,scale,value,color)
local type = type
local rotenable = rotatingop
local rng = Instance.new("Part", effectz)
        rng.Anchored = true
        rng.Color = color
        rng.CanCollide = false
        rng.CastShadow = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
if typeoftrans == "In" then
rng.Transparency = 1
end
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "FileMesh"
if typeofshape == "Normal" then
rngm.MeshId = "rbxassetid://662586858"
elseif typeofshape == "Round" then
rngm.MeshId = "rbxassetid://662585058"
end
rngm.Scale = scale
local scaler2 = 1/10
if type == "Add" then
scaler2 = 1*value/10
elseif type == "Divide" then
scaler2 = 1/value/10
end
local randomrot = math.random(1,2)
spawn(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed/10
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed/10
end
if rotenable == true then
if randomrot == 1 then
rng.CFrame = rng.CFrame*CFrame.Angles(0,math.rad(rotspeed*bonuspeed/2),0)
elseif randomrot == 2 then
rng.CFrame = rng.CFrame*CFrame.Angles(0,math.rad(-rotspeed*bonuspeed/2),0)
end
end
if typeoftrans == "Out" then
rng.Transparency = rng.Transparency + 0.01*bonuspeed
elseif typeoftrans == "In" then
rng.Transparency = rng.Transparency - 0.01*bonuspeed
end
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed/10, 0, scaler2*bonuspeed/10)
end
rng:Destroy()
end)
end

function PixelBlock(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
local type = type
local rng = Instance.new("Part", effectz)
        rng.Anchored = true
        rng.Color = color
        rng.CanCollide = false
        rng.CastShadow = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Brick"
rngm.Scale = vt(x1,y1,z1)
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
local scaler2 = 1
local speeder = FastSpeed/10
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
spawn(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
end
if chaosmode == true then
rng.Color = BrickColor.random()
end
speeder = speeder - 0.01*FastSpeed*bonuspeed/10
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
--rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale - Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, scaler2*bonuspeed)
end
rng:Destroy()
end)
end

function PixelBlockX(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
local type = type
local rng = Instance.new("Part", effectz)
        rng.Anchored = true
        rng.Color = color
        rng.CanCollide = false
        rng.CastShadow = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Brick"
rngm.Scale = vt(x1,y1,z1)
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
local scaler2 = 1
local speeder = FastSpeed/10
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
spawn(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
end
if chaosmode == true then
rng.Color = BrickColor.random()
end
speeder = speeder - 0.01*FastSpeed*bonuspeed/10
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale - Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, scaler2*bonuspeed)
end
rng:Destroy()
end)
end

function PixelBlockNeg(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
local type = type
local rng = Instance.new("Part", effectz)
        rng.Anchored = true
        rng.Color = color
        rng.CanCollide = false
        rng.CastShadow = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Brick"
rngm.Scale = vt(x1,y1,z1)
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
local scaler2 = 0
local speeder = FastSpeed/10
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
spawn(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
end
if chaosmode == true then
rng.Color = BrickColor.random()
end
speeder = speeder + 0.01*FastSpeed*bonuspeed/10
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
--rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale - Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, scaler2*bonuspeed)
end
rng:Destroy()
end)
end

function block(bonuspeed,type,pos,scale,value,value2,value3,color,color3)
local type = type
local rng = Instance.new("Part", effectz)
        rng.Anchored = true
        rng.Color = color
        rng.Color = color3
        rng.CanCollide = false
        rng.CastShadow = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Brick"
rngm.Scale = scale
local scaler2 = 1
local scaler2b = 1
local scaler2c = 1
if type == "Add" then
scaler2 = 1*value
scaler2b = 1*value2
scaler2c = 1*value3
elseif type == "Divide" then
scaler2 = 1/value
scaler2b = 1/value2
scaler2c = 1/value3
end
spawn(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
scaler2b = scaler2b - 0.01*value/bonuspeed
scaler2c = scaler2c - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
scaler2b = scaler2b - 0.01/value*bonuspeed
scaler2c = scaler2c - 0.01/value*bonuspeed
end
rng.CFrame = rng.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2b*bonuspeed, scaler2c*bonuspeed)
end
rng:Destroy()
end)
end

local TweenService = game:GetService("TweenService")
function TweenFunction(part, X, Y, Z, T, LENGTH)
	local TweenP = part
	local TweenI = TweenInfo.new(LENGTH, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0)
	local TweenG = {
		Size = Vector3.new(X, Y, Z),
		Transparency = T
	}
	local Tween = TweenService:Create(TweenP, TweenI, TweenG)
	Tween:Play()
end
function TweenFunctionMESH(part, X, Y, Z, LENGTH)
	local TweenP = part
	local TweenI = TweenInfo.new(LENGTH, Enum.EasingStyle.Linear, Enum.EasingDirection.In, 0, false, 0)
	local TweenG = {
		Scale = Vector3.new(X, Y, Z)
	}
	local Tween = TweenService:Create(TweenP, TweenI, TweenG)
	Tween:Play()
end
function ScreenBars(watval)
	spawn(function()
		Gui.BottomBar:TweenPosition(UDim2.new(0, 0, 1, 0), "Out", "Quint", 1, true)
		Gui.TopBar:TweenPosition(UDim2.new(0, 0, 0, -36), "Out", "Quint", 1, true)
		wait(watval)
		Gui.BottomBar:TweenPosition(UDim2.new(-0.009, 0, 1.136, 0), "Out", "Quint", 1, true)
		Gui.TopBar:TweenPosition(UDim2.new(0, 0, 0, -115), "Out", "Quint", 1, true)
	end)
end
	function focus(cframe,power,length)
	for i,v in pairs(game:GetService("Players"):GetChildren()) do
	local var = script.Effects.focus:Clone()
	var.Parent = v.PlayerGui
	local pw = var.Shakeval
	local lgth = var.MultLength
	local playervaluething = var.Player
	local Cframes = var.CFrame
	Cframes.Value = cframe
	pw.Value = power
	lgth.Value = length
	playervaluething.Value = plr.Name
	var.Disabled = false
	end
	end
	
function shardEffect(CFRAME, R, G, B)
	spawn(function()
		for i = 1, 10 do
			do
				local WP = Instance.new("WedgePart")
				WP.Anchored = true
				WP.CanCollide = false
				WP.Size = Vector3.new(0.05, 10, 10.6)
				WP.Material = "Neon"
				WP.Color = MAINRUINCOLOR
				WP.CFrame = CFRAME * CFrame.Angles(math.random(0, 360), math.random(0, 360), math.random(0, 360))
				WP.Parent = effectz
				TweenFunction(WP, 0.05, 1.22, 1.41, 1, 1)
				game.Debris:AddItem(WP, 1)
				local TP = Instance.new("Part")
				TP.Anchored = true
				TP.CanCollide = false
				TP.Size = Vector3.new(0.05, 1.22, 1.41)
				TP.Material = "Neon"
				TP.Transparency = 1
				TP.CFrame = CFRAME * CFrame.new(math.random(-100, 100), math.random(-100, 100), math.random(-100, 100)) * CFrame.Angles(math.random(0, 360), math.random(0, 360), math.random(0, 360))
				TP.Parent = effectz
				game.Debris:AddItem(TP, 5)
				spawn(function()
					for i = 0, 5, 0.25 do
						swait(2)
						WP.CFrame = WP.CFrame:lerp(TP.CFrame, 0.05)
					end
				end)
			end
		end
	end)
end

-- Credits to Gek for the Effect function!

function sphereRotMK(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
local type = type
local rng = Instance.new("Part", effectz)
        rng.Anchored = true
local ya = math.random(-5,5)
local xa = math.random(-5,5)
local za = math.random(-5,5)
local y2a = 0
local x2a = 0
local z2a = 0
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
		rng.Color = color
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Sphere"
rngm.Scale = vt(x1,y1,z1)
if ModeOfGlitch == 9 then
coroutine.resume(coroutine.create(function()
while true do
swait()
if rng.Parent ~= nil then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
else
break
end
end
end))
end
local scaler2 = 1
local speeder = FastSpeed
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()
y2a=y2a+ya
z2a=z2a+za
x2a=x2a+xa
 rng.CFrame =  rng.CFrame*CFrame.Angles(math.rad(ya),math.rad(za),math.rad(xa))
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
end
if chaosmode == true then
rng.Color = BrickColor.random()
end
speeder = speeder - 0.01*FastSpeed*bonuspeed
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, 0)
end
rng:Destroy()
end))
end
function sphereRot2MK(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
local type = type
local rng = Instance.new("Part", char)
        rng.Anchored = true
if ModeOfGlitch ~= 9 then
        rng.Color = color
elseif ModeOfGlitch == 9 then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
end
local ya = 5
local xa = 5
local za = 5
local y2a = 0
local x2a = 0
local z2a = 0
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Sphere"
rngm.Scale = vt(x1,y1,z1)
if ModeOfGlitch == 9 then
coroutine.resume(coroutine.create(function()
while true do
swait()
if rng.Parent ~= nil then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
else
break
end
end
end))
end
local scaler2 = 1
local speeder = FastSpeed
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()
y2a=y2a+ya
z2a=z2a+za
x2a=x2a+xa
 rng.CFrame =  rng.CFrame*CFrame.Angles(math.rad(ya),math.rad(za),math.rad(xa))
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
end
if chaosmode == true then
rng.Color = BrickColor.random()
end
speeder = speeder - 0.01*FastSpeed*bonuspeed
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, 0)
end
rng:Destroy()
end))
end
function sphereRot2(bonuspeed,type,pos,scale,value,value2,value3,color)
local type = type
local rng = Instance.new("Part", char)
        rng.Anchored = true
if ModeOfGlitch ~= 9 then
        rng.Color = color
elseif ModeOfGlitch == 9 then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
end
local ya = math.random(1,5)
local xa = math.random(1,5)
local za = math.random(1,5)
local y2a = 0
local x2a = 0
local z2a = 0
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Sphere"
rngm.Scale = scale
local scaler2 = 1
local scaler2b = 1
local scaler2c = 1
if type == "Add" then
scaler2 = 1*value
scaler2b = 1*value2
scaler2c = 1*value3
elseif type == "Divide" then
scaler2 = 1/value
scaler2b = 1/value2
scaler2c = 1/value3
end
if ModeOfGlitch == 9 then
coroutine.resume(coroutine.create(function()
while true do
swait()
if rng.Parent ~= nil then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
else
break
end
end
end))
end
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()
y2a=y2a+ya
z2a=z2a+za
x2a=x2a+xa
 rng.CFrame =  rng.CFrame*CFrame.Angles(math.rad(ya),math.rad(za),math.rad(xa))
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
scaler2b = scaler2b - 0.01*value/bonuspeed
scaler2c = scaler2c - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
scaler2b = scaler2b - 0.01/value*bonuspeed
scaler2c = scaler2c - 0.01/value*bonuspeed
end
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2b*bonuspeed, scaler2c*bonuspeed)
end
rng:Destroy()
end))
end

function sphereRev2(bonuspeed,type,pos,scale,value,value2,value3,color)
local type = type
local rng = Instance.new("Part", char)
        rng.Anchored = true
if ModeOfGlitch ~= 9 then
        rng.Color = color
elseif ModeOfGlitch == 9 then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
end
local ya = math.random(1,5)
local xa = math.random(1,5)
local za = math.random(1,5)
local y2a = 0
local x2a = 0
local z2a = 0
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 1
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Sphere"
rngm.Scale = scale
local scaler2 = 1
local scaler2b = 1
local scaler2c = 1
if type == "Add" then
scaler2 = 1*value
scaler2b = 1*value2
scaler2c = 1*value3
elseif type == "Divide" then
scaler2 = 1/value
scaler2b = 1/value2
scaler2c = 1/value3
end
if ModeOfGlitch == 9 then
coroutine.resume(coroutine.create(function()
while true do
swait()
if rng.Parent ~= nil then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
else
break
end
end
end))
end
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
scaler2b = scaler2b - 0.01*value/bonuspeed
scaler2c = scaler2c - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
scaler2b = scaler2b - 0.01/value*bonuspeed
scaler2c = scaler2c - 0.01/value*bonuspeed
end
rng.Transparency = rng.Transparency - 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2b*bonuspeed, scaler2c*bonuspeed)
end
rng:Destroy()
end))
end

function sphereSRot2(bonuspeed,type,pos,scale,value,value2,value3,color)
local type = type
local rng = Instance.new("Part", char)
        rng.Anchored = true
if ModeOfGlitch ~= 9 then
        rng.Color = color
elseif ModeOfGlitch == 9 then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
end
local ya = math.random(1,5)
local xa = math.random(1,5)
local za = math.random(1,5)
local y2a = 0
local x2a = 0
local z2a = 0
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Sphere"
rngm.Scale = scale
local scaler2 = 1
local scaler2b = 1
local scaler2c = 1
if type == "Add" then
scaler2 = 1*value
scaler2b = 1*value2
scaler2c = 1*value3
elseif type == "Divide" then
scaler2 = 1/value
scaler2b = 1/value2
scaler2c = 1/value3
end
if ModeOfGlitch == 9 then
coroutine.resume(coroutine.create(function()
while true do
swait()
if rng.Parent ~= nil then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
else
break
end
end
end))
end
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()
y2a=y2a+ya
z2a=z2a+za
x2a=x2a+xa
 rng.CFrame = pos
 rng.CFrame =  rng.CFrame*CFrame.Angles(math.rad(ya),math.rad(za),math.rad(xa))
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
scaler2b = scaler2b - 0.01*value/bonuspeed
scaler2c = scaler2c - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
scaler2b = scaler2b - 0.01/value*bonuspeed
scaler2c = scaler2c - 0.01/value*bonuspeed
end
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2b*bonuspeed, scaler2c*bonuspeed)
end
rng:Destroy()
end))
end

function sphereMK(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
local type = type
local rng = Instance.new("Part", effectz)
        rng.Anchored = true
if ModeOfGlitch ~= 9 then
        rng.Color = color
elseif ModeOfGlitch == 9 then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
end
        rng.CanCollide = false
        rng.CastShadow = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Sphere"
rngm.Scale = vt(x1,y1,z1)
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
if ModeOfGlitch == 9 then
spawn(function()
while true do
swait()
if rng.Parent ~= nil then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
else
break
end
end
end)
end
local scaler2 = 1
local speeder = FastSpeed
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
spawn(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
end
if chaosmode == true then
rng.Color = BrickColor.random()
end
speeder = speeder - 0.01*FastSpeed*bonuspeed
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, 0)
end
rng:Destroy()
end)
end

function sphereMKColor(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
local type = type
local rng = Instance.new("Part", script.CurrentEffects)
        rng.Anchored = true
        rng.Color = color
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Sphere"
rngm.Scale = Vector3.new(x1,y1,z1)
local scaler2 = 1
local speeder = FastSpeed
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
end
speeder = speeder - 0.01*FastSpeed*bonuspeed
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, 0)
end
rng:Destroy()
end))
end

function spinsquare(bonuspeed,FastSpeed,type,pos,sideleng,value,color,outerpos)
local type = type
local rng = Instance.new("Part", script.CurrentEffects)
        rng.Anchored = true
        rng.Color = color
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(sideleng,.1,sideleng)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
local lookvec = rng.CFrame.lookVector
local scaler2 = 1
local speeder = FastSpeed
local spinval = math.random(1,10)
if math.random(1,2) == 1 then
	spinval = 0 - spinval
end
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
end
speeder = speeder - 0.01*FastSpeed*bonuspeed
rng.CFrame = rng.CFrame + lookvec*speeder*bonuspeed
rng.Orientation = Vector3.new(0,sine*spinval,0)
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rng.Size = rng.Size - Vector3.new(scaler2*bonuspeed, 0, scaler2*bonuspeed)
end
rng:Destroy()
end))
end


function sphereMKt(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
local type = type
local rng = Instance.new("Part", effectz)
        rng.Anchored = true
if ModeOfGlitch ~= 9 then
        rng.Color = color
elseif ModeOfGlitch == 9 then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
end
        rng.CanCollide = false
        rng.CastShadow = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Sphere"
rngm.Scale = vt(x1,y1,z1)
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
if ModeOfGlitch == 9 then
spawn(function()
while true do
swait()
if rng.Parent ~= nil then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
else
break
end
end
end)
end
local scaler2 = 1
local speeder = FastSpeed
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
spawn(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
end
if chaosmode == true then
rng.Color = BrickColor.random()
end
speeder = speeder - 0.01*FastSpeed*bonuspeed
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, 0)
end
TweenAnimate(rng,{C0=rng.CFrame*rng.CFrame.lookVector*speeder*bonuspeed},0.3,"Back","Out",0,false,0)
TweenAnimate(rng,{C0=rng.CFrame*rng.CFrame.lookVector*speeder*bonuspeed},0.3,"Back","Out",0,false,0)
rng:Destroy()
end)
end

function sphereMKr(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
local type = type
local rng = Instance.new("Part", effectz)
        rng.Anchored = true
if ModeOfGlitch ~= 9 then
        rng.Color = color
elseif ModeOfGlitch == 9 then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
end
        rng.CanCollide = false
        rng.CastShadow = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Sphere"
rngm.Scale = vt(x1,y1,z1)
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
if ModeOfGlitch == 9 then
spawn(function()
while true do
swait()
if rng.Parent ~= nil then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
else
break
end
end
end)
end
local scaler2 = 1
local speeder = FastSpeed
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
spawn(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
end
if chaosmode == true then
rng.Color = BrickColor.random()
end
speeder = speeder - 0.01*FastSpeed*bonuspeed
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, 0)
end
						local SW = script.Mesh.VBLASTMESH2:Clone()
					SW.CFrame = rng.CFrame
					SW.Orientation = Vector3.new(0,0,0)
					SW.Parent = effectz
					TweenFunction(SW, 3, 2, 3, 1, 0.6)
					game:GetService("Debris"):AddItem(SW, 4)
rng:Destroy()
end)	
end
function Beamring(col,pos,bonsize,esize,fasten,textr)
	local sa = script.Ring:Clone()
	sa.Parent = char
	sa.CFrame = pos
	local bem = sa.Beam
	if textr ~= nil then
	bem.Texture = "rbxassetid://" ..textr
	end
	local at1 = sa.a1
	local at2 = sa.a2
	at1.Position = vt(0,0,0.5*esize)
	at2.Position = vt(0,0,-0.5*esize)
	bem.Width0 = 1*esize
	bem.Width1 = 1*esize
	bem.Color = ColorSequence.new(col)
	coroutine.resume(coroutine.create(function()
		local trans = 0
		for i = 0, 99/fasten do
			swait()
			trans = trans + 0.01*fasten
			bem.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,trans,0),NumberSequenceKeypoint.new(1,trans,0)})
			at1.Position = at1.Position + vt(0,0,0.5*bonsize*fasten)
			at2.Position = at2.Position - vt(0,0,0.5*bonsize*fasten)
			bem.Width0 = bem.Width0 + 1*bonsize*fasten
			bem.Width1 = bem.Width1 + 1*bonsize*fasten
		end
		sa:Destroy()
	end))
end

function trailMK(bonuspeed,FastSpeed,type,pos,x,value,color,outerpos)
local type = type
local rng = Instance.new("Part", effectz)
        rng.Anchored = true
rng.Color = color
        rng.CanCollide = false
        rng.CastShadow = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
local trl = Instance.new("Trail",rng)
	local a0 = Instance.new("Attachment",rng)
	a0.Position = Vector3.new(x/2,0,0)
	local a1 = Instance.new("Attachment",rng)
	a1.Position = Vector3.new(-x/2,0,0)
	trl.Attachment0 = a0
	trl.Attachment1 = a1
	trl.Color = ColorSequence.new(color)
	trl.Lifetime = 0.25
	trl.LightEmission = 1
	trl.WidthScale = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(1,0,0)})
	trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,1,0)})
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Sphere"
rngm.Scale = vt(0,0,0)
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
local scaler2 = 1
local speeder = FastSpeed
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
spawn(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
end
if chaosmode == true then
rng.Color = BrickColor.random()
end
speeder = speeder - 0.01*FastSpeed*bonuspeed
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
rng.Transparency = rng.Transparency + 0.01*bonuspeed
trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.5,rng.Transparency,0),NumberSequenceKeypoint.new(1,1,0)})
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, 0)
end
rng:Destroy()
end)
end


function sphereMKn(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos,lt)
local type = type
local rng = Instance.new("Part", effectz)
        rng.Anchored = true
rng.Color = color
        rng.CanCollide = false
        rng.CastShadow = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Sphere"
rngm.Scale = vt(x1,y1,z1)
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
local scaler2 = 1
local speeder = FastSpeed
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
spawn(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
end
if chaosmode == true then
rng.Color = BrickColor.random()
end
speeder = speeder - 0.01*FastSpeed*bonuspeed
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, 0)
end
rng:Destroy()
end)
end


function blockoutline(bonuspeed,type,pos,scale,value,value2,value3,color,outcol)
local type = type
local rng = Instance.new("Part", effectz)
        rng.Anchored = true
if ModeOfGlitch ~= 9 then
        rng.Color = color
elseif ModeOfGlitch == 9 then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
end
        rng.CanCollide = false
        rng.CastShadow = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
local outline = Instance.new("SelectionBox",rng)
outline.Adornee = rng
outline.LineThickness = 0.05
outline.Color3 = outcol.Color
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
local scaler2 = 1
local scaler2b = 1
local scaler2c = 1
if type == "Add" then
scaler2 = 1*value
scaler2b = 1*value2
scaler2c = 1*value3
elseif type == "Divide" then
scaler2 = 1/value
scaler2b = 1/value2
scaler2c = 1/value3
end
if ModeOfGlitch == 9 then
spawn(function()
while true do
swait()
if rng.Parent ~= nil then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
else
break
end
end
end)
end
spawn(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
scaler2b = scaler2b - 0.01*value/bonuspeed
scaler2c = scaler2c - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
scaler2b = scaler2b - 0.01/value*bonuspeed
scaler2c = scaler2c - 0.01/value*bonuspeed
end
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rng.Size = rng.Size + Vector3.new(scaler2*bonuspeed, scaler2b*bonuspeed, scaler2c*bonuspeed)
end
rng:Destroy()
end)
end


function blockmk(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
local type = type
local rng = Instance.new("Part", effectz)
        rng.Anchored = true
if ModeOfGlitch ~= 9 then
        rng.Color = color
elseif ModeOfGlitch == 9 then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
end
        rng.CanCollide = false
        rng.CastShadow = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Brick"
rngm.Scale = vt(x1,y1,z1)
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
if ModeOfGlitch == 9 then
spawn(function()
while true do
swait()
if rng.Parent ~= nil then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
else
break
end
end
end)
end
local scaler2 = 1
local speeder = FastSpeed
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
spawn(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
end
if chaosmode == true then
rng.Color = BrickColor.random()
end
speeder = speeder - 0.01*FastSpeed*bonuspeed
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, 0)
end
rng:Destroy()
end)
end

function sphereMKCharge(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
local type = type
local rng = Instance.new("Part", effectz)
        rng.Anchored = true
if ModeOfGlitch ~= 9 then
        rng.Color = color
elseif ModeOfGlitch == 9 then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
end
        rng.CanCollide = false
        rng.CastShadow = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 1
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Sphere"
rngm.Scale = vt(x1,y1,z1)
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
if ModeOfGlitch == 9 then
spawn(function()
while true do
swait()
if rng.Parent ~= nil then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
else
break
end
end
end)
end
local scaler2 = 1
local speeder = FastSpeed
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
spawn(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
end
if chaosmode == true then
rng.Color = BrickColor.random()
end
speeder = speeder - 0.01*FastSpeed*bonuspeed
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
rng.Transparency = rng.Transparency - 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, 0)
end
rng:Destroy()
end)
end

local targetted
function dmg(dude)
if dude.Name ~= Character then
local bgf = Instance.new("BodyGyro",dude.Head)
bgf.CFrame = bgf.CFrame * CFrame.fromEulerAnglesXYZ(math.rad(-90),0,0)
local val = Instance.new("BoolValue",dude)
val.Name = "IsHit"
local ds = coroutine.wrap(function()
dude:WaitForChild("Head"):BreakJoints()
wait(0.5)
targetted = nil
CFuncs["Sound"].Create("rbxassetid://62339698", char, 0.5, 0.3)
coroutine.resume(coroutine.create(function()
for i, v in pairs(dude:GetChildren()) do
if v:IsA("Accessory") then
v:Destroy()
end
if v:IsA("Humanoid") then
v:Destroy()
end
if v:IsA("CharacterMesh") then
v:Destroy()
end
if v:IsA("Model") then
v:Destroy()
end
if v:IsA("Part") or v:IsA("MeshPart") then
for x, o in pairs(v:GetChildren()) do
if o:IsA("Decal") then
o:Destroy()
end
end
coroutine.resume(coroutine.create(function()
v.Material = "Neon"
v.CanCollide = false
local bld = Instance.new("ParticleEmitter",v)
bld.LightEmission = 1
bld.Texture = "rbxassetid://241685484"
bld.Color = ColorSequence.new(MAINRUINCOLOR)
bld.Rate = 1000
bld.Lifetime = NumberRange.new(1)
bld.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0.1,0),NumberSequenceKeypoint.new(1,0,0)})
bld.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,1,0)})
bld.Speed = NumberRange.new(0,0)
bld.VelocitySpread = 50000
bld.Rotation = NumberRange.new(-500,500)
bld.RotSpeed = NumberRange.new(-500,500)
        local sbs = Instance.new("BodyPosition", v)
        sbs.P = 3000
        sbs.D = 1000
        sbs.maxForce = Vector3.new(50000000000, 50000000000, 50000000000)
        sbs.position = v.Position + Vector3.new(math.random(-5,5),math.random(-5,5),math.random(-5,5))
v.Color = Color3.new(1,1,1)
coroutine.resume(coroutine.create(function()
for i = 0, 49 do
swait(1)
v.Transparency = v.Transparency + 0.02
end
CFuncs["Sound"].Create("rbxassetid://1192402877", v, 0.25, 1)
bld.Speed = NumberRange.new(1,5)
bld.Acceleration = vt(0,10,0)
wait(0.5)
bld.Enabled = false
wait(3)
v:Destroy()
dude:Destroy()
end))
end))
end
end
end))
end)
ds()
end
end

function dmgnr(dude)
local bgf = Instance.new("BodyGyro",dude.Head)
bgf.CFrame = bgf.CFrame * CFrame.fromEulerAnglesXYZ(math.rad(-90),0,0)
local val = Instance.new("BoolValue",dude)
val.Name = "IsHit"
local ds = coroutine.wrap(function()
dude:WaitForChild("Head"):BreakJoints()
wait(0.5)
targetted = nil
coroutine.resume(coroutine.create(function()
for i, v in pairs(dude:GetChildren()) do
if v:IsA("Accessory") then
v:Destroy()
end
if v:IsA("Humanoid") then
v:Destroy()
end
if v:IsA("CharacterMesh") then
v:Destroy()
end
if v:IsA("Model") then
v:Destroy()
end
if v:IsA("Part") or v:IsA("MeshPart") then
for x, o in pairs(v:GetChildren()) do
if o:IsA("Decal") then
o:Destroy()
end
end
coroutine.resume(coroutine.create(function()
v.Material = "Neon"
v.CanCollide = false
local bld = Instance.new("ParticleEmitter",v)
bld.LightEmission = 1
bld.Texture = "rbxassetid://241685484"
bld.Color = ColorSequence.new(MAINRUINCOLOR)
bld.Rate = 50
bld.Lifetime = NumberRange.new(1)
bld.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0.75,0),NumberSequenceKeypoint.new(1,0,0)})
bld.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,1,0)})
bld.Speed = NumberRange.new(0,0)
bld.VelocitySpread = 50000
bld.Rotation = NumberRange.new(-500,500)
bld.RotSpeed = NumberRange.new(-500,500)
        local sbs = Instance.new("BodyPosition", v)
        sbs.P = 3000
        sbs.D = 1000
        sbs.maxForce = Vector3.new(50000000000, 50000000000, 50000000000)
        sbs.position = v.Position + Vector3.new(math.random(-5,5),math.random(-5,5),math.random(-5,5))
v.Color = MAINRUINCOLOR
coroutine.resume(coroutine.create(function()
for i = 0, 49 do
swait(1)
v.Transparency = v.Transparency + 0.02
end
CFuncs["Sound"].Create("rbxassetid://1192402877", v, 0.25, 1)
bld.Speed = NumberRange.new(1,5)
bld.Acceleration = vt(0,10,0)
wait(0.5)
bld.Enabled = false
wait(3)
v:Destroy()
dude:Destroy()
end))
end))
end
end
end))
end)
ds()
end


function FindNearestHead(Position, Distance, SinglePlayer)
	if SinglePlayer then
		return (SinglePlayer.Torso.CFrame.p - Position).magnitude < Distance
	end
	local List = {}
	for i, v in pairs(workspace:GetChildren()) do
		if v:IsA("Model") then
			if v:findFirstChild("Head") then
				if v ~= Character then
					if (v.Head.Position - Position).magnitude <= Distance then
						table.insert(List, v)
					end 
				end 
			end 
		end 
	end
	return List
end

function FaceMouse()
  Cam = workspace.CurrentCamera
  return {
    CFrame.new(char.Torso.Position, Vector3.new(mouse.Hit.p.x, char.Torso.Position.y, mouse.Hit.p.z)),
    Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)
  }
end

function FaceMouse2()
  Cam = workspace.CurrentCamera
  return {
    CFrame.new(char.Torso.Position, Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)),
    Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)
  }
end

-- Functions are ready.
local storehumanoidWS = 70
function symbolizeBlink(guipar,size,img,color,bonussize,vol,pit,soundid,spar,rotationenabled,rotsp,delay)
local bgui,imgc = createBGCircle(size,guipar,color)
bgui.AlwaysOnTop = true
imgc.Image = "rbxassetid://" ..img
local rrot = math.random(1,2)
CFuncs["Sound"].Create("rbxassetid://" ..soundid, spar, vol,pit)
coroutine.resume(coroutine.create(function()
for i = 0, 24*delay do
swait()
if rotationenabled == true then
if rrot == 1 then
imgc.Rotation = imgc.Rotation + rotsp
elseif rrot == 2 then
imgc.Rotation = imgc.Rotation - rotsp
end
end
bgui.Size = bgui.Size + UDim2.new(1*bonussize/delay,0,1*bonussize/delay,0)
imgc.ImageTransparency = imgc.ImageTransparency + 0.04/delay
end
bgui:Destroy()
end))
end
function brst()
for i = 0, 1 do
CFuncs["Sound"].Create("rbxassetid://1042716828", root, 5, 1)
CFuncs["Sound"].Create("rbxassetid://1042693018", root, 5, 0.8)
CFuncs["Sound"].Create("rbxassetid://1192402877", root, 4,0.75)
CFuncs["Sound"].Create("rbxassetid://1664711478", root, 4,1)
CFuncs["Sound"].Create("rbxassetid://763718160", root, 4, 0.75)
CFuncs["Sound"].Create("rbxassetid://782353443", root, 8, 0.9)
CFuncs["Sound"].Create("rbxassetid://782353443", root, 6, 0.8)
CFuncs["Sound"].Create("rbxassetid://782353443", root, 4, 0.7)
end
--[[symbolizeBlink(Torso,0,2109052855,MAINRUINCOLOR,30,0,0,0,root,false,0,1)
symbolizeBlink(Torso,0,2109052855,MAINRUINCOLOR,30,0,0,0,root,false,0,2)
symbolizeBlink(Torso,0,2109052855,MAINRUINCOLOR,30,0,0,0,root,false,0,4)
coroutine.resume(coroutine.create(function()
local eff = Instance.new("ParticleEmitter",Torso)
eff.Texture = "rbxassetid://2273224484"
eff.LightEmission = 1
eff.Color = ColorSequence.new(MAINRUINCOLOR)
eff.Rate = 15000
eff.Lifetime = NumberRange.new(0.5,1)
eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,60,0),NumberSequenceKeypoint.new(0.2,3,0),NumberSequenceKeypoint.new(0.8,24,0),NumberSequenceKeypoint.new(1,0,0)})
eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.2,0,0),NumberSequenceKeypoint.new(0.5,0,0),NumberSequenceKeypoint.new(1,1,0)})
eff.Speed = NumberRange.new(100,650)
eff.Drag = 5
eff.Rotation = NumberRange.new(-500,500)
eff.VelocitySpread = 9000
eff.RotSpeed = NumberRange.new(-50,50)
wait(0.35)
eff.Enabled = false
end))]]--
		WACKYEFFECT({
				Time = 30,
				EffectType = "Sphere",
				Size = VT(0.01,0.01,0.01),
				Size2 = VT(50, 50, 50),
				Transparency = 0,
				Transparency2 = 1,
				CFrame = root.CFrame,
				MoveToPos = nil,
				RotationX = 0,
				RotationY = 0,
				RotationZ = 0,
				Material = "ForceField",
				Color = MAINRUINCOLOR,
				SoundID = nil,
				SoundPitch = MRANDOM(9, 12) / 10,
				SoundVolume = 10,
				UseBoomerangMath = true,
				Boomerang = 0,
				SizeBoomerang = 50
		})
		WACKYEFFECT({
				Time = 30,
				EffectType = "Sphere",
				Size = VT(0.01,0.01,0.01),
				Size2 = VT(100, 100, 100),
				Transparency = 0,
				Transparency2 = 1,
				CFrame = root.CFrame,
				MoveToPos = nil,
				RotationX = 0,
				RotationY = 0,
				RotationZ = 0,
				Material = "ForceField",
				Color = MAINRUINCOLOR,
				SoundID = nil,
				SoundPitch = MRANDOM(9, 12) / 10,
				SoundVolume = 10,
				UseBoomerangMath = true,
				Boomerang = 0,
				SizeBoomerang = 50
		})
		for i = 0,15 do
		WACKYEFFECT({Time = 30,EffectType = "Round Slash", Size = VT(0,0,0), Size2 = VT(math.random(5,6)/10,0,math.random(5,7)/10), Transparency = 0.3, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-3,0)*ANGLES(RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360))), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = MAINRUINCOLOR2, SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 50})
		end
		swait(20)
		WACKYEFFECT({
				Time = 100,
				EffectType = "Sphere",
				Size = VT(0,0,0),
				Size2 = VT(30, 30, 30),
				Transparency = 0.4,
				Transparency2 = 0.4,
				CFrame = root.CFrame,
				MoveToPos = nil,
				RotationX = 0,
				RotationY = 0,
				RotationZ = 0,
				Material = "Neon",
				Color = MAINRUINCOLOR,
				SoundID = 2374026404,
				SoundPitch = 1,
				SoundVolume = 10,
				UseBoomerangMath = false,
				Boomerang = 0,
				SizeBoomerang = 0
		})
		WACKYEFFECT({
				Time = 100,
				EffectType = "Sphere",
				Size = VT(1,1,1),
				Size2 = VT(31, 31, 31),
				Transparency = 0,
				Transparency2 = 0,
				CFrame = root.CFrame,
				MoveToPos = nil,
				RotationX = 0,
				RotationY = 0,
				RotationZ = 0,
				Material = "ForceField",
				Color = MAINRUINCOLOR2,
				SoundID = nil,
				SoundPitch = MRANDOM(9, 12) / 10,
				SoundVolume = 10,
				UseBoomerangMath = false,
				Boomerang = 0,
				SizeBoomerang = 0
		})
		for i = 0,100 do
		swait()
		RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,-0.1,-0.1)* angles(math.rad(20),math.rad(0),math.rad(0)),0.3)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(35),math.rad(0),math.rad(0)),.3)
RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, -0.5) * angles(math.rad(0), math.rad(0), math.rad(-70)), 0.3)
LW.C0 = clerp(LW.C0, CFrame.new(-1.1, 0.5, -0.5) * angles(math.rad(0), math.rad(0), math.rad(70)), 0.3)
RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-1.5),math.rad(0),math.rad(20)),.3)
LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-20)),.3)
		sphereMK(5,-4.5,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),3.5,3.5,45,-0.035,MAINRUINCOLOR2,225)
		sphereMK(5,-4.5,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),3.5,3.5,45,-0.035,MAINRUINCOLOR,225)
		TEffect2(
			MAINRUINCOLOR2,
			root.CFrame*CFrame.new(0,0,0)*CFrame.Angles(-math.rad(sine*6),math.rad(sine*3),-math.rad(sine*4)), -- CFrame Start
			root.CFrame*CFrame.new(math.random(-60,60),math.random(-60,60),math.random(-60,60))*CFrame.Angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)), -- CFrame End
			0.1, -- Start Size X
			15, -- Start Size Y
			15, -- Start Size Z
			0.1, -- End Size X
			15, -- End Size Y
			15, -- End Size Z
			0, -- Start Transparency
			1, -- End Transparency
			40, -- Rad Spin Thing
			false, -- FFF
			"Wedge", -- Mesh
			"", -- Feather Spin Thing
			true, -- Transparency Type
			math.random(10,20)/10, -- Tween Time
			"Quad", -- EasingStyle
			"Out", -- EasingDirection
			math.random(10,20)/10 -- TweenTime v2
		)
		TEffect2(
			MAINRUINCOLOR,
			root.CFrame*CFrame.new(0,0,0)*CFrame.Angles(-math.rad(sine*6),math.rad(sine*3),-math.rad(sine*4)), -- CFrame Start
			root.CFrame*CFrame.new(math.random(-60,60),math.random(-60,60),math.random(-60,60))*CFrame.Angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)), -- CFrame End
			0.1, -- Start Size X
			15, -- Start Size Y
			15, -- Start Size Z
			0.1, -- End Size X
			15, -- End Size Y
			15, -- End Size Z
			0, -- Start Transparency
			1, -- End Transparency
			40, -- Rad Spin Thing
			false, -- FFF
			"Wedge", -- Mesh
			"", -- Feather Spin Thing
			true, -- Transparency Type
			math.random(10,20)/10, -- Tween Time
			"Quad", -- EasingStyle
			"Out", -- EasingDirection
			math.random(10,20)/10 -- TweenTime v2
		)
		end
		sphere2(3,"Add",tors.CFrame,vt(1,1,1),0.25,0.25,0.25,MAINRUINCOLOR)
sphere2(4,"Add",tors.CFrame,vt(1,1,1),0.5,0.5,0.5,MAINRUINCOLOR2)
sphere2(5,"Add",tors.CFrame,vt(1,1,1),0.75,0.75,0.75,MAINRUINCOLOR)
for i = 0, 24 do
slash(math.random(15,30)/15,3,true,"Round","Add","Out",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(150,350.5)/250,MAINRUINCOLOR)
		TEffect2(
			MAINRUINCOLOR,
			root.CFrame*CFrame.new(0,0,0)*CFrame.Angles(-math.rad(sine*6),math.rad(sine*3),-math.rad(sine*4)), -- CFrame Start
			root.CFrame*CFrame.new(math.random(-60,60),math.random(-60,60),math.random(-60,60))*CFrame.Angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)), -- CFrame End
			0.1, -- Start Size X
			200, -- Start Size Y
			200, -- Start Size Z
			0.1, -- End Size X
			15, -- End Size Y
			15, -- End Size Z
			0, -- Start Transparency
			1, -- End Transparency
			40, -- Rad Spin Thing
			false, -- FFF
			"Wedge", -- Mesh
			"", -- Feather Spin Thing
			true, -- Transparency Type
			math.random(30,40)/10, -- Tween Time
			"Quad", -- EasingStyle
			"Out", -- EasingDirection
			math.random(30,40)/10 -- TweenTime v2
		)
end
CFuncs["Sound"].Create("rbxassetid://206082327", root, 10,1)
CFuncs["Sound"].Create("rbxassetid://1368637781", root, 10,1)
CFuncs["Sound"].Create("rbxassetid://763718160", root, 10, 1.1)
CFuncs["Sound"].Create("rbxassetid://1310128035", root, 10, 0.9)
for i = 0, 9 do
	Beamring(MAINRUINCOLOR2,root.CFrame*CFrame.new(0,0,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),math.random(10,100)/10,0,math.random(1,5),348103573)
end
end

local musicss = Gui.Musiccs
local oldmusicc = musicss:Clone()
oldmusicc.Name = "Musiccc"
oldmusicc.Parent = Gui
oldmusicc.Position = UDim2.new(0.35,0,0.019,0)

function musicc()
spawn(function()
musicactive = true
local oldmusicc = Gui:WaitForChild("Musiccc")
local newmusicc = musicss:Clone()
newmusicc.Name = "Musiccc"
newmusicc.Parent = Gui
local mps=game:GetService("MarketplaceService"):GetProductInfo(cp, Enum.InfoType.Asset)
newmusicc.Text = (mps.Name)
newmusicc:TweenPosition(UDim2.new(0.35,0,0.019,0),Enum.EasingDirection.Out,Enum.EasingStyle.Back,3,true) --{0.328, 0},{0.019, 0}
oldmusicc:TweenPosition(UDim2.new(1.444,0,0.019,0),Enum.EasingDirection.Out,Enum.EasingStyle.Quad,3,true) --{0.328, 0},{0.019, 0}
spawn(function()
for i,v in pairs(oldmusicc:GetChildren())do
for i = 0,10 do
swait()
if v:IsA'Frame' then
v.BackgroundTransparency = v.BackgroundTransparency + 0.1
end
oldmusicc.TextTransparency = oldmusicc.TextTransparency + 0.1
end
end
end)
spawn(function()
wait(1)
oldmusicc:Destroy()
end)
wait(3)
musicactive = false
end)
end
local realth = script.AttachmentH.Realt
realth.Parent = tors
function RecolorThing(one,two,three,four,five,exonetran,exone,extwotran,extwo,secondaryenabled,sectrailenabled)
	attack = true
	hum.WalkSpeed = 0
	realth["1"].Color = ColorSequence.new(one)
	realth["2"].Color = ColorSequence.new(two)
for i, v in pairs(mw2:GetDescendants()) do
if v:IsA("BasePart") or v:IsA("UnionOperation") or v:IsA("Part") then
v.Color = one
v.Material = "Neon"
if v.Name == "Color2" then
v.Color = two
end
if v.Name == "Force Field" then
v.Material = "ForceField"
v.Mesh.VertexColor = Vector3.new(two.r,two.g,two.b)
end
elseif v:IsA("Trail") or v:IsA("ParticleEmitter") or v:IsA("Beam") then
if v.Name == "Trail1" then
v.Color = ColorSequence.new(one)
elseif v.Name == "Trail2" then
	v.Color = ColorSequence.new(two)
else
v.Color = ColorSequence.new(one)
end
elseif v:IsA("Decal") then
v.Color3 = one
end
end
ringgu.Ring1.Color = one
ringgu.Ring2.Color = two
ringgu.Ring3.Color = one
ringgu.Ring4.Color = two
for i, v in pairs(mw1:GetDescendants()) do
if v:IsA("BasePart") or v:IsA("UnionOperation") then
v.Color = one
v.Material = "Neon"
if v.Name == "Color2" then
v.Color = two
end
elseif v:IsA("Trail") or v:IsA("ParticleEmitter") or v:IsA("Beam") then
if v.Name == "Trail1" then
v.Color = ColorSequence.new(one)
elseif v.Name == "Trail2" then
	v.Color = ColorSequence.new(two)
else
v.Color = ColorSequence.new(one)
end
end
end
for i,v in pairs(gauntneon)do
v.Color = one
v.Material = "Neon"
end
		for i,v in pairs(Gui:GetDescendants())do
if v:IsA("Frame") then
v.BackgroundColor3 = MAINRUINCOLOR
end
if v:IsA("ImageLabel") then
	v.ImageColor3 = MAINRUINCOLOR
	end
if v.Name == "Ring" or v.Name == "Ring2" then
v.ImageColor3 = MAINRUINCOLOR2
end
if v:IsA("TextLabel") then
v.TextColor3 = MAINRUINCOLOR2
v.BackgroundColor3 = MAINRUINCOLOR
end
end
brst()
CamShakeAll2({
    Duration=0.6; -- Lasts for .1 seconds
    Intensity=3; -- Intensity of 5
    Position=Vector3.new(2,2,2); -- What axises the shake effects and how much (position)
    Rotation=Vector3.new(2,2,6); -- What axises the shake effects and how much (rotation)
    DropDist=100; -- Camera dist from origin when the shake starts to gradually get weaker
    IneffectiveDist=130; -- Camera dist from origin when the shake goes away
    Origin=tors.Position; -- Where the shake is coming from (Part, CFrame, or Vector3)
})
	attack = false
	hum.WalkSpeed = storehumanoidWS
end

function RecolorThingQuiet(one,two,three,four,five,exonetran,exone,extwotran,extwo,secondaryenabled,sectrailenabled)
		realth["1"].Color = ColorSequence.new(one)
	realth["2"].Color = ColorSequence.new(two)
for i, v in pairs(mw2:GetDescendants()) do
if v:IsA("BasePart") or v:IsA("UnionOperation") then
v.Color = one
v.Material = "Neon"
if v.Name == "Color2" then
v.Color = two
end
if v.Name == "Force Field" then
v.Material = "ForceField"
v.Mesh.VertexColor = Vector3.new(two.r,two.g,two.b)
end
elseif v:IsA("Trail") or v:IsA("ParticleEmitter") or v:IsA("Beam") then
if v.Name == "Trail1" then
v.Color = ColorSequence.new(one)
elseif v.Name == "Trail2" then
	v.Color = ColorSequence.new(two)
else
v.Color = ColorSequence.new(one)
end
elseif v:IsA("Decal") then
v.Color3 = one
end
end
		for i,v in pairs(Gui:GetDescendants())do
if v:IsA("Frame") then
v.BackgroundColor3 = MAINRUINCOLOR
end
if v:IsA("ImageLabel") then
	v.ImageColor3 = MAINRUINCOLOR
	end
if v.Name == "Ring" or v.Name == "Ring2" then
v.ImageColor3 = MAINRUINCOLOR2
end
if v:IsA("TextLabel") then
v.TextColor3 = MAINRUINCOLOR2
v.BackgroundColor3 = MAINRUINCOLOR
end
end
ringgu.Ring1.Color = one
ringgu.Ring2.Color = two
ringgu.Ring3.Color = one
ringgu.Ring4.Color = two
for i, v in pairs(mw1:GetDescendants()) do
if v:IsA("BasePart") or v:IsA("UnionOperation") then
v.Color = one
v.Material = "Neon"
if v.Name == "Color2" then
v.Color = two
end
elseif v:IsA("Trail") or v:IsA("ParticleEmitter") or v:IsA("Beam") then
if v.Name == "Trail1" then
v.Color = ColorSequence.new(one)
elseif v.Name == "Trail2" then
	v.Color = ColorSequence.new(two)
else
v.Color = ColorSequence.new(one)
end
end
end
for i,v in pairs(gauntneon)do
v.Color = one
v.Material = "Neon"
end
end
RecolorThingQuiet(MAINRUINCOLOR,MAINRUINCOLOR2,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,false,false)

function RecolorTextAndRename(name,col1,col2,font)
modet.TextStrokeColor3 = col2
modet.TextColor3 = col1
modet.Font = font
modet.Text = name
bilguit.FX1.ImageColor3 = MAINRUINCOLOR2
bilguit.FX2.ImageColor3 = MAINRUINCOLOR
bilguit.FX3.ImageColor3 = MAINRUINCOLOR2
end

function createBGCircle(size,parent,color)
local bgui = Instance.new("BillboardGui",parent)
bgui.Size = UDim2.new(size, 0, size, 0)
local imgc = Instance.new("ImageLabel",bgui)
imgc.BackgroundTransparency = 1
imgc.ImageTransparency = 0
imgc.Size = UDim2.new(1,0,1,0)
imgc.Image = "rbxassetid://997291547" --997291547,521073910
imgc.ImageColor3 = color
return bgui,imgc
end

local bguis = Instance.new("BillboardGui",tors)
bguis.Size = UDim2.new(15, 0, 15, 0)
local imgca = Instance.new("ImageLabel",bguis)
imgca.BackgroundTransparency = 1
imgca.ImageTransparency = 1
imgca.Size = UDim2.new(1,0,1,0)
imgca.Image = "rbxassetid://2312119891" --997291547,521073910,2312119891
imgca.ImageColor3 = BrickColor.new("Pink").Color

local warngui = script.bwarn
warngui.Parent = hed
warngui.Enabled = true
local markimg = warngui.warnimage
markimg.ImageTransparency = 1
function WARNINGMARK(frequen,sound)
spawn(function()
if sound==true then
CFuncs["Sound"].Create("rbxassetid://2923164079", char, 1, 1.1)
else
end
if frequen then
for i = 0, frequen do
repeat
markimg.ImageTransparency = markimg.ImageTransparency - 0.05
swait()
until markimg.ImageTransparency < 0.5
repeat
markimg.ImageTransparency = markimg.ImageTransparency + 0.05
swait()
until markimg.ImageTransparency == 1
end
else
for i = 0, 1 do
repeat
markimg.ImageTransparency = markimg.ImageTransparency - 0.05
swait()
until markimg.ImageTransparency < 0.5
repeat
markimg.ImageTransparency = markimg.ImageTransparency + 0.05
swait()
until markimg.ImageTransparency == 1
end
end
end)
end
-- WARNINGMARK(3,true)


----------------------------------- Abilities
local charge = false
function opening() -- 5.5902949405938313632
attack = true
openingo = true
WARNINGMARK(3,true)
	TEffect2(
			MAINRUINCOLOR, -- BrickColor
			root.CFrame, -- CFrame Start
			root.CFrame, -- CFrame End
			100, -- Start Size X
			600000, -- Start Size Y
			100, -- Start Size Z
			0, -- End Size X
			600000, -- End Size Y
			0, -- End Size Z
			0.5, -- Start Transparency
			1, -- End Transparency
			0, -- Rad Spin Thing
			false, -- FFF
			"Sphere", -- Mesh
			"", -- Feather Spin Thing
			true, -- Transparency Type
			.5, -- Tween Time
			"Quad", -- EasingStyle
			"Out", -- EasingDirection
			.5 -- TweenTime v2
	)
	TEffect2(
			MAINRUINCOLOR, -- BrickColor
			root.CFrame, -- CFrame Start
			root.CFrame, -- CFrame End
			50, -- Start Size X
			600000, -- Start Size Y
			50, -- Start Size Z
			0, -- End Size X
			600000, -- End Size Y
			0, -- End Size Z
			0.5, -- Start Transparency
			1, -- End Transparency
			0, -- Rad Spin Thing
			false, -- FFF
			"Sphere", -- Mesh
			"", -- Feather Spin Thing
			true, -- Transparency Type
			.5, -- Tween Time
			"Quad", -- EasingStyle
			"Out", -- EasingDirection
			.5 -- TweenTime v2
	)
hum.WalkSpeed = 0
kan.TimePosition = 0
  	local Alpha = .1
  	TweenAnimate(RootJoint,{C0=cf(0,784.5,0)*angles(math.rad(38.6),math.rad(0),math.rad(0))*RootCF},Alpha,'Linear','Out',0,false,0)
  	TweenAnimate(LH,{C0=cf(-1,-1,0)*angles(math.rad(-45.9),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0))},Alpha,'Linear','Out',0,false,0)
  	TweenAnimate(RH,{C0=cf(1,-0.7,-0.9)*angles(math.rad(-69.6),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(90),math.rad(0))},Alpha,'Linear','Out',0,false,0)
  	TweenAnimate(LW,{C0=cf(-1.4,0.7,-0.2)*angles(math.rad(135.7),math.rad(0),math.rad(43.3))},Alpha,'Linear','Out',0,false,0)
  	TweenAnimate(RW,{C0=cf(1.4,0.7,-0.2)*angles(math.rad(134.2),math.rad(0),math.rad(-41.5))},Alpha,'Linear','Out',0,false,0)
  	TweenAnimate(Torso.Neck,{C0 =cf(0,0.1,-0.4)*angles(math.rad(24),math.rad(0),math.rad(0))*necko},Alpha,'Linear','Out',0,false,0)
wait(5.590)
warnedpeople("I am here..","Antique",MAINRUINCOLOR,MAINRUINCOLOR2)
		sphere2(3,"Add",tors.CFrame,vt(1,1,1),0.25,0.25,0.25,MAINRUINCOLOR)
sphere2(4,"Add",tors.CFrame,vt(1,1,1),0.5,0.5,0.5,MAINRUINCOLOR2)
sphere2(5,"Add",tors.CFrame,vt(1,1,1),0.75,0.75,0.75,MAINRUINCOLOR)
for i = 0, 24 do
slash(math.random(15,30)/15,3,true,"Round","Add","Out",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(150,350.5)/250,MAINRUINCOLOR)
end
CFuncs["Sound"].Create("rbxassetid://206082327", root, 5,1)
CFuncs["Sound"].Create("rbxassetid://1368637781", root, 7,1)
CFuncs["Sound"].Create("rbxassetid://763718160", root, 4, 1.1)
CFuncs["Sound"].Create("rbxassetid://1310128035", root, 9, 0.9)
for i = 0, 9 do
	Beamring(MAINRUINCOLOR2,root.CFrame*CFrame.new(0,0,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),math.random(10,100)/10,0,math.random(1,5),348103573)
end
CamShakeAll2({
    Duration=0.6; -- Lasts for .1 seconds
    Intensity=5; -- Intensity of 5
    Position=Vector3.new(2,2,2); -- What axises the shake effects and how much (position)
    Rotation=Vector3.new(2,2,6); -- What axises the shake effects and how much (rotation)
    DropDist=10000; -- Camera dist from origin when the shake starts to gradually get weaker
    IneffectiveDist=10000; -- Camera dist from origin when the shake goes away
    Origin=tors.Position; -- Where the shake is coming from (Part, CFrame, or Vector3)
})
    for i = 0,20,0.1 do
        swait()
  	local Alpha = .3
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0,-1.5,-0.6)*angles(math.rad(-67),math.rad(0),math.rad(0))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-1,-0.6,-0.9)*angles(math.rad(-22.3),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(1,-0.7,-0.9)*angles(math.rad(-22.8),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1.2,0.4,-0.7)*angles(math.rad(81.7),math.rad(0),math.rad(27)),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.2,0.4,-0.7)*angles(math.rad(77.8),math.rad(0),math.rad(-29.5)),Alpha)
  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0))*necko,Alpha)
end
hum.WalkSpeed = storehumanoidWS
attack = false
openingo = false
end
spawn(function()
opening()
end)

function Heal()
	attack = true
	hum.WalkSpeed = 0
	ScreenBars(2.5)
	    for i = 0,2,0.1 do
        swait()
            RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,-0.15,0)* angles(math.rad(10),math.rad(0),math.rad(0)),0.3)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(10),math.rad(0),math.rad(0)),.3)
RW.C0 = clerp(RW.C0, CFrame.new(1.25, 0.5, -0.5) * angles(math.rad(40), math.rad(0), math.rad(-90)), 0.3)
LW.C0 = clerp(LW.C0, CFrame.new(-1.25, 0.5, -0.5) * angles(math.rad(40), math.rad(0), math.rad(70)), 0.3)
RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-1.5),math.rad(0),math.rad(10)),.3)
LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-10)),.3)
	    end
	CFuncs["Sound"].Create("rbxassetid://356427062", root, 4,1.2)
for i,v in pairs(HealEff:GetChildren())do
v:Emit(20)
end
hum.Health = hum.Health + hum.MaxHealth/3
    for i = 0,2,0.1 do
        swait()
            RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0.15,0)* angles(math.rad(-10),math.rad(0),math.rad(0)),0.3)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(-10),math.rad(0),math.rad(0)),.3)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(120)), 0.3)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(-120)), 0.3)
RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-1.5),math.rad(0),math.rad(-10)),.3)
LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(10)),.3)
    end
hum.WalkSpeed = storehumanoidWS
attack = false
cooldown = 6
end


function levelup()
for i,v in pairs(stupidgui:GetDescendants())do
v.BackgroundColor3 = MAINRUINCOLOR
v.TextStrokeColor3 = MAINRUINCOLOR2
v.TextColor3 = MAINRUINCOLOR
end
CFuncs["Sound"].Create("rbxassetid://2513971488", root, 10, 1)
stupidgui.stupidthing.stupidthingv2.Text = "Level: ".. level
if BarrierEnabled == true then
stupidgui.stupidthing.stupidthingv3.Text = "BARRIER: ".. hum.Health.. "/".. hum.MaxHealth
elseif BarrierEnabled == false then
stupidgui.stupidthing.stupidthingv3.Text = "HP: ".. hum.Health.. "/".. hum.MaxHealth
end
stupidgui.stupidthing:TweenPosition(UDim2.new(0,0,0.018,0),Enum.EasingDirection.Out,Enum.EasingStyle.Quad,0.4,true) --
if switchb == true then
	MLT.Eth:TweenPosition(UDim2.new(.3,0,.2,0),Enum.EasingDirection.Out,Enum.EasingStyle.Quad,.4,true)
end
wait(4)
stupidgui.stupidthing:TweenPosition(UDim2.new(-0.298,0,0.018,0),Enum.EasingDirection.Out,Enum.EasingStyle.Quad,0.4,true) -- {-0.298, 0},{0.373, 0}
if switchb == true then
	MLT.Eth:TweenPosition(UDim2.new(.011,0,.2,0),Enum.EasingDirection.Out,Enum.EasingStyle.Quad,.4,true)
end
end

function attackone()
attack = true
hum.WalkSpeed = 0
local rootCF=euler(-1.57,0,3.14)
local keptcolor = MAINRUINCOLOR
  	local Alpha,Easing,Direction,Repeat,Reverse,Delay = .2,'Back','Out',0,false,0
  	TweenAnimate(RootJoint,{C0=cf(0,0,0)*angles(math.rad(19.2),math.rad(-34.5),math.rad(11.8))*RootCF},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(LH,{C0=cf(-1,-1,0)*angles(math.rad(-16.8),math.rad(38),math.rad(0.2))*angles(math.rad(0),math.rad(-90),math.rad(0))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(RH,{C0=cf(1,-1,0)*angles(math.rad(9.3),math.rad(-2.5),math.rad(-6.5))*angles(math.rad(0),math.rad(90),math.rad(0))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(LW,{C0=cf(-1.5,0.6,0.1)*angles(math.rad(-26.6),math.rad(17.1),math.rad(-3.9))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(RW,{C0=cf(1.5,0.6,0.4)*angles(math.rad(105.8),math.rad(2.2),math.rad(13.7))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(Torso.Neck,{C0 =necko*angles(math.rad(20.9),math.rad(2.9),math.rad(37.1))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
wait(0.2)
  	local Alpha,Easing,Direction,Repeat,Reverse,Delay = .05,'Linear','Out',0,false,0
  	TweenAnimate(RootJoint,{C0=cf(0,0,0)*angles(math.rad(-21.7),math.rad(-6),math.rad(2.4))*RootCF},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(LH,{C0=cf(-1,-1,0)*angles(math.rad(24.3),math.rad(36.2),math.rad(-3.4))*angles(math.rad(0),math.rad(-90),math.rad(0))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(RH,{C0=cf(1,-1,0)*angles(math.rad(-20.6),math.rad(-1.6),math.rad(-3.2))*angles(math.rad(0),math.rad(90),math.rad(0))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(LW,{C0=cf(-1.5,0.6,-0.1)*angles(math.rad(-40.5),math.rad(2.4),math.rad(-18.2))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(RW,{C0=cf(1.5,0.7,-0.3)*angles(math.rad(109.5),math.rad(4.2),math.rad(-13.9))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(Torso.Neck,{C0 =necko*angles(math.rad(-5.1),math.rad(-7),math.rad(-0.8))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
wait(0.05)
CFuncs["Sound"].Create("rbxassetid://182765513", root, 4, 0.8)
local hitb = Instance.new("Part", char)
        hitb.Anchored = true
        hitb.CanCollide = false
        hitb.FormFactor = 3
        hitb.Name = "Ring"
        hitb.Material = "Neon"
        hitb.Size = Vector3.new(1, 1, 1)
        hitb.Transparency = 1
        hitb.TopSurface = 0
        hitb.BottomSurface = 0
hitb.CFrame = root.CFrame + root.CFrame.lookVector*2
MagniDamage(hitb, 3, 30,60, 0, "Normal")
hitb:Destroy()
  	local Alpha,Easing,Direction,Repeat,Reverse,Delay = .05,'Linear','Out',0,false,0
  	TweenAnimate(RootJoint,{C0=cf(0,0,0)*angles(math.rad(-34.8),math.rad(27.1),math.rad(16.5))*RootCF},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(LH,{C0=cf(-0.9,-0.7,-0.5)*angles(math.rad(26),math.rad(-28.5),math.rad(-9.1))*angles(math.rad(0),math.rad(-90),math.rad(0))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(RH,{C0=cf(1,-1,0)*angles(math.rad(-30.2),math.rad(3.2),math.rad(-6.7))*angles(math.rad(0),math.rad(90),math.rad(0))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(LW,{C0=cf(-1.5,0.7,-0.1)*angles(math.rad(-55.4),math.rad(11.4),math.rad(-20.3))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(RW,{C0=cf(1.4,0.6,-0.4)*angles(math.rad(121.2),math.rad(2),math.rad(30.7))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(Torso.Neck,{C0 =necko*angles(math.rad(-22.2),math.rad(-0.4),math.rad(-28.5))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
wait(.05)
  	local Alpha,Easing,Direction,Repeat,Reverse,Delay = .1,'Circular','Out',0,false,0
  	TweenAnimate(RootJoint,{C0=cf(0,0,0)*angles(math.rad(-48.5),math.rad(27.1),math.rad(16.5))*RootCF},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(LH,{C0=cf(-0.8,-0.4,-0.6)*angles(math.rad(41.3),math.rad(-28.2),math.rad(2.5))*angles(math.rad(0),math.rad(-90),math.rad(0))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(RH,{C0=cf(0.8,-1.4,0.4)*angles(math.rad(-58.3),math.rad(-1.2),math.rad(-33))*angles(math.rad(0),math.rad(90),math.rad(0))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(LW,{C0=cf(-1.8,0.4,0.1)*angles(math.rad(-42.4),math.rad(4),math.rad(-27.3))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(RW,{C0=cf(1.6,1.1,-0.7)*angles(math.rad(133),math.rad(5.9),math.rad(15.9))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(Torso.Neck,{C0 =necko*angles(math.rad(-43.7),math.rad(3.8),math.rad(-27.5))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
wait(.1)
hum.WalkSpeed = storehumanoidWS
attack = false
end

function attacktwo()
attack = true
local rootCF=euler(-1.57,0,3.14)
local keptcolor = MAINRUINCOLOR
local al=.2
local typ="Back"
local direc="Out"
TweenAnimate(RootJoint,{C0=rootCF*cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(100))},al,typ,direc,0,false,0)
TweenAnimate(Torso.Neck,{C0=necko*angles(math.rad(15),math.rad(0),math.rad(-90))},al,typ,direc,0,false,0)
TweenAnimate(RW,{C0=cf(1.2,0.5,-0.25)*angles(math.rad(-10),math.rad(-10),math.rad(-90))},al,typ,direc,0,false,0)
TweenAnimate(LW,{C0=cf(-1.35,0.35,-0.4)*angles(math.rad(90),math.rad(2),math.rad(80))},al,typ,direc,0,false,0)
TweenAnimate(RH,{C0=cf(.75,-1,0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(-100),math.rad(5))},al,typ,direc,0,false,0)
TweenAnimate(LH,{C0=cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-6),math.rad(10),math.rad(0))},al,typ,direc,0,false,0)
wait(.2)
CFuncs["Sound"].Create("rbxassetid://182765513", root, 4, 0.8)
local hitb = Instance.new("Part", char)
        hitb.Anchored = true
        hitb.CanCollide = false
        hitb.FormFactor = 3
        hitb.Name = "Ring"
        hitb.Material = "Neon"
        hitb.Size = Vector3.new(1, 1, 1)
        hitb.Transparency = 1
        hitb.TopSurface = 0
        hitb.BottomSurface = 0
hitb.CFrame = root.CFrame + root.CFrame.lookVector*2
MagniDamage(hitb, 3, 30,60, 0, "Normal")
hitb:Destroy()
spawn(function()
for i = 0,20 do
wait(0.01)
hitb.CFrame = root.CFrame + root.CFrame.lookVector*2
MagniDamage(hitb, 3, 30,60, 0, "Normal")
end
end)
local al=.25
local typ="Back"
local direc="Out"
TweenAnimate(RootJoint,{C0=rootCF*cf(0,0,0)*angles(math.rad(5),math.rad(2),math.rad(100))},al,typ,direc,0,false,0)
TweenAnimate(Torso.Neck,{C0=necko*angles(math.rad(0),math.rad(0),math.rad(-90))},al,typ,direc,0,false,0)
TweenAnimate(RW,{C0=cf(1.8,0.5,-0.25)*angles(math.rad(-10),math.rad(-10),math.rad(-90))},al,typ,direc,0,false,0)
TweenAnimate(LW,{C0=cf(-.7,0.35,-0.4)*angles(math.rad(90),math.rad(2),math.rad(80))},al,typ,direc,0,false,0)
TweenAnimate(RH,{C0=cf(1.2,-.5,0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(20),math.rad(-100),math.rad(10))},al,typ,direc,0,false,0)
TweenAnimate(LH,{C0=cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-10),math.rad(10),math.rad(-10))},al,typ,direc,0,false,0)
root.Anchored=true
TweenAnimate(root,{CFrame=root.CFrame*CFrame.new(0,0,-12.5)},.3,"Sine","Out",0,false,0)
--root.CFrame=root.CFrame*CFrame.new(0,0,.075)
wait(0.3)
root.Anchored=false
attack = false
end

function attackthree()
attack = true
hum.WalkSpeed = 0
local rootCF=euler(-1.57,0,3.14)
local keptcolor = MAINRUINCOLOR
local al=.3
local typ="Back"
local direc="Out"
  	local Alpha,Easing,Direction,Repeat,Reverse,Delay = .3,'Back','Out',0,false,0
  	TweenAnimate(RootJoint,{C0=cf(0,0,0)*angles(math.rad(-37),math.rad(-61.6),math.rad(-31.8))*RootCF},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(LH,{C0=cf(-1,-1,0)*angles(math.rad(12.6),math.rad(35.4),math.rad(2.8))*angles(math.rad(0),math.rad(-90),math.rad(0))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(RH,{C0=cf(0.9,-0.8,-0.8)*angles(math.rad(-39.6),math.rad(-14.1),math.rad(18.4))*angles(math.rad(0),math.rad(90),math.rad(0))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(LW,{C0=cf(-1.5,0.7,0)*angles(math.rad(-9.6),math.rad(7.2),math.rad(-17.3))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(RW,{C0=cf(1.5,0.6,0)*angles(math.rad(6.9),math.rad(-2.8),math.rad(11.2))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(Torso.Neck,{C0 =necko*angles(math.rad(-9.3),math.rad(5.5),math.rad(58.4))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
wait(0.3)
  	local Alpha,Easing,Direction,Repeat,Reverse,Delay = .05,'Linear','Out',0,false,0
  	TweenAnimate(RootJoint,{C0=cf(0,0,0)*angles(math.rad(-8.8),math.rad(-32.5),math.rad(-9.2))*RootCF},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(LH,{C0=cf(-1,-1,0)*angles(math.rad(5.1),math.rad(35.1),math.rad(6.9))*angles(math.rad(0),math.rad(-90),math.rad(0))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(RH,{C0=cf(0.7,-0.3,-0.4)*angles(math.rad(4.9),math.rad(-4.9),math.rad(26.4))*angles(math.rad(0),math.rad(90),math.rad(0))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(LW,{C0=cf(-1.5,0.7,0.1)*angles(math.rad(1.6),math.rad(9.3),math.rad(-23.8))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(RW,{C0=cf(1.5,0.6,0)*angles(math.rad(1),math.rad(-3.6),math.rad(15.2))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(Torso.Neck,{C0 =necko*angles(math.rad(3.6),math.rad(14),math.rad(39.1))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
wait(0.05)
CFuncs["Sound"].Create("rbxassetid://182765513", root, 4, 1)
local hitb = Instance.new("Part", char)
        hitb.Anchored = true
        hitb.CanCollide = false
        hitb.FormFactor = 3
        hitb.Name = "Ring"
        hitb.Material = "Neon"
        hitb.Size = Vector3.new(1, 1, 1)
        hitb.Transparency = 1
        hitb.TopSurface = 0
        hitb.BottomSurface = 0
hitb.CFrame = root.CFrame + root.CFrame.lookVector*2
MagniDamage(hitb, 3, 30,60, 0, "Normal")
hitb:Destroy()
local al=.4
local typ="Back"
local direc="Out"
  	local Alpha,Easing,Direction,Repeat,Reverse,Delay = .05,'Linear','Out',0,false,0
  	TweenAnimate(RootJoint,{C0=cf(0,0,0)*angles(math.rad(24),math.rad(45.7),math.rad(-9.4))*RootCF},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(LH,{C0=cf(-1,-1,0)*angles(math.rad(-13.9),math.rad(24.7),math.rad(-9.3))*angles(math.rad(0),math.rad(-90),math.rad(0))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(RH,{C0=cf(1,-0.6,-0.4)*angles(math.rad(-11.4),math.rad(46.9),math.rad(83.4))*angles(math.rad(0),math.rad(90),math.rad(0))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(LW,{C0=cf(-1.5,0.7,0.1)*angles(math.rad(1.6),math.rad(9.3),math.rad(-23.8))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(RW,{C0=cf(1.5,0.7,-0.1)*angles(math.rad(-35.4),math.rad(-4.5),math.rad(22))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(Torso.Neck,{C0 =necko*angles(math.rad(17),math.rad(-5),math.rad(-30.3))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
wait(0.05)
  	local Alpha,Easing,Direction,Repeat,Reverse,Delay = .3,'Back','Out',0,false,0
  	TweenAnimate(RootJoint,{C0=cf(0,0,0)*angles(math.rad(45.4),math.rad(66.5),math.rad(-34.6))*RootCF},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(LH,{C0=cf(-1,-1,-0.2)*angles(math.rad(-17.5),math.rad(0.4),math.rad(-8.9))*angles(math.rad(0),math.rad(-90),math.rad(0))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(RH,{C0=cf(1.2,-0.6,-0.4)*angles(math.rad(-14.9),math.rad(28.5),math.rad(84.9))*angles(math.rad(0),math.rad(90),math.rad(0))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(LW,{C0=cf(-1.4,0.8,0)*angles(math.rad(-1.2),math.rad(6.2),math.rad(-36.4))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(RW,{C0=cf(1.5,0.7,0.1)*angles(math.rad(-41.5),math.rad(-4.5),math.rad(24.4))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(Torso.Neck,{C0 =necko*angles(math.rad(32),math.rad(-16.2),math.rad(-56.9))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
wait(.3)
hum.WalkSpeed = storehumanoidWS
attack = false
end

function attackfour()
attack = true
hum.WalkSpeed = 0
  	local Alpha = .2
  	TweenAnimate(RootJoint,{C0=cf(0,0,0)*angles(math.rad(0),math.rad(-53.8),math.rad(0))*RootCF},Alpha,'Back','Out',0,false,0)
  	TweenAnimate(LH,{C0=cf(-1,-1,0)*angles(math.rad(6.8),math.rad(21.8),math.rad(-15.7))*angles(math.rad(0),math.rad(-90),math.rad(0))},Alpha,'Back','Out',0,false,0)
  	TweenAnimate(RH,{C0=cf(1,-1,0)*angles(math.rad(-16.6),math.rad(-2),math.rad(4.8))*angles(math.rad(0),math.rad(90),math.rad(0))},Alpha,'Back','Out',0,false,0)
  	TweenAnimate(LW,{C0=cf(-1.3,0.4,-0.1)*angles(math.rad(102.2),math.rad(6.3),math.rad(-54.2))},Alpha,'Back','Out',0,false,0)
  	TweenAnimate(RW,{C0=cf(1.4,0.3,0.2)*angles(math.rad(-27.9),math.rad(-10.7),math.rad(-27.9))},Alpha,'Back','Out',0,false,0)
  	TweenAnimate(Torso.Neck,{C0 =cf(0,0,0)*angles(math.rad(0),math.rad(46.1),math.rad(0))*necko},Alpha,'Back','Out',0,false,0)
wait(.2)
local distance = 5
spawn(function()
for i = 0, 4 do
swait(2)
local hit = Instance.new("Part", char)
        hit.Anchored = true
        hit.CanCollide = false
        hit.FormFactor = 3
        hit.Name = "Ring"
        hit.Material = "Neon"
        hit.Size = Vector3.new(1, 1, 1)
        hit.Transparency = 1
        hit.TopSurface = 0
        hit.BottomSurface = 0
hit.CFrame = root.CFrame + root.CFrame.lookVector*distance
MagniDamage(hit, 10, 15,35, 0, "Normal")
			WACKYEFFECT({
				Time = 40,
				EffectType = "Sphere",
				Size = VT(0.01,0.01,0.01),
				Size2 = VT(5, 5, 5),
				Transparency = 0,
				Transparency2 = 1,
				CFrame = hit.CFrame,
				MoveToPos = nil,
				RotationX = 0,
				RotationY = 0,
				RotationZ = 0,
				Material = "Neon",
				Color = MAINRUINCOLOR2,
				SoundID = nil,
				SoundPitch = MRANDOM(9, 12) / 10,
				SoundVolume = 10,
				UseBoomerangMath = true,
				Boomerang = 0,
				SizeBoomerang = 50
			})
			WACKYEFFECT({
				Time = 40,
				EffectType = "Sphere",
				Size = VT(0.01,0.01,0.01),
				Size2 = VT(2.5, 2.5, 2.5),
				Transparency = 0,
				Transparency2 = 1,
				CFrame = hit.CFrame,
				MoveToPos = nil,
				RotationX = 0,
				RotationY = 0,
				RotationZ = 0,
				Material = "Neon",
				Color = MAINRUINCOLOR,
				SoundID = nil,
				SoundPitch = MRANDOM(9, 12) / 10,
				SoundVolume = 10,
				UseBoomerangMath = true,
				Boomerang = 0,
				SizeBoomerang = 50
			})
			for i = 0,8 do
	TEffect2(
			MAINRUINCOLOR, -- BrickColor
			hit.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))), -- CFrame Start
			hit.CFrame*CFrame.new(math.random(-15,15),math.random(-15,15),math.random(-15,15)), -- CFrame End
			15, -- Start Size X
			12, -- Start Size Y
			15, -- Start Size Z
			0, -- End Size X
			0, -- End Size Y
			0, -- End Size Z
			0, -- Start Transparency
			1, -- End Transparency
			0, -- Rad Spin Thing
			true, -- FFF
			"Sphere", -- Mesh
			"", -- Feather Spin Thing
			true, -- Transparency Type
			1, -- Tween Time
			"Quad", -- EasingStyle
			"Out", -- EasingDirection
			1 -- TweenTime v2
	)
			end
for i = 0,6 do
			WACKYEFFECT({
				Time = 40,
				EffectType = "Box",
				Size = VT(0.5,0.01,0.5),
				Size2 = VT(0.1, 10, 0.1),
				Transparency = 0,
				Transparency2 = 1,
				CFrame = hit.CFrame,
				MoveToPos = nil,
				RotationX = math.random(-5,5),
				RotationY = math.random(-5,5),
				RotationZ = math.random(-5,5),
				Material = "Neon",
				Color = MAINRUINCOLOR,
				SoundID = nil,
				SoundPitch = MRANDOM(9, 12) / 10,
				SoundVolume = 10,
				UseBoomerangMath = false,
				Boomerang = 0,
				SizeBoomerang = 0
			})
end
CFuncs["Sound"].Create("rbxassetid://183763506", hit, 5, 1)
game:GetService("Debris"):AddItem(hit, 10)
distance = distance + 6
end
for i = 0, 4 do
swait(2)
local hit = Instance.new("Part", char)
        hit.Anchored = true
        hit.CanCollide = false
        hit.FormFactor = 3
        hit.Name = "Ring"
        hit.Material = "Neon"
        hit.Size = Vector3.new(1, 1, 1)
        hit.Transparency = 1
        hit.TopSurface = 0
        hit.BottomSurface = 0
hit.CFrame = root.CFrame + root.CFrame.lookVector*distance
MagniDamage(hit, 10, 15,35, 0, "Normal")
			WACKYEFFECT({
				Time = 20,
				EffectType = "Sphere",
				Size = VT(0.01,0.01,0.01),
				Size2 = VT(5, 5, 5),
				Transparency = 0,
				Transparency2 = 1,
				CFrame = hit.CFrame,
				MoveToPos = nil,
				RotationX = 0,
				RotationY = 0,
				RotationZ = 0,
				Material = "Neon",
				Color = MAINRUINCOLOR2,
				SoundID = nil,
				SoundPitch = MRANDOM(9, 12) / 10,
				SoundVolume = 10,
				UseBoomerangMath = true,
				Boomerang = 0,
				SizeBoomerang = 50
			})
			WACKYEFFECT({
				Time = 20,
				EffectType = "Sphere",
				Size = VT(0.01,0.01,0.01),
				Size2 = VT(2.5, 2.5, 2.5),
				Transparency = 0,
				Transparency2 = 1,
				CFrame = hit.CFrame,
				MoveToPos = nil,
				RotationX = 0,
				RotationY = 0,
				RotationZ = 0,
				Material = "Neon",
				Color = MAINRUINCOLOR,
				SoundID = nil,
				SoundPitch = MRANDOM(9, 12) / 10,
				SoundVolume = 10,
				UseBoomerangMath = true,
				Boomerang = 0,
				SizeBoomerang = 50
			})
for i = 0,6 do
			WACKYEFFECT({
				Time = 20,
				EffectType = "Box",
				Size = VT(0.5,0.01,0.5),
				Size2 = VT(0.1, 10, 0.1),
				Transparency = 0,
				Transparency2 = 1,
				CFrame = hit.CFrame,
				MoveToPos = nil,
				RotationX = math.random(-5,5),
				RotationY = math.random(-5,5),
				RotationZ = math.random(-5,5),
				Material = "Neon",
				Color = MAINRUINCOLOR,
				SoundID = nil,
				SoundPitch = MRANDOM(9, 12) / 10,
				SoundVolume = 10,
				UseBoomerangMath = false,
				Boomerang = 0,
				SizeBoomerang = 0
			})
end
CFuncs["Sound"].Create("rbxassetid://183763506", hit, 5, 1)
game:GetService("Debris"):AddItem(hit, 10)
distance = distance - 6
end
end)
  	local Alpha = .3
  	TweenAnimate(RootJoint,{C0=cf(0,0,0)*angles(math.rad(0),math.rad(-53.8),math.rad(0))*RootCF},Alpha,'Back','Out',0,false,0)
  	TweenAnimate(LH,{C0=cf(-1,-1,0)*angles(math.rad(6.8),math.rad(21.8),math.rad(-15.7))*angles(math.rad(0),math.rad(-90),math.rad(0))},Alpha,'Back','Out',0,false,0)
  	TweenAnimate(RH,{C0=cf(1,-1,0)*angles(math.rad(-16.6),math.rad(-2),math.rad(4.8))*angles(math.rad(0),math.rad(90),math.rad(0))},Alpha,'Back','Out',0,false,0)
  	TweenAnimate(LW,{C0=cf(-1.3,0.5,-0.2)*angles(math.rad(116),math.rad(-11),math.rad(-48.3))},Alpha,'Back','Out',0,false,0)
  	TweenAnimate(RW,{C0=cf(1.4,0.3,0.2)*angles(math.rad(-27.9),math.rad(-10.7),math.rad(-27.9))},Alpha,'Back','Out',0,false,0)
  	TweenAnimate(Torso.Neck,{C0 =cf(0,0,0)*angles(math.rad(0),math.rad(46.1),math.rad(0))*necko},Alpha,'Back','Out',0,false,0)
wait(.3)
hum.WalkSpeed = storehumanoidWS
attack = false
end

function bootlegcorruption()
attack = true
hum.WalkSpeed = 0
  	local Alpha = .3
  	TweenAnimate(RootJoint,{C0=cf(0,0,0)*angles(math.rad(-25.6),math.rad(1),math.rad(0.5))*RootCF},Alpha,'Back','Out',0,false,0)
  	TweenAnimate(LH,{C0=cf(-1,-1,0)*angles(math.rad(30),math.rad(22.3),math.rad(-3.1))*angles(math.rad(0),math.rad(-90),math.rad(0))},Alpha,'Back','Out',0,false,0)
  	TweenAnimate(RH,{C0=cf(1,-0.9,-0.3)*angles(math.rad(22.6),math.rad(1.5),math.rad(5))*angles(math.rad(0),math.rad(90),math.rad(0))},Alpha,'Back','Out',0,false,0)
  	TweenAnimate(LW,{C0=cf(-1,0.6,-0.5)*angles(math.rad(116),math.rad(-11),math.rad(61.6))},Alpha,'Back','Out',0,false,0)
  	TweenAnimate(RW,{C0=cf(0.9,0.6,-0.5)*angles(math.rad(104.6),math.rad(8.9),math.rad(-89))},Alpha,'Back','Out',0,false,0)
  	TweenAnimate(Torso.Neck,{C0 =cf(0,0,0)*angles(math.rad(0),math.rad(1.7),math.rad(0))*necko},Alpha,'Back','Out',0,false,0)
wait(.3)
			WACKYEFFECT({
				Time = 70,
				EffectType = "Sphere",
				Size = VT(0.01,0.01,0.01),
				Size2 = VT(35, 35, 35),
				Transparency = 0,
				Transparency2 = 1,
				CFrame = Torso.CFrame,
				MoveToPos = nil,
				RotationX = 0,
				RotationY = 0,
				RotationZ = 0,
				Material = "Neon",
				Color = MAINRUINCOLOR,
				SoundID = nil,
				SoundPitch = MRANDOM(9, 12) / 10,
				SoundVolume = 10,
				UseBoomerangMath = true,
				Boomerang = 0,
				SizeBoomerang = 50
			})
			WACKYEFFECT({
				Time = 70,
				EffectType = "Sphere",
				Size = VT(0.01,0.01,0.01),
				Size2 = VT(70, 70, 70),
				Transparency = 0,
				Transparency2 = 1,
				CFrame = Torso.CFrame,
				MoveToPos = nil,
				RotationX = 0,
				RotationY = 0,
				RotationZ = 0,
				Material = "Neon",
				Color = MAINRUINCOLOR2,
				SoundID = nil,
				SoundPitch = MRANDOM(9, 12) / 10,
				SoundVolume = 10,
				UseBoomerangMath = true,
				Boomerang = 0,
				SizeBoomerang = 50
			})
for i = 0,6 do
			WACKYEFFECT({
				Time = 60,
				EffectType = "Box",
				Size = VT(10,0.01,10),
				Size2 = VT(0.1, 169, 0.1), -- This used to be 69
				Transparency = 0,
				Transparency2 = 1,
				CFrame = Torso.CFrame,
				MoveToPos = nil,
				RotationX = math.random(-5,5),
				RotationY = math.random(-5,5),
				RotationZ = math.random(-5,5),
				Material = "Neon",
				Color = MAINRUINCOLOR,
				SoundID = nil,
				SoundPitch = MRANDOM(9, 12) / 10,
				SoundVolume = 10,
				UseBoomerangMath = false,
				Boomerang = 0,
				SizeBoomerang = 0
			})
end
CFuncs["Sound"].Create("rbxassetid://1396758921", char, 7, 1)
CFuncs["Sound"].Create("rbxassetid://3750539322", char, 7, 1)
CFuncs["Sound"].Create("rbxassetid://2042692050", char, 10, 1)
  	local Alpha = .3
  	TweenAnimate(RootJoint,{C0=cf(0,0,0)*angles(math.rad(15.1),math.rad(0),math.rad(0))*RootCF},Alpha,'Back','Out',0,false,0)
  	TweenAnimate(LH,{C0=cf(-1,-1,0)*angles(math.rad(-20.2),math.rad(30.2),math.rad(5.3))*angles(math.rad(0),math.rad(-90),math.rad(0))},Alpha,'Back','Out',0,false,0)
  	TweenAnimate(RH,{C0=cf(1,-1,0)*angles(math.rad(-23.4),math.rad(-10.1),math.rad(-1))*angles(math.rad(0),math.rad(90),math.rad(0))},Alpha,'Back','Out',0,false,0)
  	TweenAnimate(LW,{C0=cf(-1.5,0.5,0.2)*angles(math.rad(103.7),math.rad(-0.5),math.rad(-131))},Alpha,'Back','Out',0,false,0)
  	TweenAnimate(RW,{C0=cf(1.5,0.5,0)*angles(math.rad(82.2),math.rad(0),math.rad(134.4))},Alpha,'Back','Out',0,false,0)
  	TweenAnimate(Torso.Neck,{C0 =cf(0,0,0.1)*angles(math.rad(-4.3),math.rad(0),math.rad(0))*necko},Alpha,'Back','Out',0,false,0)
wait(.3)
hum.WalkSpeed = storehumanoidWS
attack = false
end


function template()
attack = true
hum.WalkSpeed = 0

hum.WalkSpeed = storehumanoidWS
attack = false
end


 
-------------------------------------

if Character:findFirstChild("Animate") then
Character:findFirstChild("Animate"):Remove()
end


if Humanoid:findFirstChild("Animator") then
Humanoid:findFirstChild("Animator"):Remove()
end



-------------------------------------


-------------------------------------

local attacktype = 1
mouse.Button1Down:connect(function()
  if attack == false and attacktype == 1 then
    attacktype = 2
    attackone()
  elseif attack == false and attacktype == 2 then
    attacktype = 3
    attacktwo()
  elseif attack == false and attacktype == 3 then
    attacktype = 4
    attackthree()
  elseif attack == false and attacktype == 4 then
    attacktype = 1
    attackfour()
  end
end)
mouse.KeyDown:connect(function(k)
	if switch == 1 then
if k == "1" and attack == false and Mode ~= 1 then
MAINRUINCOLOR = BrickColor.new("Really red").Color
MAINRUINCOLOR2 = BrickColor.new("Maroon").Color
Mode = 1
RecolorTextAndRename("SANCTUARY",MAINRUINCOLOR,MAINRUINCOLOR2,"Fantasy")
RecolorThing(MAINRUINCOLOR,MAINRUINCOLOR2,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,false,false)
storehumanoidWS = 70
hum.WalkSpeed = storehumanoidWS
newTheme("rbxassetid://4453518004",0,1,1.25)
end
if k == "2" and attack == false and Mode ~= 2 then
MAINRUINCOLOR = BrickColor.new("Bright blue").Color
MAINRUINCOLOR2 = BrickColor.new("Storm blue").Color
Mode = 2
RecolorTextAndRename("EXPONENTIAL",BrickColor.new("Institutional white").Color,MAINRUINCOLOR2,"Code")
RecolorThing(MAINRUINCOLOR,MAINRUINCOLOR2,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,false,false)
storehumanoidWS = 70
hum.WalkSpeed = storehumanoidWS
newTheme("rbxassetid://3329947102",0,1,1.25)
end
if k == "m" and attack == false and Mode == 2 then
MAINRUINCOLOR = BrickColor.new("Storm blue").Color
MAINRUINCOLOR2 = BrickColor.new("Storm blue").Color
Mode = 11
RecolorTextAndRename("₮̷̲́₩̵̲̐ł̶̤͠₴̷̬͝₮̷̼̌Ɇ̶̪͆Đ̴̲͐",BrickColor.new("Institutional white").Color,MAINRUINCOLOR2,"Code")
RecolorThing(MAINRUINCOLOR,MAINRUINCOLOR2,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,false,false)
storehumanoidWS = 70
hum.WalkSpeed = storehumanoidWS
newTheme("rbxassetid://1789295287",0,1,1.25)
end
if k == "3" and attack == false and Mode ~= 3 then
MAINRUINCOLOR = BrickColor.new("Royal purple").Color
MAINRUINCOLOR2 = BrickColor.new("Really black").Color
Mode = 3
RecolorTextAndRename("INDECENCY",BrickColor.new("Really black").Color,MAINRUINCOLOR,"Code")
RecolorThing(MAINRUINCOLOR,MAINRUINCOLOR2,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,false,false)
storehumanoidWS = 16
hum.WalkSpeed = storehumanoidWS
newTheme("rbxassetid://1326552262",0,1,1.25)
end
if k == "m" and attack == false and Mode == 3 then
MAINRUINCOLOR = BrickColor.new("Dark stone grey").Color
MAINRUINCOLOR2 = BrickColor.new("Smoky grey").Color
Mode = 31
RecolorTextAndRename("Uninhibited",BrickColor.new("Really black").Color,MAINRUINCOLOR,"Code")
RecolorThing(MAINRUINCOLOR,MAINRUINCOLOR2,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,false,false)
storehumanoidWS = 9
hum.WalkSpeed = storehumanoidWS
newTheme("rbxassetid://4608631175",0,1,1.25)
end
if k == "4" and attack == false and Mode ~= 4 then
MAINRUINCOLOR = BrickColor.new("Pink").Color
MAINRUINCOLOR2 = BrickColor.new("Carnation pink").Color
Mode = 4
RecolorTextAndRename("Resonance",BrickColor.new("White").Color,MAINRUINCOLOR,"Gotham")
RecolorThing(MAINRUINCOLOR,MAINRUINCOLOR2,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,false,false)
storehumanoidWS = 16
hum.WalkSpeed = storehumanoidWS
newTheme("rbxassetid://4111409836",0,1,1.25)
end
if k == "m" and attack == false and Mode == 4 then
MAINRUINCOLOR = BrickColor.new("Olivine").Color
MAINRUINCOLOR2 = BrickColor.new("White").Color
Mode = 469 -- lol
RecolorTextAndRename("Abundancy",BrickColor.new("White").Color,MAINRUINCOLOR,"Code")
RecolorThing(MAINRUINCOLOR,MAINRUINCOLOR2,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,false,false)
storehumanoidWS = 69
hum.WalkSpeed = storehumanoidWS
newTheme("rbxassetid://1448834469",0,1,1.25)
end
if k == "5" and attack == false and Mode ~= 5 then
MAINRUINCOLOR = BrickColor.new("Daisy orange").Color
MAINRUINCOLOR2 = BrickColor.new("Baby blue").Color
Mode = 5
RecolorTextAndRename("EXHALTION",MAINRUINCOLOR2,MAINRUINCOLOR,"Code")
RecolorThing(MAINRUINCOLOR,MAINRUINCOLOR2,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,false,false)
storehumanoidWS = 50
hum.WalkSpeed = storehumanoidWS
newTheme("rbxassetid://3669988686",0,1,1.25)
end
if k == "6" and attack == false and Mode ~= 6 then
MAINRUINCOLOR = BrickColor.new("Crimson").Color
MAINRUINCOLOR2 = BrickColor.new("White").Color
Mode = 6
RecolorTextAndRename("RITUALISTIC",MAINRUINCOLOR2,MAINRUINCOLOR,"Antique")
RecolorThing(MAINRUINCOLOR,MAINRUINCOLOR2,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,false,false)
storehumanoidWS = 50
hum.WalkSpeed = storehumanoidWS
newTheme("rbxassetid://718825568",0,1,1.25)
end
if k == "m" and attack == false and Mode == 6 then
	attack = true
	hum.WalkSpeed = 0
	newThemeCust("rbxassetid://145045424",31.0197,1,1.25)
	repeat swait()
	  	local Alpha = .3
  	TweenAnimate(RootJoint,{C0=cf(0,0+0.2*math.cos(sine/18),0)*angles(math.rad(-16.9),math.rad(-1.5),math.rad(0))*RootCF},Alpha,'Quart','Out',0,false,0)
  	TweenAnimate(LH,{C0=cf(-1,-1-0.2*math.cos(sine/18),0)*angles(math.rad(17.2),math.rad(7.6),math.rad(-0.5))*angles(math.rad(0),math.rad(-90),math.rad(0))},Alpha,'Quart','Out',0,false,0)
  	TweenAnimate(RH,{C0=cf(1,-1-0.2*math.cos(sine/18),0)*angles(math.rad(19.8),math.rad(-2.9),math.rad(2.4))*angles(math.rad(0),math.rad(90),math.rad(0))},Alpha,'Quart','Out',0,false,0)
  	TweenAnimate(LW,{C0=cf(-1.1,0.1+0.2*math.cos(sine/18),0.3)*angles(math.rad(-26.6),math.rad(31.1),math.rad(32))},Alpha,'Quart','Out',0,false,0)
  	TweenAnimate(RW,{C0=cf(1.2,0.1+0.2*math.cos(sine/18),0.2)*angles(math.rad(-12),math.rad(-14),math.rad(-25.5))},Alpha,'Quart','Out',0,false,0)
  	TweenAnimate(Torso.Neck,{C0 =cf(0,0.1,0.5)*angles(math.rad(-30.3),math.rad(0.8),math.rad(1.9))*necko},Alpha,'Quart','Out',0,false,0)		
	 until kan.TimePosition >= 35.529005998047068715
	MAINRUINCOLOR = BrickColor.new("Crimson").Color
MAINRUINCOLOR2 = BrickColor.new("Really red").Color
Mode = 69
RecolorTextAndRename("DETERMINED",MAINRUINCOLOR2,MAINRUINCOLOR,"Gotham")
RecolorThingQuiet(MAINRUINCOLOR,MAINRUINCOLOR2,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,false,false)
CFuncs["Sound"].Create("rbxassetid://3190948728", root, 2, 1)
CFuncs["Sound"].Create("rbxassetid://2237297994", root, 2, 1)
		sphere2(3,"Add",tors.CFrame,vt(1,1,1),0.25,0.25,0.25,MAINRUINCOLOR)
sphere2(4,"Add",tors.CFrame,vt(1,1,1),0.5,0.5,0.5,MAINRUINCOLOR2)
sphere2(5,"Add",tors.CFrame,vt(1,1,1),0.75,0.75,0.75,MAINRUINCOLOR)
for i = 0, 24 do
slash(math.random(15,30)/15,3,true,"Round","Add","Out",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(150,350.5)/250,MAINRUINCOLOR)
end
CFuncs["Sound"].Create("rbxassetid://206082327", root, 10,1)
CFuncs["Sound"].Create("rbxassetid://1368637781", root, 10,1)
CFuncs["Sound"].Create("rbxassetid://763718160", root, 10, 1.1)
CFuncs["Sound"].Create("rbxassetid://1310128035", root, 10, 0.9)
for i = 0, 9 do
	Beamring(MAINRUINCOLOR2,root.CFrame*CFrame.new(0,0,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),math.random(10,100)/10,0,math.random(1,5),348103573)
end
	repeat swait()
	  	local Alpha = .3
  	TweenAnimate(RootJoint,{C0=cf(0,0+0.2*math.cos(sine/18),0)*angles(math.rad(-16.9),math.rad(-1.5),math.rad(0))*RootCF},Alpha,'Quart','Out',0,false,0)
  	TweenAnimate(LH,{C0=cf(-1,-1-0.2*math.cos(sine/18),0)*angles(math.rad(17.2),math.rad(7.6),math.rad(-0.5))*angles(math.rad(0),math.rad(-90),math.rad(0))},Alpha,'Quart','Out',0,false,0)
  	TweenAnimate(RH,{C0=cf(1,-1-0.2*math.cos(sine/18),0)*angles(math.rad(19.8),math.rad(-2.9),math.rad(2.4))*angles(math.rad(0),math.rad(90),math.rad(0))},Alpha,'Quart','Out',0,false,0)
  	TweenAnimate(LW,{C0=cf(-1.1,0.1+0.2*math.cos(sine/18),0.3)*angles(math.rad(-26.6),math.rad(31.1),math.rad(32))},Alpha,'Quart','Out',0,false,0)
  	TweenAnimate(RW,{C0=cf(1.2,0.1+0.2*math.cos(sine/18),0.2)*angles(math.rad(-12),math.rad(-14),math.rad(-25.5))},Alpha,'Quart','Out',0,false,0)
  	TweenAnimate(Torso.Neck,{C0 =cf(0,0.1,0.5)*angles(math.rad(-30.3+3*math.sin(sine/18)),math.rad(0.8),math.rad(1.9))*necko},Alpha,'Quart','Out',0,false,0)		
	 until kan.TimePosition >= 52.3
	repeat swait()
  	local Alpha = .3
  	TweenAnimate(RootJoint,{C0=cf(0,0+0.2*math.cos(sine/18),0)*angles(math.rad(0.2),math.rad(-1.5),math.rad(0))*RootCF},Alpha,'Quart','Out',0,false,0)
  	TweenAnimate(LH,{C0=cf(-1,-1-0.2*math.cos(sine/18),0)*angles(math.rad(-1.4),math.rad(7.6),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0))},Alpha,'Quart','Out',0,false,0)
  	TweenAnimate(RH,{C0=cf(1,-1-0.2*math.cos(sine/18),0)*angles(math.rad(-1.2),math.rad(-2.9),math.rad(2.9))*angles(math.rad(0),math.rad(90),math.rad(0))},Alpha,'Quart','Out',0,false,0)
  	TweenAnimate(LW,{C0=cf(-1.3,0.6+0.2*math.cos(sine/18),0.5)*angles(math.rad(85.1),math.rad(-4.6),math.rad(-97))},Alpha,'Quart','Out',0,false,0)
  	TweenAnimate(RW,{C0=cf(1.2,0.1+0.2*math.cos(sine/18),0.2)*angles(math.rad(-12),math.rad(-14),math.rad(-25.5))},Alpha,'Quart','Out',0,false,0)
  	TweenAnimate(Torso.Neck,{C0 =cf(0,0.1,0.5)*angles(math.rad(-30.3+3*math.sin(sine/18)),math.rad(0.8),math.rad(1.9))*necko},Alpha,'Quart','Out',0,false,0)
	 until kan.TimePosition >= 55.199745224043724079
	repeat swait()
  	local Alpha = .3
  	TweenAnimate(RootJoint,{C0=cf(0,0+0.2*math.cos(sine/18),0)*angles(math.rad(0.2),math.rad(-1.5),math.rad(0))*RootCF},Alpha,'Quart','Out',0,false,0)
  	TweenAnimate(LH,{C0=cf(-1,-1-0.2*math.cos(sine/18),0)*angles(math.rad(-1.4),math.rad(7.6),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0))},Alpha,'Quart','Out',0,false,0)
  	TweenAnimate(RH,{C0=cf(1,-1-0.2*math.cos(sine/18),0)*angles(math.rad(-1.2),math.rad(-2.9),math.rad(2.9))*angles(math.rad(0),math.rad(90),math.rad(0))},Alpha,'Quart','Out',0,false,0)
  	TweenAnimate(LW,{C0=cf(-1.1,0+0.2*math.cos(sine/18),0.1)*angles(math.rad(-11.8),math.rad(-12.7),math.rad(35.8))},Alpha,'Quart','Out',0,false,0)
  	TweenAnimate(RW,{C0=cf(1.3,0.5+0.2*math.cos(sine/18),0.3)*angles(math.rad(79.7),math.rad(-2),math.rad(81.5))},Alpha,'Quart','Out',0,false,0)
  	TweenAnimate(Torso.Neck,{C0 =cf(0,0.1,0.5)*angles(math.rad(-30.3+3*math.sin(sine/18)),math.rad(0.8),math.rad(1.9))*necko},Alpha,'Quart','Out',0,false,0)
	until kan.TimePosition >= 57.582591206068173051
	repeat swait()
  	local Alpha = .3
  	TweenAnimate(RootJoint,{C0=cf(0,0+0.2*math.cos(sine/18),0)*angles(math.rad(0.2),math.rad(-1.5),math.rad(0))*RootCF},Alpha,'Quart','Out',0,false,0)
  	TweenAnimate(LH,{C0=cf(-1,-1-0.2*math.cos(sine/18),0)*angles(math.rad(-1.4),math.rad(7.6),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0))},Alpha,'Quart','Out',0,false,0)
  	TweenAnimate(RH,{C0=cf(1,-1-0.2*math.cos(sine/18),0)*angles(math.rad(-1.2),math.rad(-2.9),math.rad(2.9))*angles(math.rad(0),math.rad(90),math.rad(0))},Alpha,'Quart','Out',0,false,0)
  	TweenAnimate(LW,{C0=cf(-1.1,0+0.2*math.cos(sine/18),0.1)*angles(math.rad(-11.8),math.rad(-12.7),math.rad(35.8))},Alpha,'Quart','Out',0,false,0)
  	TweenAnimate(RW,{C0=cf(1.2,0.1+0.2*math.cos(sine/18),0.1)*angles(math.rad(-19.9),math.rad(9.2),math.rad(-29.5))},Alpha,'Quart','Out',0,false,0)
  	TweenAnimate(Torso.Neck,{C0 =cf(0,0,0)*angles(math.rad(-0.1+3*math.sin(sine/18)),math.rad(1),math.rad(1.2))*necko},Alpha,'Quart','Out',0,false,0)
	until kan.TimePosition >= 61.080716703028883785
		repeat swait()
  	local Alpha = .3
  	TweenAnimate(RootJoint,{C0=cf(0,0+0.2*math.cos(sine/18),0)*angles(math.rad(0.2),math.rad(-1.5),math.rad(0))*RootCF},Alpha,'Quart','Out',0,false,0)
  	TweenAnimate(LH,{C0=cf(-1,-1-0.2*math.cos(sine/18),0)*angles(math.rad(-1.4),math.rad(7.6),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0))},Alpha,'Quart','Out',0,false,0)
  	TweenAnimate(RH,{C0=cf(1,-1-0.2*math.cos(sine/18),0)*angles(math.rad(-1.2),math.rad(-2.9),math.rad(2.9))*angles(math.rad(0),math.rad(90),math.rad(0))},Alpha,'Quart','Out',0,false,0)
  	TweenAnimate(LW,{C0=cf(-1.3,0.6+0.2*math.cos(sine/18),0.5)*angles(math.rad(85.1),math.rad(-4.6),math.rad(-97))},Alpha,'Quart','Out',0,false,0)
  	TweenAnimate(RW,{C0=cf(1.2,0.1+0.2*math.cos(sine/18),0.2)*angles(math.rad(-12),math.rad(-14),math.rad(-25.5))},Alpha,'Quart','Out',0,false,0)
  	TweenAnimate(Torso.Neck,{C0 =cf(0,0.1,0.5)*angles(math.rad(-30.3+3*math.sin(sine/18)),math.rad(0.8),math.rad(1.9))*necko},Alpha,'Quart','Out',0,false,0)
		 until kan.TimePosition >= 63.912733727134764194
		repeat swait()
  	local Alpha = .3
  	TweenAnimate(RootJoint,{C0=cf(0,0+0.2*math.cos(sine/18),0)*angles(math.rad(0.2),math.rad(-1.5),math.rad(0))*RootCF},Alpha,'Quart','Out',0,false,0)
  	TweenAnimate(LH,{C0=cf(-1,-1-0.2*math.cos(sine/18),0)*angles(math.rad(-1.4),math.rad(7.6),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0))},Alpha,'Quart','Out',0,false,0)
  	TweenAnimate(RH,{C0=cf(1,-1-0.2*math.cos(sine/18),0)*angles(math.rad(-1.2),math.rad(-2.9),math.rad(2.9))*angles(math.rad(0),math.rad(90),math.rad(0))},Alpha,'Quart','Out',0,false,0)
  	TweenAnimate(LW,{C0=cf(-1.1,0+0.2*math.cos(sine/18),0.1)*angles(math.rad(-11.8),math.rad(-12.7),math.rad(35.8))},Alpha,'Quart','Out',0,false,0)
  	TweenAnimate(RW,{C0=cf(1.3,0.5+0.2*math.cos(sine/18),0.3)*angles(math.rad(79.7),math.rad(-2),math.rad(81.5))},Alpha,'Quart','Out',0,false,0)
  	TweenAnimate(Torso.Neck,{C0 =cf(0,0.1,0.5)*angles(math.rad(-30.3+3*math.sin(sine/18)),math.rad(0.8),math.rad(1.9))*necko},Alpha,'Quart','Out',0,false,0)
		until kan.TimePosition >= 66.163192623062059283
		RecolorThing(MAINRUINCOLOR,MAINRUINCOLOR2,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,false,false)
		newTheme("rbxassetid://145045424",0,1,1.25)
storehumanoidWS = 70
hum.WalkSpeed = storehumanoidWS
attack = false
end
if k == "7" and attack == false and Mode ~= 7 then
MAINRUINCOLOR = BrickColor.new("White").Color
MAINRUINCOLOR2 = BrickColor.new("White").Color
Mode = 7
RecolorTextAndRename("MARIGOLD",MAINRUINCOLOR2,MAINRUINCOLOR,"Code")
RecolorThing(MAINRUINCOLOR,MAINRUINCOLOR2,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,false,false)
storehumanoidWS = 100
hum.WalkSpeed = storehumanoidWS
newTheme("rbxassetid://4813501413",0,1,1.25)
end
if k == "8" and attack == false and Mode ~= 8 then
MAINRUINCOLOR = BrickColor.new("Pink").Color
MAINRUINCOLOR2 = BrickColor.new("Carnation pink").Color
Mode = 8
RecolorTextAndRename("恋煩いの",MAINRUINCOLOR2,MAINRUINCOLOR,"Cartoon")
RecolorThing(MAINRUINCOLOR,MAINRUINCOLOR2,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,false,false)
storehumanoidWS = 10
hum.WalkSpeed = storehumanoidWS
newTheme("rbxassetid://4814933503",0,1,1.25)
end
if k == "9" and attack == false and Mode ~= 9 then
MAINRUINCOLOR = BrickColor.new("Neon orange").Color
MAINRUINCOLOR2 = BrickColor.new("CGA brown").Color
Mode = 9
RecolorTextAndRename("FIRESTORM",MAINRUINCOLOR2,MAINRUINCOLOR,"Fantasy")
RecolorThing(MAINRUINCOLOR,MAINRUINCOLOR2,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,false,false)
storehumanoidWS = 25
hum.WalkSpeed = storehumanoidWS
newTheme("rbxassetid://4742132179",0,1,1.25)
end
if k == "m" and attack == false and Mode == 1 then
MAINRUINCOLOR = BrickColor.new("Maroon").Color
MAINRUINCOLOR2 = BrickColor.new("Really black").Color
Mode = 10
RecolorTextAndRename("MALEVOLENCE",MAINRUINCOLOR2,MAINRUINCOLOR,"Highway")
RecolorThing(MAINRUINCOLOR,MAINRUINCOLOR2,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,false,false)
storehumanoidWS = 7
hum.WalkSpeed = storehumanoidWS
newTheme("rbxassetid://1859929072",0,1,1.25)
end
end
if k == "l" and mutedtog == false then
mutedtog = true
kan:Pause()
elseif k == "l" and mutedtog == true then
mutedtog = false
kan:Resume()
end
if k == ";" and attack == false and hum.Health ~= hum.MaxHealth then
Heal()
end
--[[
if k == "-" then
switch = switch + 1
if switch > 2 then
switch = 1
end
end
]]--
if k == "z" and attack == false and Mode == 3 then
	bootlegcorruption()
end
end)

spawn(function()
while true do
swait()
if BarrierEnabled == false then
--Automatic-Healing-System (AHS)
hum.Health = hum.Health + 1
hum.MaxHealth = hum.MaxHealth + 1
elseif BarrierEnabled == true then
-- no
end
end
end)


plr.Chatted:connect(function(msg)
newbosschatfunc(msg,MAINRUINCOLOR,MAINRUINCOLOR2,250)
end)
--[[
local glitchMeshes = {}	

function genGlitches()
	clearGlitches()
	for _,v in next, char:children() do
		if(v:IsA'Part' and v.Name~='Ring')then
			local mesh = v:FindFirstChildOfClass'SpecialMesh'
			if(mesh)then
				mesh.Parent=nil
				local glitched = mesh:Clone()
				glitched.Parent=v
				table.insert(glitchMeshes,{Part=v,Original=mesh,New=glitched;})
			else
				table.insert(glitchMeshes,{Part=v,New=Instance.new("BlockMesh",v);})
			end
		elseif(v:IsA'Accessory' and v:FindFirstChild'Handle')then
			local mesh = v.Handle:FindFirstChildOfClass'SpecialMesh'
			if(mesh)then
				mesh.Parent=nil
				local glitched = mesh:Clone()
				glitched.Parent=v.Handle
				table.insert(glitchMeshes,{Part=v.Handle,Original=mesh,New=glitched;})
			else
				table.insert(glitchMeshes,{Part=v.Handle,New=Instance.new("BlockMesh",v.Handle);})
			end
		end
	end
end

function clearGlitches()
	for _,v in next, glitchMeshes do
		if(v.Original)then
			v.Original.Parent=v.Part
		end
		v.New:destroy()
	end
	glitchMeshes={}
end

function causeGlitch(intensity)
	local intensity = intensity or 1
	for _,v in next, glitchMeshes do
		v.New.Offset=Vector3.new((math.random(-1,1)/10)*intensity,(math.random(-1,1)/10)*intensity,(math.random(-1,1)/10)*intensity)
	end
end

local Glitching=false
local lastGlitch=tick()
local static = Instance.new("Sound")
static.Volume=1
static.SoundId='rbxassetid://0'
					local orig=kan:Clone()
					orig.Parent = char
					orig:Stop()
					orig.SoundId=kan.SoundId
					orig.Name = "noob"

coroutine.wrap(function()
	while true do
		swait()
		if(Mode==61 or Mode==7)then
			if(tick()-lastGlitch>=(math.random()*2) and math.random(0,30)==1 and not Glitching)then
				genGlitches()
				Glitching=true
				static.Parent=tors
				wait()
				static:Play()
				orig:Play()
				local start=tick()
				repeat swait()
					orig.SoundId=kan.SoundId
					local quikmath=math.random(1,150)
					orig.TimePosition=quikmath
					for i,v in pairs(char:GetChildren())do
						if v:IsA("Part") or v:IsA("BasePart") then
					v.BrickColor = BrickColor.Random()
					v.Material = "Neon"
					end
					end
					causeGlitch(5)
				until tick()-start>=(math.random()*2)+0.1
				lastGlitch=tick()
				Glitching=false
				clearGlitches()
				static:Stop()
				orig:Stop()
				for i,v in pairs(char:GetChildren())do
						if v:IsA("Part") or v:IsA("BasePart") then
				v.BrickColor = BrickColor.new("Nougat")
				v.Material = "Plastic"
						end
						end
				static.Parent=nil
			end
		end
	end	
end)()
]]--

coroutine.resume(coroutine.create(function()
while true do
swait()
hitfloor,posfloor=rayCast(RootPart.Position,(CFrame.new(RootPart.Position,RootPart.Position - Vector3.new(0,1,0))).lookVector,4,Character)
if hitfloor ~= nil then -- Effectz (Normal)
	if Mode == 1 then
		swait(1)
		WACKYEFFECT({
				Time = 30,
				EffectType = "Box",
				Size = VT(0.01,0.01,0.01),
				Size2 = VT(0.3, math.random(5,15), 0.3),
				Transparency = 0,
				Transparency2 = 1,
				CFrame = root.CFrame*CFrame.new(math.random(-15,15),-3,math.random(-15,15))*angles(math.rad(0 + math.random(-30,30)*math.cos(sine/32)),math.rad(0 + math.random(-30,30)*math.cos(sine/32)),math.rad(0 + math.random(-30,30)*math.cos(sine/32))),
				MoveToPos = nil,
				RotationX = math.random(-5,5),
				RotationY = math.random(-5,5),
				RotationZ = math.random(-5,5),
				Material = "Neon",
				Color = MAINRUINCOLOR2,
				SoundID = nil,
				SoundPitch = MRANDOM(9, 12) / 10,
				SoundVolume = 10,
				UseBoomerangMath = true,
				Boomerang = 0,
				SizeBoomerang = 50
		})
	elseif Mode == 2 then
		WACKYEFFECT({
				Time = 30,
				EffectType = "Wedge",
				Size = VT(0.01, 1, 1),
				Size2 = VT(0.01, 1, 1),
				Transparency = 0,
				Transparency2 = 1,
				CFrame = root.CFrame*CFrame.new(math.random(-15,15),-3,math.random(-15,15))*angles(math.rad(0 + math.random(-30,30)*math.cos(sine/32)),math.rad(0 + math.random(-30,30)*math.cos(sine/32)),math.rad(0 + math.random(-30,30)*math.cos(sine/32))),
				MoveToPos = root.CFrame*CFrame.new(math.random(-15,15),3,math.random(-15,15)).p,
				RotationX = math.random(-5,5),
				RotationY = math.random(-5,5),
				RotationZ = math.random(-5,5),
				Material = "Neon",
				Color = MAINRUINCOLOR2,
				SoundID = nil,
				SoundPitch = MRANDOM(9, 12) / 10,
				SoundVolume = 10,
				UseBoomerangMath = false,
				Boomerang = 0,
				SizeBoomerang = 50
		})
elseif Mode == 3 then
	lepod = math.random(-15,15)
	lepod2 = math.random(-15,15)
	swait(1)
	WACKYEFFECT({
				Time = 30,
				EffectType = "Box",
				Size = VT(0.01, 1, 1),
				Size2 = VT(0.01, 1, 1),
				Transparency = 0,
				Transparency2 = 1,
				CFrame = root.CFrame*CFrame.new(lepod,-3,lepod2)*angles(math.rad(0 + math.random(-30,30)*math.cos(sine/32)),math.rad(0 + math.random(-30,30)*math.cos(sine/32)),math.rad(0 + math.random(-30,30)*math.cos(sine/32))),
				MoveToPos = root.CFrame*CFrame.new(lepod,5,lepod2).p,
				RotationX = math.random(-5,5),
				RotationY = math.random(-5,5),
				RotationZ = math.random(-5,5),
				Material = "Neon",
				Color = MAINRUINCOLOR,
				SoundID = nil,
				SoundPitch = MRANDOM(9, 12) / 10,
				SoundVolume = 10,
				UseBoomerangMath = false,
				Boomerang = 0,
				SizeBoomerang = 50
	})
	elseif Mode == 4 then
	swait(2)
	spawn(function()
			lepod = math.random(-30,30)
	lepod2 = math.random(-30,30)
	WACKYEFFECT({
				Time = 15,
				EffectType = "Sphere",
				Size = VT(.7, 4, .7),
				Size2 = VT(0.7, 4, 0.7),
				Transparency = 0.5,
				Transparency2 = 0,
				CFrame = root.CFrame*CFrame.new(lepod,20,lepod2),
				MoveToPos = root.CFrame*CFrame.new(lepod,-3,lepod2).p,
				RotationX = 0,
				RotationY = 0,
				RotationZ = 0,
				Material = "Neon",
				Color = MAINRUINCOLOR,
				SoundID = nil,
				SoundPitch = MRANDOM(9, 12) / 10,
				SoundVolume = 10,
				UseBoomerangMath = false,
				Boomerang = 0,
				SizeBoomerang = 100
	})
		swait(15)
		WACKYEFFECT({
				Time = 60,
				EffectType = "Sphere",
				Size = VT(1, 4, .1),
				Size2 = VT(8, 0.01, 8),
				Transparency = 0.5,
				Transparency2 = 1,
				CFrame = root.CFrame*CFrame.new(lepod,-3,lepod2),
				MoveToPos = nil,
				RotationX = 0,
				RotationY = 0,
				RotationZ = 0,
				Material = "Neon",
				Color = MAINRUINCOLOR2,
				SoundID = nil,
				SoundPitch = MRANDOM(9, 12) / 10,
				SoundVolume = 10,
				UseBoomerangMath = false,
				Boomerang = 0,
				SizeBoomerang = 100
	})
	end)
	elseif Mode == 5 then
		swait(4)
		local lepod1 = math.random(-60,60)
		local lepod2 = math.random(-60,60)
		local lepod3 = math.random(-60,60)
		TEffect2(
			MAINRUINCOLOR, -- BrickColor
			root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))), -- CFrame Start
			root.CFrame*CFrame.new(0,-3,0)*CFrame.new(math.random(-15,15),0,math.random(-15,15)), -- CFrame End
			15, -- Start Size X
			12, -- Start Size Y
			15, -- Start Size Z
			0, -- End Size X
			0, -- End Size Y
			0, -- End Size Z
			0, -- Start Transparency
			1, -- End Transparency
			0, -- Rad Spin Thing
			true, -- FFF
			"Wedge", -- Mesh
			"", -- Feather Spin Thing
			true, -- Transparency Type
			0.5, -- Tween Time
			"Quad", -- EasingStyle
			"Out", -- EasingDirection
			0.5 -- TweenTime v2
		)
		for i = 0,8 do
	TEffect2(
			MAINRUINCOLOR, -- BrickColor
			root.CFrame*CFrame.new(lepod1,lepod2,lepod3)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))), -- CFrame Start
			root.CFrame*CFrame.new(lepod1,lepod2,lepod3)*CFrame.new(math.random(-30,30),math.random(-30,30),math.random(-30,30)), -- CFrame End
			20, -- Start Size X
			12, -- Start Size Y
			20, -- Start Size Z
			0, -- End Size X
			0, -- End Size Y
			0, -- End Size Z
			0, -- Start Transparency
			1, -- End Transparency
			0, -- Rad Spin Thing
			true, -- FFF
			"Sphere", -- Mesh
			"", -- Feather Spin Thing
			true, -- Transparency Type
			0.5, -- Tween Time
			"Quad", -- EasingStyle
			"Out", -- EasingDirection
			0.5 -- TweenTime v2
	)
	end
	elseif Mode == 7 then
		TEffect2(
			MAINRUINCOLOR, -- BrickColor
			root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(0,math.rad(sine*4),0), -- CFrame Start
			root.CFrame*CFrame.new(0-50*math.sin(sine/6),-3,0+50*math.cos(sine/6))*CFrame.Angles(0,math.rad(sine*4),0), -- CFrame End
			15, -- Start Size X
			0.1, -- Start Size Y
			15, -- Start Size Z
			0, -- End Size X
			0, -- End Size Y
			0, -- End Size Z
			0, -- Start Transparency
			1, -- End Transparency
			40, -- Rad Spin Thing
			true, -- FFF
			"Brick", -- Mesh
			"", -- Feather Spin Thing
			true, -- Transparency Type
			2, -- Tween Time
			"Quad", -- EasingStyle
			"Out", -- EasingDirection
			2 -- TweenTime v2
		)
		TEffect2(
			MAINRUINCOLOR, -- BrickColor
			root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(0,math.rad(sine*4),0), -- CFrame Start
			root.CFrame*CFrame.new(0+25*math.sin(sine/18),-3,0-25*math.cos(sine/18))*CFrame.Angles(0,math.rad(sine*4),0), -- CFrame End
			15, -- Start Size X
			0.1, -- Start Size Y
			15, -- Start Size Z
			0, -- End Size X
			0, -- End Size Y
			0, -- End Size Z
			0, -- Start Transparency
			1, -- End Transparency
			40, -- Rad Spin Thing
			true, -- FFF
			"Brick", -- Mesh
			"", -- Feather Spin Thing
			true, -- Transparency Type
			2, -- Tween Time
			"Quad", -- EasingStyle
			"Out", -- EasingDirection
			2 -- TweenTime v2
		)
		TEffect2(
			MAINRUINCOLOR, -- BrickColor
			root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(0,math.rad(sine*4),0), -- CFrame Start
			root.CFrame*CFrame.new(0-50*math.sin(sine/6),-3,0-50*math.cos(sine/6))*CFrame.Angles(0,math.rad(sine*4),0), -- CFrame End
			15, -- Start Size X
			0.1, -- Start Size Y
			15, -- Start Size Z
			0, -- End Size X
			0, -- End Size Y
			0, -- End Size Z
			0, -- Start Transparency
			1, -- End Transparency
			40, -- Rad Spin Thing
			true, -- FFF
			"Brick", -- Mesh
			"", -- Feather Spin Thing
			true, -- Transparency Type
			2, -- Tween Time
			"Quad", -- EasingStyle
			"Out", -- EasingDirection
			2 -- TweenTime v2
		)
		TEffect2(
			MAINRUINCOLOR, -- BrickColor
			root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(0,math.rad(sine*4),0), -- CFrame Start
			root.CFrame*CFrame.new(0-25*math.sin(sine/14),-3,0-25*math.cos(sine/14))*CFrame.Angles(0,math.rad(sine*4),0), -- CFrame End
			15, -- Start Size X
			0.1, -- Start Size Y
			15, -- Start Size Z
			0, -- End Size X
			0, -- End Size Y
			0, -- End Size Z
			0, -- Start Transparency
			1, -- End Transparency
			40, -- Rad Spin Thing
			true, -- FFF
			"Brick", -- Mesh
			"", -- Feather Spin Thing
			true, -- Transparency Type
			2, -- Tween Time
			"Quad", -- EasingStyle
			"Out", -- EasingDirection
			2 -- TweenTime v2
		)
				elseif Mode == 8 then
					local lepod = math.random(-15,15)
			local lepod2 = math.random(-15,15)
			local lepod3 = math.random(-15,15)
			WACKYEFFECT({
				Time = 10,
				EffectType = "Box",
				Size = VT(0.8,0.8,0.8),
				Size2 = VT(0, 0, 0),
				Transparency = 0,
				Transparency2 = 1,
				CFrame = root.CFrame*CFrame.new(lepod,lepod3,lepod2)*angles(math.rad(0 + math.random(-30,30)*math.cos(sine/32)),math.rad(0 + math.random(-30,30)*math.cos(sine/32)),math.rad(0 + math.random(-30,30)*math.cos(sine/32))),
				MoveToPos = root.CFrame*CFrame.new(lepod+math.random(-3,3),lepod3+math.random(-3,3),lepod2+math.random(-3,3)).p,
				RotationX = math.random(-5,5),
				RotationY = math.random(-5,5),
				RotationZ = math.random(-5,5),
				Material = "Neon",
				Color = MAINRUINCOLOR2,
				SoundID = nil,
				SoundPitch = MRANDOM(9, 12) / 10,
				SoundVolume = 10,
				UseBoomerangMath = false,
				Boomerang = 20,
				SizeBoomerang = 0
			})
			local lepod = math.random(-15,15)
			local lepod2 = math.random(-15,15)
			local lepod3 = math.random(-15,15)
			WACKYEFFECT({
				Time = 10,
				EffectType = "Box",
				Size = VT(0.8,0.8,0.8),
				Size2 = VT(0, 0, 0),
				Transparency = 0,
				Transparency2 = 1,
				CFrame = root.CFrame*CFrame.new(lepod,lepod3,lepod2)*angles(math.rad(0 + math.random(-30,30)*math.cos(sine/32)),math.rad(0 + math.random(-30,30)*math.cos(sine/32)),math.rad(0 + math.random(-30,30)*math.cos(sine/32))),
				MoveToPos = root.CFrame*CFrame.new(lepod+math.random(-3,3),lepod3+math.random(-3,3),lepod2+math.random(-3,3)).p,
				RotationX = math.random(-5,5),
				RotationY = math.random(-5,5),
				RotationZ = math.random(-5,5),
				Material = "Neon",
				Color = MAINRUINCOLOR2,
				SoundID = nil,
				SoundPitch = MRANDOM(9, 12) / 10,
				SoundVolume = 10,
				UseBoomerangMath = false,
				Boomerang = 20,
				SizeBoomerang = 0
			})
			local lepod = math.random(-15,15)
			local lepod2 = math.random(-15,15)
			local lepod3 = math.random(-15,15)
			WACKYEFFECT({
				Time = 10,
				EffectType = "Box",
				Size = VT(0.8,0.8,0.8),
				Size2 = VT(0, 0, 0),
				Transparency = 0,
				Transparency2 = 1,
				CFrame = root.CFrame*CFrame.new(lepod,lepod3,lepod2)*angles(math.rad(0 + math.random(-30,30)*math.cos(sine/32)),math.rad(0 + math.random(-30,30)*math.cos(sine/32)),math.rad(0 + math.random(-30,30)*math.cos(sine/32))),
				MoveToPos = root.CFrame*CFrame.new(lepod+math.random(-3,3),lepod3+math.random(-3,3),lepod2+math.random(-3,3)).p,
				RotationX = math.random(-5,5),
				RotationY = math.random(-5,5),
				RotationZ = math.random(-5,5),
				Material = "Neon",
				Color = MAINRUINCOLOR2,
				SoundID = nil,
				SoundPitch = MRANDOM(9, 12) / 10,
				SoundVolume = 10,
				UseBoomerangMath = false,
				Boomerang = 20,
				SizeBoomerang = 0
			})
			local lepod = math.random(-15,15)
			local lepod2 = math.random(-15,15)
			local lepod3 = math.random(-15,15)
			WACKYEFFECT({
				Time = 10,
				EffectType = "Sphere",
				Size = VT(3.5,3.5,3.5),
				Size2 = VT(0, 0, 0),
				Transparency = 0.5,
				Transparency2 = 1,
				CFrame = root.CFrame*CFrame.new(lepod,lepod3,lepod2)*angles(math.rad(0 + math.random(-30,30)*math.cos(sine/32)),math.rad(0 + math.random(-30,30)*math.cos(sine/32)),math.rad(0 + math.random(-30,30)*math.cos(sine/32))),
				MoveToPos = nil,
				RotationX = math.random(-5,5),
				RotationY = math.random(-5,5),
				RotationZ = math.random(-5,5),
				Material = "Neon",
				Color = MAINRUINCOLOR2,
				SoundID = nil,
				SoundPitch = MRANDOM(9, 12) / 10,
				SoundVolume = 10,
				UseBoomerangMath = false,
				Boomerang = 20,
				SizeBoomerang = 0
			})
			WACKYEFFECT({
				Time = 8,
				EffectType = "Sphere",
				Size = VT(0.01,0.01,0.01),
				Size2 = VT(kan.PlaybackLoudness/40, 0.01, kan.PlaybackLoudness/40),
				Transparency = 0,
				Transparency2 = 1,
				CFrame = root.CFrame*CFrame.new(0,-3,0),
				MoveToPos = nil,
				RotationX = 0,
				RotationY = 0,
				RotationZ = 0,
				Material = "Neon",
				Color = MAINRUINCOLOR2,
				SoundID = nil,
				SoundPitch = MRANDOM(9, 12) / 10,
				SoundVolume = 10,
				UseBoomerangMath = false,
				Boomerang = 50,
				SizeBoomerang = 0
			})
		elseif Mode == 9 then
		TEffect2(
			MAINRUINCOLOR,
			root.CFrame*CFrame.new(math.random(-60,60),-3,math.random(-60,60))*CFrame.Angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)), -- CFrame Start
			root.CFrame*CFrame.new(math.random(-60,60),math.random(50,60),math.random(-60,60))*CFrame.Angles(-math.rad(sine*6),math.rad(sine*3),-math.rad(sine*4)), -- CFrame End
			15, -- Start Size X
			15, -- Start Size Y
			15, -- Start Size Z
			0.1, -- End Size X
			0.1, -- End Size Y
			0.1, -- End Size Z
			0, -- Start Transparency
			1, -- End Transparency
			40, -- Rad Spin Thing
			false, -- FFF
			"Brick", -- Mesh
			"", -- Feather Spin Thing
			true, -- Transparency Type
			math.random(10,20)/10, -- Tween Time
			"Quad", -- EasingStyle
			"Out", -- EasingDirection
			math.random(10,20)/10 -- TweenTime v2
		)
		TEffect2(
			MAINRUINCOLOR2,
			root.CFrame*CFrame.new(math.random(-60,60),-3,math.random(-60,60))*CFrame.Angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)), -- CFrame Start
			root.CFrame*CFrame.new(math.random(-60,60),math.random(50,60),math.random(-60,60))*CFrame.Angles(-math.rad(sine*6),math.rad(sine*3),-math.rad(sine*4)), -- CFrame End
			15, -- Start Size X
			15, -- Start Size Y
			15, -- Start Size Z
			0.1, -- End Size X
			0.1, -- End Size Y
			0.1, -- End Size Z
			0, -- Start Transparency
			1, -- End Transparency
			40, -- Rad Spin Thing
			false, -- FFF
			"Brick", -- Mesh
			"", -- Feather Spin Thing
			true, -- Transparency Type
			math.random(10,20)/10, -- Tween Time
			"Quad", -- EasingStyle
			"Out", -- EasingDirection
			math.random(10,20)/10 -- TweenTime v2
		)
		elseif Mode == 10 then
			for i = 0,1 do
		TEffect2(
			MAINRUINCOLOR,
			root.CFrame*CFrame.new(math.random(-60,60),math.random(20,30),math.random(-60,60))*CFrame.Angles(-math.rad(sine*6),math.rad(sine*3),-math.rad(sine*4)), -- CFrame Start
			root.CFrame*CFrame.new(math.random(-60,60),-3,math.random(-60,60))*CFrame.Angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),  -- CFrame End
			2, -- Start Size X
			4, -- Start Size Y
			2, -- Start Size Z
			2, -- End Size X
			4, -- End Size Y
			2, -- End Size Z
			0, -- Start Transparency
			1, -- End Transparency
			40, -- Rad Spin Thing
			false, -- FFF
			"Sphere", -- Mesh
			"", -- Feather Spin Thing
			true, -- Transparency Type
			math.random(10,20)/10, -- Tween Time
			"Quad", -- EasingStyle
			"Out", -- EasingDirection
			math.random(10,20)/10 -- TweenTime v2
		)
		TEffect2(
			MAINRUINCOLOR2,
			root.CFrame*CFrame.new(math.random(-60,60),math.random(20,30),math.random(-60,60))*CFrame.Angles(-math.rad(sine*6),math.rad(sine*3),-math.rad(sine*4)), -- CFrame Start
			root.CFrame*CFrame.new(math.random(-60,60),-3,math.random(-60,60))*CFrame.Angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),  -- CFrame End
			2, -- Start Size X
			4, -- Start Size Y
			2, -- Start Size Z
			2, -- End Size X
			4, -- End Size Y
			2, -- End Size Z
			0, -- Start Transparency
			1, -- End Transparency
			40, -- Rad Spin Thing
			false, -- FFF
			"Sphere", -- Mesh
			"", -- Feather Spin Thing
			true, -- Transparency Type
			math.random(10,20)/10, -- Tween Time
			"Quad", -- EasingStyle
			"Out", -- EasingDirection
			math.random(10,20)/10 -- TweenTime v2
		)
		WACKYEFFECT({
				Time = 15,
				EffectType = "Wedge",
				Size = VT(0.01,15,15),
				Size2 = VT(0.01, 15, 15),
				Transparency = 0.7,
				Transparency2 = 1,
				CFrame = root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(0+math.random(-3,3)),math.rad(math.random(-360,360)),math.rad(90+math.random(-3,3))),
				MoveToPos = root.CFrame*CFrame.new(math.random(-5,5),-3,math.random(-5,5)).p,--root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),
				RotationX = math.random(-10,10),
				RotationY = 0,
				RotationZ = 0,
				Material = "Neon",
				Color = MAINRUINCOLOR,
				SoundID = nil,
				SoundPitch = MRANDOM(9, 12) / 10,
				SoundVolume = 10,
				UseBoomerangMath = false,
				Boomerang = 0,
				SizeBoomerang = 50
			})
		end
end
end
end
end))

coroutine.resume(coroutine.create(function()
while true do
swait()
hitfloor,posfloor=rayCast(RootPart.Position,(CFrame.new(RootPart.Position,RootPart.Position - Vector3.new(0,1,0))).lookVector,4,Character)
if hitfloor ~= nil then -- Effectz 2 (Timed effects)
	if Mode == 1 then
		swait(40)
			WACKYEFFECT({
				Time = 40,
				EffectType = "Sphere",
				Size = VT(0.01,0.01,0.01),
				Size2 = VT(20, 0.01, 20),
				Transparency = 0,
				Transparency2 = 1,
				CFrame = root.CFrame*CFrame.new(0,-3,0),
				MoveToPos = nil,
				RotationX = 0,
				RotationY = 0,
				RotationZ = 0,
				Material = "Neon",
				Color = MAINRUINCOLOR,
				SoundID = nil,
				SoundPitch = MRANDOM(9, 12) / 10,
				SoundVolume = 10,
				UseBoomerangMath = true,
				Boomerang = 0,
				SizeBoomerang = 50
			})
			WACKYEFFECT({
				Time = 40,
				EffectType = "Sphere",
				Size = VT(0.01,0.01,0.01),
				Size2 = VT(10, 0.01, 10),
				Transparency = 0,
				Transparency2 = 1,
				CFrame = root.CFrame*CFrame.new(0,-3,0),
				MoveToPos = nil,
				RotationX = 0,
				RotationY = 0,
				RotationZ = 0,
				Material = "Neon",
				Color = MAINRUINCOLOR2,
				SoundID = nil,
				SoundPitch = MRANDOM(9, 12) / 10,
				SoundVolume = 10,
				UseBoomerangMath = true,
				Boomerang = 0,
				SizeBoomerang = 50
			})
	elseif Mode == 2 then
		swait(50)
			WACKYEFFECT({
				Time = 80,
				EffectType = "Box",
				Size = VT(0.01,0.01,0.01),
				Size2 = VT(15, 0.01, 15),
				Transparency = 0,
				Transparency2 = 1,
				CFrame = root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(0,math.rad(math.random(-360,360)),0),
				MoveToPos = nil,--root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),
				RotationX = 0,
				RotationY = math.random(-10,10),
				RotationZ = 0,
				Material = "Neon",
				Color = MAINRUINCOLOR,
				SoundID = nil,
				SoundPitch = MRANDOM(9, 12) / 10,
				SoundVolume = 10,
				UseBoomerangMath = false,
				Boomerang = 0,
				SizeBoomerang = 50
			})
			WACKYEFFECT({
				Time = 80,
				EffectType = "Box",
				Size = VT(0.01,0.01,0.01),
				Size2 = VT(30, 0.01, 30),
				Transparency = 0,
				Transparency2 = 1,
				CFrame = root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(0,math.rad(math.random(-360,360)),0),
				MoveToPos = nil,--CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))).p,
				RotationX = 0,
				RotationY = math.random(-10,10),
				RotationZ = 0,
				Material = "Neon",
				Color = MAINRUINCOLOR2,
				SoundID = nil,
				SoundPitch = MRANDOM(9, 12) / 10,
				SoundVolume = 10,
				UseBoomerangMath = false,
				Boomerang = 0,
				SizeBoomerang = 0
			})
	elseif Mode == 4 then
		swait(2)
			WACKYEFFECT({
				Time = 15,
				EffectType = "Wedge",
				Size = VT(0.01,15,15),
				Size2 = VT(0.01, 15, 15),
				Transparency = 0.7,
				Transparency2 = 1,
				CFrame = root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(0+math.random(-3,3)),math.rad(math.random(-360,360)),math.rad(90+math.random(-3,3))),
				MoveToPos = root.CFrame*CFrame.new(math.random(-5,5),-3,math.random(-5,5)).p,--root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),
				RotationX = math.random(-10,10),
				RotationY = 0,
				RotationZ = 0,
				Material = "Neon",
				Color = MAINRUINCOLOR,
				SoundID = nil,
				SoundPitch = MRANDOM(9, 12) / 10,
				SoundVolume = 10,
				UseBoomerangMath = false,
				Boomerang = 0,
				SizeBoomerang = 50
			})
		elseif Mode == 9 then
		wait(0.5)
		TEffect2(
			MAINRUINCOLOR,
			root.CFrame*CFrame.new(0,-3,0), -- CFrame Start
			root.CFrame*CFrame.new(0,-3,0), -- CFrame End
			0.001, -- Start Size X
			3, -- Start Size Y
			0.001, -- Start Size Z
			140, -- End Size X
			3, -- End Size Y
			140, -- End Size Z
			0, -- Start Transparency
			1, -- End Transparency
			40, -- Rad Spin Thing
			false, -- FFF
			"Brick", -- Mesh
			"", -- Feather Spin Thing
			true, -- Transparency Type
			math.random(10,20)/10, -- Tween Time
			"Quad", -- EasingStyle
			"Out", -- EasingDirection
			math.random(10,20)/10 -- TweenTime v2
		)
		wait(0.5)
		TEffect2(
			MAINRUINCOLOR,
			root.CFrame*CFrame.new(0,-3,0), -- CFrame Start
			root.CFrame*CFrame.new(0,-3,0), -- CFrame End
			0.001, -- Start Size X
			3, -- Start Size Y
			0.001, -- Start Size Z
			140, -- End Size X
			3, -- End Size Y
			140, -- End Size Z
			0, -- Start Transparency
			1, -- End Transparency
			40, -- Rad Spin Thing
			false, -- FFF
			"Brick", -- Mesh
			"", -- Feather Spin Thing
			true, -- Transparency Type
			math.random(10,20)/10, -- Tween Time
			"Quad", -- EasingStyle
			"Out", -- EasingDirection
			math.random(10,20)/10 -- TweenTime v2
		)
		TEffect2(
			MAINRUINCOLOR,
			root.CFrame*CFrame.new(0,-3,0), -- CFrame Start
			root.CFrame*CFrame.new(0,-3,0), -- CFrame End
			0.001, -- Start Size X
			3, -- Start Size Y
			0.001, -- Start Size Z
			10, -- End Size X
			3, -- End Size Y
			10, -- End Size Z
			0, -- Start Transparency
			1, -- End Transparency
			40, -- Rad Spin Thing
			false, -- FFF
			"Brick", -- Mesh
			"", -- Feather Spin Thing
			true, -- Transparency Type
			math.random(10,20)/10, -- Tween Time
			"Quad", -- EasingStyle
			"Out", -- EasingDirection
			math.random(10,20)/10, -- TweenTime v2
			"" --meshdie
		)
	end
end
end
end))

coroutine.resume(coroutine.create(function()
while true do
swait()
hitfloor,posfloor=rayCast(RootPart.Position,(CFrame.new(RootPart.Position,RootPart.Position - Vector3.new(0,1,0))).lookVector,4,Character)
if hitfloor ~= nil then -- Effectz 3 (Slashes, etc)
	if Mode == 2 then
		swait(2)
WACKYEFFECT({Time = MRANDOM(10,30),EffectType = "Round Slash", Size = VT(0,0,0), Size2 = VT(0.3+.01 * COS(SINE / 42.6),0,0.3+.01 * COS(SINE / 42.6)), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-3,0)*ANGLES(RAD(MRANDOM(-2.5,2.5)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-2.5,2.5))), MoveToPos = nil, RotationX = 0, RotationY = MRANDOM(-1000/1000,1000/1000), RotationZ = 0, Material = "Neon", Color = MAINRUINCOLOR2, SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
	end
end
end
end))


hum.Died:Connect(function()
if BarrierEnabled == true then
hum.Parent = nil
for i,v in pairs(Refit:GetChildren())do
v.Enabled = true
v.Color = ColorSequence.new(MAINRUINCOLOR)
spawn(function()
	wait(2)
v.Enabled = false
end)
end
	shardEffect(char.Torso.CFrame * CFrame.new(0, -0.5, 0), 255, 0, 0)
	shardEffect(char.Torso.CFrame * CFrame.new(0, -0.5, 0), 255, 0, 0)
CFuncs["Sound"].Create("rbxassetid://2978605361", root, 10, 1)
CFuncs["Sound"].Create("rbxassetid://747105289", root, 10, 1)
for i = 0,20 do
sphere2(5,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(3,3,3),-0.03,15,-0.03,MAINRUINCOLOR)
end

spawn(function()
Gui.Stats.Barrier.Text = "0"
BarrierEnabled=false
end)
elseif BarrierEnabled == false then
	Gui.Stats.Health.Text = "0/8000"
for i,v in pairs(workspace.Terrain:GetChildren())do
v:Destroy()
end
kan:Stop()
CFuncs["Sound"].Create("rbxassetid://2613355772", root, 10, 1)
hum.BreakJointsOnDeath = true
dmgnr(Character)
end	
end)


local sng = nil
local anid = nil
local mps = game:GetService("MarketplaceService")
local scrg = Instance.new("ScreenGui",plr.PlayerGui)
scrg.Name = "who"
function bit(live)
	local siz = math.random(5,15)
	local frm = Instance.new("Frame",scrg)
	frm.Size = UDim2.new(0,siz,0,siz)
	frm.BackgroundTransparency = 0
	frm.BorderSizePixel = 0
	frm.Rotation = math.random(-360,360)
	frm.Position = UDim2.new(math.random(1,100)/100,0,1,0)
	local val = 0.025
	coroutine.resume(coroutine.create(function()
	for i = 0, 24/live do
		swait()
		frm.BackgroundColor3 = MAINRUINCOLOR2
		val = val - 0.001*live
		frm.Rotation = frm.Rotation + 5
		frm.BackgroundTransparency = frm.BackgroundTransparency + 0.04*live
		frm.Position = frm.Position - UDim2.new(0,0,val,0)
	end
	frm:Destroy()
	end))
end
local glw2 = Instance.new("ImageLabel",scrg)
glw2.BackgroundTransparency = 1
glw2.BackgroundColor3 = Color3.new(0,0,0)
glw2.Image = "rbxassetid://2288875354"
glw2.Size = UDim2.new(1,0,0.25,0)
glw2.ImageColor3 = MAINRUINCOLOR2
glw2.ImageTransparency = 0.75
glw2.Position = UDim2.new(0,0,0.75,0)

plr.Chatted:connect(function(message)
if string.sub(message,1,3) == "!bd" then
hum.Health = 0
elseif string.sub(message,1,3) == "!td" then
hum.Health = 0
wait(0.6)
hum.Health = 0
end
end)

function clonebutfadeout(par)

end


-- fuck you reset character
hum.BreakJointsOnDeath = false

hum.WalkSpeed = storehumanoidWS 
Humanoid.Name = plr.Name
Humanoid.MaxHealth = DefenceHealthMax
Humanoid.Health = DefenceHealth
hum2.Name = plr.Name
hum2.MaxHealth = DefenceHealthMax
hum2.Health = DefenceHealth
rval = 0
rval2 = 0
local rotperm = 0
idleanim=.4
while true do
		bit(math.random(8,15)/10)
if mutedtog == false then
kan.Volume = ORVOL
elseif mutedtog == true then
kan.Volume = 0
end
kan.PlaybackSpeed = ORPIT
kan.Pitch = ORPIT
kan.Looped = true
kan.Parent = char
CameraManager()
swait()
if BarrierEnabled == true then
DefenceHealthMax = hum.MaxHealth
DefenceHealth = hum.Health
else
DefenceHealth = 0
end
if not hum then
if BarrierEnabled == true then
hum = hum2
hum.Parent = char
Humanoid = hum
end
end
haloweld.C0=clerp(haloweld.C0,cf(0,0,0)*angles(math.rad(0 - 4 * math.cos(sine/32)),math.rad(0),math.rad(0 - 4 * math.sin(sine/32))),.3)
modet.Position = UDim2.new(0,0,0,0)
modet.Rotation = -5 * math.cos(sine / 32)
fx1.Rotation = fx1.Rotation + 8
fx2.Rotation = fx2.Rotation + 8
glw2.ImageColor3 = MAINRUINCOLOR2
	Gui.Stats.Position = UDim2.new(0.25 + 0.1 * math.cos(sine/60),0,0.893 + 0.02 * math.sin(sine/60),0)
Gui.Ring.Rotation = Gui.Ring.Rotation + 2
Gui.Ring2.Rotation = Gui.Ring2.Rotation - 3
Gui.Ring3.Rotation = Gui.Ring3.Rotation - 1.5
Gui.Ring4.Rotation = Gui.Ring4.Rotation + 1
Gui.TopBar.BackgroundColor3 = Color3.new(0,0,0)
Gui.BottomBar.BackgroundColor3 = Color3.new(0,0,0)
musica = Gui:FindFirstChild("Musiccc")
if musicactive == false then
musica:TweenPosition(UDim2.new(0.35 + 0.07 * math.cos(sine/45),0,0.019 + 0.03 * math.sin(sine/39),0),Enum.EasingDirection.Out,Enum.EasingStyle.Back,3,true)
end
Cresc.Mesh.Scale = Vector3.new(15 + 3 * math.cos(sine/45),1,15 + 3 * math.cos(sine/45))
Cresc.Ces.Mesh.Scale = Vector3.new(-15 - 3 * math.cos(sine/45),1,15 + 3 * math.cos(sine/45))
Beamring(Cresc.Decal.Color3,Cresc.CFrame,0.2,0,5,348103573)
clonebutfadeout(Cresc)
CresWeld.C1=clerp(CresWeld.C1,cf(0,0,0)*cf(0,0+3*math.cos(sine/18),0)*angles(0,math.rad(sine*12),0),.3)
		--	sphereMKn(math.random(4,8),math.random(2,8)/100,"Add",rarm.CFrame*CFrame.new(math.random(-6,6)/10,-0.5 + math.random(-10,10)/10,math.random(-6,6)/10)*CFrame.Angles(math.rad(90 + math.random(-15,15)),math.rad(math.random(-15,15)),math.rad(math.random(-15,15))),1,1,1,-0.01,BrickColor.new("Really red").Color,0,1)
	--		sphereMKn(math.random(4,8),math.random(2,8)/100,"Add",larm.CFrame*CFrame.new(math.random(-6,6)/10,-0.5 + math.random(-10,10)/10,math.random(-6,6)/10)*CFrame.Angles(math.rad(90 + math.random(-15,15)),math.rad(math.random(-15,15)),math.rad(math.random(-15,15))),1,1,1,-0.01,BrickColor.new("Really red").Color,0,1)
--trailMK(math.random(4,6),math.random(1,500)/1000,"Add",root.CFrame*CFrame.Angles(0,math.rad(0),0)*CFrame.new(math.random(-15,15),-3,math.random(-15,15))*CFrame.Angles(math.rad(90 + math.random(-6,6)),math.rad(math.random(-6,6)),math.rad(math.random(-6,6))),1,-0.0025,BrickColor.new("Really red").Color,0)
if openingo == true then
elseif openingo == false then
	--Humanoid.CameraOffset = (RootPart.CFrame:toObjectSpace(Head.CFrame)).p - Vector3.new(0, 1.25, 0)
end
imgca.Rotation = imgca.Rotation + 1
hitfloor,posfloor=rayCast(RootPart.Position,(CFrame.new(RootPart.Position,RootPart.Position - Vector3.new(0,1,0))).lookVector,4,Character)
local torvel=(RootPart.Velocity*Vector3.new(1,0,1)).magnitude 
local velderp=RootPart.Velocity.y
if openingo == false then
if Mode == 1 then
rval = rval + 3
handleweld.C0=clerp(handleweld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.03)
rotweld.C0=clerp(rotweld.C0,CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))*cf(0,0,2),.03)
lwing1weld.C1=clerp(lwing1weld.C1,cf(0,2.5,0 + 0.2 * math.cos(sine / 20))*angles(math.rad(0 - 5 * math.cos(sine / 20)),math.rad(0),math.rad(90 + rval)),.03)
lwing2weld.C1=clerp(lwing2weld.C1,cf(0,2.5,0 + 0.2 * math.cos(sine / 20))*angles(math.rad(0 - 5 * math.cos(sine / 20)),math.rad(0),math.rad(-147.5 + rval)),.03)
lwing3weld.C1=clerp(lwing3weld.C1,cf(0,2.5,0 + 0.2 * math.cos(sine / 20))*angles(math.rad(0 - 5 * math.cos(sine / 20)),math.rad(0),math.rad(-32.5 + rval)),.03)
rwing1weld.C1=clerp(rwing1weld.C1,cf(0,2.5,0 - 0.2 * math.cos(sine / 20))*angles(math.rad(0 + 5 * math.cos(sine / 20)),math.rad(0),math.rad(-90 - rval)),.03)
rwing2weld.C1=clerp(rwing2weld.C1,cf(0,2.5,0 - 0.2 * math.cos(sine / 20))*angles(math.rad(0 + 5 * math.cos(sine / 20)),math.rad(0),math.rad(147.5 - rval)),.03)
rwing3weld.C1=clerp(rwing3weld.C1,cf(0,2.5,0 - 0.2 * math.cos(sine / 20))*angles(math.rad(0 + 5 * math.cos(sine / 20)),math.rad(0),math.rad(32.5 - rval)),.03)
elseif Mode == 2 then
handleweld.C0=clerp(handleweld.C0,cf(0,2.3 - .6 * math.cos(sine/45),-0.4)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
rotweld.C0=clerp(rotweld.C0,cf(0,2.3 - .6 * math.cos(sine/45),1)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
lwing1weld.C1=clerp(lwing1weld.C1,cf(0,1.85 + 0.15 * math.cos(sine / 36),0)*angles(math.rad(0 + 2 * math.cos(sine / 45)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(90 - 30 * math.cos(sine / 45))),.3)
lwing2weld.C1=clerp(lwing2weld.C1,cf(0,1.85 + 0.15 * math.cos(sine / 38),0)*angles(math.rad(0 + 2 * math.cos(sine / 45)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(130 - 30 * math.cos(sine / 45))),.3)
lwing3weld.C1=clerp(lwing3weld.C1,cf(0,1.85 + 0.15 * math.cos(sine / 41),0)*angles(math.rad(0 + 2 * math.cos(sine / 45)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(50 - 30 * math.cos(sine / 45))),.3)
rwing1weld.C1=clerp(rwing1weld.C1,cf(0,1.85 + 0.15 * math.cos(sine / 36),0)*angles(math.rad(0 + 2 * math.cos(sine / 45)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(-90 + 30 * math.cos(sine / 45))),.3)
rwing2weld.C1=clerp(rwing2weld.C1,cf(0,1.85 + 0.15 * math.cos(sine / 38),0)*angles(math.rad(0 + 2 * math.cos(sine / 45)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(-130 + 30 * math.cos(sine / 45))),.3)
rwing3weld.C1=clerp(rwing3weld.C1,cf(0,1.85 + 0.15 * math.cos(sine / 41),0)*angles(math.rad(0 + 2 * math.cos(sine / 45)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(-50 + 30 * math.cos(sine / 45))),.3)
elseif Mode == 3 then
handleweld.C0=clerp(handleweld.C0,cf(0,1.6,-0.4)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
rotweld.C0=clerp(rotweld.C0,cf(0,1.6,1)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
lwing1weld.C1=clerp(lwing1weld.C1,cf(0,1.85 + 0.15 * math.cos(sine / 36),0)*angles(math.rad(0 + 25 * math.cos(sine / 45)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(90 + 5 * math.cos(sine / 56))),.3)
lwing2weld.C1=clerp(lwing2weld.C1,cf(0,1.85 + 0.15 * math.cos(sine / 38),0)*angles(math.rad(0 + 25 * math.cos(sine / 45)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(130 + 5 * math.cos(sine / 56))),.3)
lwing3weld.C1=clerp(lwing3weld.C1,cf(0,1.85 + 0.15 * math.cos(sine / 41),0)*angles(math.rad(0 + 25 * math.cos(sine / 45)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(50 + 5 * math.cos(sine / 56))),.3)
rwing1weld.C1=clerp(rwing1weld.C1,cf(0,1.85 + 0.15 * math.cos(sine / 36),0)*angles(math.rad(0 + 25 * math.cos(sine / 45)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(-90 - 5 * math.cos(sine / 56))),.3)
rwing2weld.C1=clerp(rwing2weld.C1,cf(0,1.85 + 0.15 * math.cos(sine / 38),0)*angles(math.rad(0 + 25 * math.cos(sine / 45)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(-130 - 5 * math.cos(sine / 56))),.3)
rwing3weld.C1=clerp(rwing3weld.C1,cf(0,1.85 + 0.15 * math.cos(sine / 41),0)*angles(math.rad(0 + 25 * math.cos(sine / 45)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(-50 - 5 * math.cos(sine / 56))),.3)
elseif Mode == 4 then
handleweld.C0=clerp(handleweld.C0,cf(0 - .6 * math.cos(sine/50),1 - .6 * math.cos(sine/45),4.4 - .4 * math.cos(sine/55))*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
rotweld.C0=clerp(rotweld.C0,cf(0 - .6 * math.cos(sine/50),1.5 - .6 * math.cos(sine/45),1 - .4 * math.cos(sine/55))*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
lwing1weld.C1=clerp(lwing1weld.C1,cf(0,3.85 + 0.15 * math.cos(sine / 36),5)*angles(math.rad(0 + 20 * math.cos(sine / 40)),math.rad(0 - 5 * math.cos(sine / 36)),math.rad(110)),.3)
lwing2weld.C1=clerp(lwing2weld.C1,cf(0,3.85 + 0.15 * math.cos(sine / 38),5)*angles(math.rad(0 + 20 * math.cos(sine / 40)),math.rad(0 - 5 * math.cos(sine / 37)),math.rad(90)),.3)
lwing3weld.C1=clerp(lwing3weld.C1,cf(0,3.85 + 0.15 * math.cos(sine / 41),5)*angles(math.rad(0 + 20 * math.cos(sine / 40)),math.rad(0 - 5 * math.cos(sine / 51)),math.rad(70)),.3)
rwing1weld.C1=clerp(rwing1weld.C1,cf(0,3.85 + 0.15 * math.cos(sine / 36),5)*angles(math.rad(0 + 20 * math.cos(sine / 40)),math.rad(0 - 5 * math.cos(sine / 36)),math.rad(-110)),.3)
rwing2weld.C1=clerp(rwing2weld.C1,cf(0,3.85 + 0.15 * math.cos(sine / 38),5)*angles(math.rad(0 + 20 * math.cos(sine / 40)),math.rad(0 - 5 * math.cos(sine / 37)),math.rad(-90)),.3)
rwing3weld.C1=clerp(rwing3weld.C1,cf(0,3.85 + 0.15 * math.cos(sine / 41),5)*angles(math.rad(0 + 20 * math.cos(sine / 40)),math.rad(0 - 5 * math.cos(sine / 51)),math.rad(-70)),.3)
elseif Mode == 5 then
handleweld.C0=clerp(handleweld.C0,cf(0,0,-0.4)*angles(math.rad(0),math.rad(0),math.rad(0)),.05)
rotweld.C0=clerp(rotweld.C0,CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))*cf(0,0,2),.3)
lwing1weld.C1=clerp(lwing1weld.C1,cf(0,1.85 - 0.4 * math.sin(sine / 32),0)*angles(math.rad(0 + 2 * math.cos(sine / 32)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(90 - 0 * math.cos(sine / 32))),.05)
lwing2weld.C1=clerp(lwing2weld.C1,cf(0,1.85 + 0.6 * math.sin(sine / 32),0)*angles(math.rad(0 + 2 * math.cos(sine / 32)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(130 + 15 * math.cos(sine / 32))),.05)
lwing3weld.C1=clerp(lwing3weld.C1,cf(0,1.85 + 0.6 * math.sin(sine / 32),0)*angles(math.rad(0 + 2 * math.cos(sine / 32)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(50 - 15 * math.cos(sine / 32))),.05)
rwing1weld.C1=clerp(rwing1weld.C1,cf(0,1.85 - 0.4 * math.sin(sine / 32),0)*angles(math.rad(0 + 2 * math.cos(sine / 32)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(-90 + 0 * math.cos(sine / 32))),.05)
rwing2weld.C1=clerp(rwing2weld.C1,cf(0,1.85 + 0.6 * math.sin(sine / 32),0)*angles(math.rad(0 + 2 * math.cos(sine / 32)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(-130 - 15 * math.cos(sine / 32))),.05)
rwing3weld.C1=clerp(rwing3weld.C1,cf(0,1.85 + 0.6 * math.sin(sine / 32),0)*angles(math.rad(0 + 2 * math.cos(sine / 32)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(-50 + 15 * math.cos(sine / 32))),.05)
elseif Mode == 6 then
	rval = rval + 3
handleweld.C0=clerp(handleweld.C0,cf(0 - .6 * math.cos(sine/50),1 - .6 * math.cos(sine/45),4.4 - .4 * math.cos(sine/55))*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
rotweld.C0=clerp(rotweld.C0,cf(0 - .6 * math.cos(sine/50),1.5 - .6 * math.cos(sine/45),1 - .4 * math.cos(sine/55))*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
lwing1weld.C1=clerp(lwing1weld.C1,angles(0,0,math.rad(90 + rval))*cf(0,3.85 + 0.15 * math.cos(sine / 36),5)*angles(math.rad(0 + 20 * math.cos(sine / 40)),math.rad(0),math.rad(0+rval)),.3)
lwing2weld.C1=clerp(lwing2weld.C1,angles(0,0,math.rad(90 + rval))*cf(0,3.85 + 0.15 * math.cos(sine / 38),5)*angles(math.rad(0 + 20 * math.cos(sine / 40)),math.rad(0),math.rad(90+rval)),.3)
lwing3weld.C1=clerp(lwing3weld.C1,angles(0,0,math.rad(90 + rval))*cf(0,3.85 + 0.15 * math.cos(sine / 41),5)*angles(math.rad(0 + 20 * math.cos(sine / 40)),math.rad(0),math.rad(180+rval)),.3)
rwing1weld.C1=clerp(rwing1weld.C1,angles(0,0,math.rad(90 + rval))*cf(0,3.85 + 0.15 * math.cos(sine / 36),5)*angles(math.rad(0 + 20 * math.cos(sine / 40)),math.rad(0),math.rad(270+rval)),.3)
rwing2weld.C1=clerp(rwing2weld.C1,cf(0,-3,5)*angles(math.rad(0),math.rad(0),math.rad(0+rval)),.3)
rwing3weld.C1=clerp(rwing3weld.C1,cf(0,-3,5)*angles(math.rad(0),math.rad(0),math.rad(90+rval)),.3)
elseif Mode == 69 or Mode == 9 then
handleweld.C0=clerp(handleweld.C0,cf(0 - .6 * math.cos(sine/50),1 - .6 * math.cos(sine/45),4.4 - .4 * math.cos(sine/55))*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
rotweld.C0=clerp(rotweld.C0,cf(0 - .6 * math.cos(sine/50),1.5 - .6 * math.cos(sine/45),1 - .4 * math.cos(sine/55))*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
lwing1weld.C1=clerp(lwing1weld.C1,cf(0,1.5,5)*angles(math.rad(0),math.rad(0),math.rad(130-20*math.cos(sine/18))),.3)
lwing2weld.C1=clerp(lwing2weld.C1,cf(0,1.5,5)*angles(math.rad(0),math.rad(0),math.rad(110-30*math.cos(sine/18))),.3)
lwing3weld.C1=clerp(lwing3weld.C1,cf(0,1.5,5)*angles(math.rad(0),math.rad(0),math.rad(90-40*math.cos(sine/18))),.3)
rwing1weld.C1=clerp(rwing1weld.C1,cf(0,1.5,5)*angles(math.rad(0),math.rad(0),math.rad(-130+20*math.cos(sine/18))),.3)
rwing2weld.C1=clerp(rwing2weld.C1,cf(0,1.5,5)*angles(math.rad(0),math.rad(0),math.rad(-110+30*math.cos(sine/18))),.3)
rwing3weld.C1=clerp(rwing3weld.C1,cf(0,1.5,5)*angles(math.rad(0),math.rad(0),math.rad(-90+40*math.cos(sine/18))),.3)
elseif Mode == 7 or Mode == 8 then
handleweld.C0=clerp(handleweld.C0,cf(0 - .6 * math.cos(sine/50),1 - .6 * math.cos(sine/45),4.4 - .4 * math.cos(sine/55))*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
rotweld.C0=clerp(rotweld.C0,cf(0 - .6 * math.cos(sine/50),1.5 - .6 * math.cos(sine/45),1 - .4 * math.cos(sine/55))*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
lwing1weld.C1=clerp(lwing1weld.C1,cf(0,1.5,5)*angles(math.rad(0),math.rad(0),math.rad(130-20*math.cos(sine/42))),.3)
lwing2weld.C1=clerp(lwing2weld.C1,cf(0,1.5,5)*angles(math.rad(0),math.rad(0),math.rad(110-30*math.cos(sine/42))),.3)
lwing3weld.C1=clerp(lwing3weld.C1,cf(0,1.5,5)*angles(math.rad(0),math.rad(0),math.rad(90-40*math.cos(sine/42))),.3)
rwing1weld.C1=clerp(rwing1weld.C1,cf(0,1.5,5)*angles(math.rad(0),math.rad(0),math.rad(-130+20*math.cos(sine/42))),.3)
rwing2weld.C1=clerp(rwing2weld.C1,cf(0,1.5,5)*angles(math.rad(0),math.rad(0),math.rad(-110+30*math.cos(sine/42))),.3)
rwing3weld.C1=clerp(rwing3weld.C1,cf(0,1.5,5)*angles(math.rad(0),math.rad(0),math.rad(-90+40*math.cos(sine/42))),.3)
elseif Mode == 10 then
handleweld.C0=clerp(handleweld.C0,cf(0,2.3 - .6 * math.cos(sine/45),-0.4)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
rotweld.C0=clerp(rotweld.C0,cf(0,2.3 - .6 * math.cos(sine/45),1)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
lwing1weld.C1=clerp(lwing1weld.C1,cf(0,1.85 + 0.15 * math.cos(sine / 36),0)*angles(math.rad(0 + 2 * math.cos(sine / 45)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(90 - 30 * math.cos(sine / 18))),.3)
lwing2weld.C1=clerp(lwing2weld.C1,cf(0,1.85 + 0.15 * math.cos(sine / 38),0)*angles(math.rad(0 + 2 * math.cos(sine / 45)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(130 - 30 * math.cos(sine / 18))),.3)
lwing3weld.C1=clerp(lwing3weld.C1,cf(0,1.85 + 0.15 * math.cos(sine / 41),0)*angles(math.rad(0 + 2 * math.cos(sine / 45)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(50 - 30 * math.cos(sine / 18))),.3)
rwing1weld.C1=clerp(rwing1weld.C1,cf(0,1.85 + 0.15 * math.cos(sine / 36),0)*angles(math.rad(0 + 2 * math.cos(sine / 45)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(-90 + 30 * math.cos(sine / 18))),.3)
rwing2weld.C1=clerp(rwing2weld.C1,cf(0,1.85 + 0.15 * math.cos(sine / 38),0)*angles(math.rad(0 + 2 * math.cos(sine / 45)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(-130 + 30 * math.cos(sine / 18))),.3)
rwing3weld.C1=clerp(rwing3weld.C1,cf(0,1.85 + 0.15 * math.cos(sine / 41),0)*angles(math.rad(0 + 2 * math.cos(sine / 45)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(-50 + 30 * math.cos(sine / 18))),.3)
elseif Mode == 11 then
handleweld.C0=clerp(handleweld.C0,cf(0,2.3 - .6 * math.cos(sine/45),-0.4)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
rotweld.C0=clerp(rotweld.C0,cf(0,2.3 - .6 * math.cos(sine/45),1)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
lwing1weld.C1=clerp(lwing1weld.C1,angles(math.rad(0 + 2 * math.cos(sine / 45)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(90+math.random(-360,360)))*cf(3,1.85 + 0.15 * math.cos(sine / 36),0+math.random(-10,10)/20)*angles(math.rad(0 + 2 * math.cos(sine / 45)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(90+math.random(-360,360))),.3)
lwing2weld.C1=clerp(lwing2weld.C1,angles(math.rad(0 + 2 * math.cos(sine / 45)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(90+math.random(-360,360)))*cf(3,1.85 + 0.15 * math.cos(sine / 38),0+math.random(-10,10)/20)*angles(math.rad(0 + 2 * math.cos(sine / 45)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(130+math.random(-360,360))),.3)
lwing3weld.C1=clerp(lwing3weld.C1,angles(math.rad(0 + 2 * math.cos(sine / 45)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(90+math.random(-360,360)))*cf(3,1.85 + 0.15 * math.cos(sine / 41),0+math.random(-10,10)/20)*angles(math.rad(0 + 2 * math.cos(sine / 45)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(50+math.random(-360,360))),.3)
rwing1weld.C1=clerp(rwing1weld.C1,angles(math.rad(0 + 2 * math.cos(sine / 45)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(90+math.random(-360,360)))*cf(3,1.85 + 0.15 * math.cos(sine / 36),0+math.random(-10,10)/20)*angles(math.rad(0 + 2 * math.cos(sine / 45)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(-90+math.random(-360,360))),.3)
rwing2weld.C1=clerp(rwing2weld.C1,angles(math.rad(0 + 2 * math.cos(sine / 45)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(90+math.random(-360,360)))*cf(3,1.85 + 0.15 * math.cos(sine / 38),0+math.random(-10,10)/20)*angles(math.rad(0 + 2 * math.cos(sine / 45)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(-130+math.random(-360,360))),.3)
rwing3weld.C1=clerp(rwing3weld.C1,angles(math.rad(0 + 2 * math.cos(sine / 45)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(90+math.random(-360,360)))*cf(3,1.85 + 0.15 * math.cos(sine / 41),0+math.random(-10,10)/20)*angles(math.rad(0 + 2 * math.cos(sine / 45)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(-50+math.random(-360,360))),.3)
elseif Mode == 469 then
handleweld.C0=clerp(handleweld.C0,cf(0,0,-0.4)*angles(math.rad(0),math.rad(0),math.rad(0)),.05)
rotweld.C0=clerp(rotweld.C0,CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))*cf(0,0,2),.3)
lwing1weld.C1=clerp(lwing1weld.C1,cf(0,1.85 - 0.4 * math.sin(sine / 32),0)*angles(math.rad(0 + 2 * math.cos(sine / 32)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(90+sine*4)),.05)
lwing2weld.C1=clerp(lwing2weld.C1,cf(0,1.85 + 0.6 * math.sin(sine / 32),0)*angles(math.rad(0 + 2 * math.cos(sine / 32)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(150+sine*4)),.05)
lwing3weld.C1=clerp(lwing3weld.C1,cf(0,1.85 + 0.6 * math.sin(sine / 32),0)*angles(math.rad(0 + 2 * math.cos(sine / 32)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(30+sine*4)),.05)
rwing1weld.C1=clerp(rwing1weld.C1,cf(0,1.85 - 0.4 * math.sin(sine / 32),0)*angles(math.rad(0 + 2 * math.cos(sine / 32)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(-90+sine*4)),.05)
rwing2weld.C1=clerp(rwing2weld.C1,cf(0,1.85 + 0.6 * math.sin(sine / 32),0)*angles(math.rad(0 + 2 * math.cos(sine / 32)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(-150+sine*4)),.05)
rwing3weld.C1=clerp(rwing3weld.C1,cf(0,1.85 + 0.6 * math.sin(sine / 32),0)*angles(math.rad(0 + 2 * math.cos(sine / 32)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(-30+sine*4)),.05)
end
end
--bguis.Size = UDim2.new(15 + 3 * math.cos(sine/32), 0, 15 + 3 * math.cos(sine/32), 0)
--block2(7,math.random(1,10)/45,"Add",root.CFrame*CFrame.new(math.random(-25,25),-10,math.random(-25,25))*CFrame.Angles(math.rad(90),math.rad(0),math.rad(0)),0.75,0.75,kan.PlaybackLoudness/40,-0.0075,MAINRUINCOLOR,0)
--shard1(2,0.25,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),0,2,2,0,BrickColor.new("Really red"),2)

if BarrierEnabled == true then
Gui.Stats.Barrier.Text = hum.Health.. "/".. hum.MaxHealth
elseif BarrierEnabled == false then
	Gui.Stats.Health.Text = hum.Health.. "/".. hum.MaxHealth
end
cp = kan.SoundId:gsub("rbxassetid://","")
if hum.MaxHealth > 99999 then
Gui.Stats.Health.TextSize = 13
Gui.Stats.Barrier.TextSize = 13
end
Gui.Stats.Attack.Text = "x".. attackmultiplier
Gui.Stats.Level.Text = level
bilguit.StudsOffset = Vector3.new(0 + 0.6 * math.cos(sine/28),5 + 0.6 * math.sin(sine/32),0)
 sine = sine + change
if barrier1 >= 16 then
sine1= sine1 + change
barrier1 = 16
else
barrier1 = barrier1 + 1
end
if barrier2 >= 32 then
sine2 = sine2 + change
barrier2 = 32
else
barrier2 = barrier2 + 1
end
if barrier3 >= 48 then
sine3 = sine3 + change
barrier3 = 48
else
barrier3 = barrier3 + 1
end
if levelnum >= 100 and level <= 100 then
level = level + 1
levelnum = 0
hum.MaxHealth = hum.MaxHealth + 2000
hum.Health = hum.MaxHealth
attackmultiplier = attackmultiplier + 1
spawn(function()
levelup()
end)
end
rval2 = rval2 + 2
for i,v in pairs(visu)do
	local mrad = math.random(1600,4000)
	local mrad2 = math.random(5000,7000)
	local norad = math.random(0,8)
v:TweenSize(UDim2.new((kan.PlaybackLoudness)/mrad*norad, 0, 0, 17), "Out", "Quart", 2,true)
v.Transparency = 0.9 -kan.PlaybackLoudness/mrad2*norad
end
if(Hue > 360)then Hue = 0 end
Hue = Hue + 1
ringgu.Ring1.Orientation = Vector3.new(rval,rval2,rval2)
ringgu.Ring2.Orientation = Vector3.new(rval,-rval,rval2)
ringgu.Ring3.Orientation = Vector3.new(rval2,rval2,-rval)
ringgu.Ring4.Orientation = Vector3.new(-rval2,-rval,rval)
spawn(function()
	swait()
if Mode == 1 then
RecolorThingQuiet(MAINRUINCOLOR,Color3.fromRGB(255/2 + 255/2 * math.cos(sine/10),0,0),MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,false,false)
MAINRUINCOLOR2 = Color3.fromRGB(255/2 + 255/2 * math.cos(sine/10),0,0)
elseif Mode == 7 then
	MAINRUINCOLOR = Color3.fromHSV((sine/360) - math.floor(sine/360),.55 + math.sin(sine/32)*0.3,1)
	MAINRUINCOLOR2 = Color3.fromHSV((sine/360) - math.floor(sine/360),.5 + math.sin(sine/46)*0.4,1)
	RecolorTextAndRename("MARIGOLD",MAINRUINCOLOR,MAINRUINCOLOR2,"Code")
RecolorThingQuiet(MAINRUINCOLOR,MAINRUINCOLOR2,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,false,false)
elseif Mode == 8 then
local radm = math.random(0,500)
if radm >= 460 then
	MAINRUINCOLOR = Color3.fromRGB(255,0,0)
	MAINRUINCOLOR2 = Color3.fromRGB(255/1.3,0,0)
	RecolorTextAndRename("恋煩いの",MAINRUINCOLOR,MAINRUINCOLOR2,"Antique")
RecolorThingQuiet(MAINRUINCOLOR,MAINRUINCOLOR2,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,false,false)
else
MAINRUINCOLOR = BrickColor.new("Pink").Color
MAINRUINCOLOR2 = BrickColor.new("Carnation pink").Color
RecolorTextAndRename("恋煩いの",MAINRUINCOLOR,MAINRUINCOLOR2,"Cartoon")
RecolorThingQuiet(MAINRUINCOLOR,MAINRUINCOLOR2,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,false,false)
end
elseif Mode == 11 then
MAINRUINCOLOR = BrickColor.new(twistedcolors[math.random(1,#twistedcolors)]).Color
MAINRUINCOLOR2 = BrickColor.new(twistedcolors[math.random(1,#twistedcolors)]).Color
RecolorTextAndRename(twistedtable[math.random(1,#twistedtable)],MAINRUINCOLOR,MAINRUINCOLOR2,"Code")
RecolorThingQuiet(BrickColor.new(twistedcolors[math.random(1,#twistedcolors)]).Color,BrickColor.new(twistedcolors[math.random(1,#twistedcolors)]).Color,BrickColor.new(twistedcolors[math.random(1,#twistedcolors)]).Color,BrickColor.new(twistedcolors[math.random(1,#twistedcolors)]).Color,BrickColor.new(twistedcolors[math.random(1,#twistedcolors)]).Color,1,BrickColor.new(twistedcolors[math.random(1,#twistedcolors)]).Color,1,BrickColor.new(twistedcolors[math.random(1,#twistedcolors)]).Color,false,false)

end
end)
if equipped==true or equipped==false then
if attack==false then
idle=idle+1
else
idle=0
end
if idle>=500 then
if attack==false then
--Sheath()
end
end
script.BRUH.CFrame = root.CFrame*CFrame.new(0,-3,0)
if Mode == 469 then
script.BRUH.Particle.Enabled = true
else
script.BRUH.Particle.Enabled = false
end
if armorexist == true then
mov = mov + 0.03
Har.Part.Texture.OffsetStudsU = mov
Har.Part.Color = MAINRUINCOLOR
Har.idiot2.Color = MAINRUINCOLOR
Har.Part.Texture.Color3 = MAINRUINCOLOR2
end
	--Footplanting code, no need to modify anything, variable is Vec.X,Y or Z
	local Walking = hum.MoveDirection.magnitude>0
	local FwdDir = (Walking and hum.MoveDirection*root.CFrame.lookVector or Vector3.new())
	local RigDir = (Walking and hum.MoveDirection*root.CFrame.rightVector or Vector3.new())
	local Vec = {
		X=RigDir.X+RigDir.Z,
		Z=FwdDir.X+FwdDir.Z
	};
	local Divide = 1
	if(Vec.Z<0)then
		Divide=math.clamp(-(1.25*Vec.Z),1,2)
	end
	Vec.Z = Vec.Z/Divide
	Vec.X = Vec.X/Divide
ringgu.CoreOrb2.Orientation = Vector3.new(0 + 24 * math.sin(sine / 15),0 - 35 * math.cos(sine / 17),0 + 24 * math.cos(sine / 18))
if RootPart.Velocity.y > 1 and hitfloor==nil then 
Anim="Jump"
TAnim(cam,{FieldOfView=80},0.3,"Quad","Out",0,false,0)
if attack==false then
  	local Alpha = .4
  	TweenAnimate(RootJoint,{C0=cf(0,0,0)*angles(math.rad(15-15*Vec.Z),math.rad(0),math.rad(0-15*Vec.X))*RootCF},Alpha,'Back','Out',0,false,0)
  	TweenAnimate(LH,{C0=cf(-1,-1,0)*angles(math.rad(-16.3),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0))},Alpha,'Back','Out',0,false,0)
  	TweenAnimate(RH,{C0=cf(1,-0.3,-0.8)*angles(math.rad(-29.1),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(90),math.rad(0))},Alpha,'Back','Out',0,false,0)
  	TweenAnimate(LW,{C0=cf(-1.5,0.6,0.1)*angles(math.rad(-14.8),math.rad(17.3),math.rad(-10.2))},Alpha,'Back','Out',0,false,0)
  	TweenAnimate(RW,{C0=cf(1.4,0.7,0.2)*angles(math.rad(-21.1),math.rad(-27.1),math.rad(9.1))},Alpha,'Back','Out',0,false,0)
  	TweenAnimate(Torso.Neck,{C0 =cf(0,0,-0.1)*angles(math.rad(7.7),math.rad(0),math.rad(0))*necko},Alpha,'Back','Out',0,false,0)
end
elseif RootPart.Velocity.y < -1 and hitfloor==nil then 
Anim="Fall"
TAnim(cam,{FieldOfView=100},0.3,"Quad","Out",0,false,0)
if attack==false then
  	local Alpha = .4
  	TweenAnimate(RootJoint,{C0=cf(0,0,0)*angles(math.rad(-18.2-15*Vec.Z),math.rad(0),math.rad(0-15*Vec.X))*RootCF},Alpha,'Back','Out',0,false,0)
  	TweenAnimate(LH,{C0=cf(-1,-1,0)*angles(math.rad(11),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0))},Alpha,'Back','Out',0,false,0)
  	TweenAnimate(RH,{C0=cf(1,-0.6,-1)*angles(math.rad(-48.9),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(90),math.rad(0))},Alpha,'Back','Out',0,false,0)
  	TweenAnimate(LW,{C0=cf(-1.5,0.6,0.1)*angles(math.rad(32.9),math.rad(4),math.rad(-19.6))},Alpha,'Back','Out',0,false,0)
  	TweenAnimate(RW,{C0=cf(1.4,0.7,0.2)*angles(math.rad(34.8),math.rad(-7.8),math.rad(27.4))},Alpha,'Back','Out',0,false,0)
  	TweenAnimate(Torso.Neck,{C0 =cf(0,0.1,0.4)*angles(math.rad(-25.1),math.rad(0),math.rad(0))*necko},Alpha,'Back','Out',0,false,0)
end
elseif torvel<1 and hitfloor~=nil then
Anim="Idle"
TAnim(cam,{FieldOfView=70},0.3,"Quad","Out",0,false,0)
if attack==false then
if Mode == 1 then
  	local Alpha = .1
  	TweenAnimate(RootJoint,{C0=cf(0,2.2 + 1 * math.cos(sine/45),0)*angles(math.rad(-16.7 - 7 * math.sin(sine/45)),math.rad(0),math.rad(0))*RootCF},Alpha,'Linear','Out',0,false,0)
  	TweenAnimate(LH,{C0=cf(-1,-1,0)*angles(math.rad(17 + 7 * math.sin(sine/45)),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0))},Alpha,'Linear','Out',0,false,0)
  	TweenAnimate(RH,{C0=cf(1,-0.1,-0.7)*angles(math.rad(-3.7 + 7 * math.sin(sine/45)),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(90),math.rad(0))},Alpha,'Linear','Out',0,false,0)
  	TweenAnimate(LW,{C0=cf(-1.5,0.7,-0.1)*angles(math.rad(16.8 + 3 * math.sin(sine/45)),math.rad(-18.9),math.rad(-15.4 + 7 * math.cos(sine/45)))},Alpha,'Linear','Out',0,false,0)
  	TweenAnimate(RW,{C0=cf(1.5,0.6,0.2)*angles(math.rad(26 + 3 * math.sin(sine/45)),math.rad(10),math.rad(20.3 - 7 * math.cos(sine/45)))},Alpha,'Linear','Out',0,false,0)
  	TweenAnimate(Torso.Neck,{C0 =cf(0,0,0.1)*angles(math.rad(-7.1),math.rad(0),math.rad(0))*necko},Alpha,'Linear','Out',0,false,0)
elseif Mode == 2 then
	  	local Alpha = .1
  	TweenAnimate(RootJoint,{C0=cf(-0.1- 0.5 * math.cos(sine/45),3 - 2 * math.cos(sine/45),-0.7 - 0.5 * math.sin(sine/45))*angles(math.rad(-27.6),math.rad(-32.9),math.rad(-0.7))*RootCF},Alpha,'Linear','Out',0,false,0)
  	TweenAnimate(LH,{C0=cf(-1,-1,-0.1)*angles(math.rad(-5- 9 * math.cos(sine/45)),math.rad(0.9),math.rad(-3.1))*angles(math.rad(0),math.rad(-90),math.rad(0))},Alpha,'Linear','Out',0,false,0)
  	TweenAnimate(RH,{C0=cf(0.8,-0.1,-0.3)*angles(math.rad(-1.7- 9 * math.cos(sine/45)),math.rad(-16.5),math.rad(-1.9))*angles(math.rad(0),math.rad(90),math.rad(0))},Alpha,'Linear','Out',0,false,0)
  	TweenAnimate(LW,{C0=cf(-0.8,0.6,-0.5)*angles(math.rad(114.8- 4 * math.cos(sine/52)),math.rad(0.4),math.rad(83.5))},Alpha,'Linear','Out',0,false,0)
  	TweenAnimate(RW,{C0=cf(1,0.6,-0.7)*angles(math.rad(108.5- 5 * math.cos(sine/54)),math.rad(3.1),math.rad(-80.9))},Alpha,'Linear','Out',0,false,0)
  	TweenAnimate(Torso.Neck,{C0 =cf(0,0,0.3)*angles(math.rad(-16.1),math.rad(-1.7),math.rad(-0.1))*necko},Alpha,'Linear','Out',0,false,0)
elseif Mode == 3 then
	  	local Alpha = .1
  	TweenAnimate(RootJoint,{C0=cf(0,0+0.1*math.cos(sine/45),0)*angles(math.rad(-13.4),math.rad(0),math.rad(0))*RootCF},Alpha,'Linear','Out',0,false,0)
  	TweenAnimate(LH,{C0=cf(-1,-1-0.1*math.cos(sine/45),0)*angles(math.rad(14.4),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0))},Alpha,'Linear','Out',0,false,0)
  	TweenAnimate(RH,{C0=cf(1,-1-0.1*math.cos(sine/45),0)*angles(math.rad(15.5),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(90),math.rad(0))},Alpha,'Linear','Out',0,false,0)
  	TweenAnimate(LW,{C0=cf(-0.9,0.5+0.2*math.sin(sine/45),0.1)*angles(math.rad(-11.4),math.rad(-22.8),math.rad(26.2))},Alpha,'Linear','Out',0,false,0)
  	TweenAnimate(RW,{C0=cf(1,0.5+0.2*math.sin(sine/45),0.1)*angles(math.rad(-12.3),math.rad(15.8),math.rad(-29.6))},Alpha,'Linear','Out',0,false,0)
  	TweenAnimate(Torso.Neck,{C0 =cf(0,0,0.3)*angles(math.rad(-17.6),math.rad(0+7*math.cos(sine/48)),math.rad(0))*necko},Alpha,'Linear','Out',0,false,0)
elseif Mode == 4 then
  	local Alpha = .1
  	TweenAnimate(RootJoint,{C0=cf(0,0 + 0.1 * math.cos(sine/28),0)*angles(math.rad(0),math.rad(19.8),math.rad(0))*RootCF},Alpha,'Linear','Out',0,false,0)
  	TweenAnimate(LH,{C0=cf(-1,-1 - 0.1 * math.cos(sine/28),0)*angles(math.rad(-13.2),math.rad(0),math.rad(-2.4))*angles(math.rad(0),math.rad(-90),math.rad(0))},Alpha,'Linear','Out',0,false,0)
  	TweenAnimate(RH,{C0=cf(1,-1 - 0.1 * math.cos(sine/28),0)*angles(math.rad(0),math.rad(-14.9),math.rad(0))*angles(math.rad(0),math.rad(90),math.rad(0))},Alpha,'Linear','Out',0,false,0)
  	TweenAnimate(LW,{C0=cf(-1.5,0.6 + 0.1 * math.sin(sine/28),0)*angles(math.rad(178.7),math.rad(0),math.rad(12.1))},Alpha,'Linear','Out',0,false,0)
  	TweenAnimate(RW,{C0=cf(1.5,0.6 + 0.1 * math.sin(sine/28),0.1)*angles(math.rad(0),math.rad(-8.5),math.rad(9.7 - 3 * math.cos(sine/28)))},Alpha,'Linear','Out',0,false,0)
  	TweenAnimate(Torso.Neck,{C0 =cf(0,0,0.1)*angles(math.rad(-6.3),math.rad(-17.2),math.rad(-1.9))*necko},Alpha,'Linear','Out',0,false,0)
elseif Mode == 5 then
  	local Alpha = .1
  	TweenAnimate(RootJoint,{C0=cf(0.2,2.5 - 0.9 * math.sin(sine/32),0)*angles(math.rad(-6.4 - 4 * math.cos(sine/45)),math.rad(43),math.rad(0))*RootCF},Alpha,'Linear','Out',0,false,0)
  	TweenAnimate(LH,{C0=cf(-0.9,-1.2,-0.1)*angles(math.rad(-16.2),math.rad(15.6),math.rad(4.5))*angles(math.rad(0),math.rad(-90),math.rad(0))},Alpha,'Linear','Out',0,false,0)
  	TweenAnimate(RH,{C0=cf(1.1,-0.3,0.1)*angles(math.rad(-53.2),math.rad(-60.9),math.rad(-39))*angles(math.rad(0),math.rad(90),math.rad(0))},Alpha,'Linear','Out',0,false,0)
  	TweenAnimate(LW,{C0=cf(-0.9,0.1 + 0.1 * math.cos(sine/32),-0.4)*angles(math.rad(91.9 + 7 * math.cos(sine/45)),math.rad(14.7 + 5 * math.sin(sine/45)),math.rad(60.3))},Alpha,'Linear','Out',0,false,0)
  	TweenAnimate(RW,{C0=cf(1.3,0.6 + 0.1 * math.cos(sine/32),-0.2)*angles(math.rad(85.9 + 7 * math.cos(sine/45)),math.rad(10.7 + 5 * math.sin(sine/45)),math.rad(-44.6))},Alpha,'Linear','Out',0,false,0)
  	TweenAnimate(Torso.Neck,{C0 =cf(0,0,0.3)*angles(math.rad(-18.3+ 3 * math.sin(sine/42)),math.rad(-43.1),math.rad(-0.1))*necko},Alpha,'Linear','Out',0,false,0)
elseif Mode == 6 then
  	local Alpha = .1
  	TweenAnimate(RootJoint,{C0=cf(0,1.2 + 0.6 * math.cos(sine/25),-0.1)*angles(math.rad(-41.6),math.rad(-23.6),math.rad(-4.3))*RootCF},Alpha,'Linear','Out',0,false,0)
  	TweenAnimate(LH,{C0=cf(-1,-1,0)*angles(math.rad(36.9),math.rad(22.8),math.rad(-9.6))*angles(math.rad(0),math.rad(-90),math.rad(0))},Alpha,'Linear','Out',0,false,0)
  	TweenAnimate(RH,{C0=cf(1,-0.6,-0.4)*angles(math.rad(42.3),math.rad(-3.7),math.rad(-5.7))*angles(math.rad(0),math.rad(90),math.rad(0))},Alpha,'Linear','Out',0,false,0)
  	TweenAnimate(LW,{C0=cf(-1.6,0.5 + 0.2 * math.sin(sine/25),-0.4)*angles(math.rad(53.8),math.rad(-11.3),math.rad(-19.8 + 10 * math.cos(sine/25)))},Alpha,'Linear','Out',0,false,0)
  	TweenAnimate(RW,{C0=cf(1.2,0.3 + 0.2 * math.sin(sine/25),-0.9)*angles(math.rad(61.6),math.rad(17.5),math.rad(-17.4 - 10 * math.cos(sine/25)))},Alpha,'Linear','Out',0,false,0)
  	TweenAnimate(Torso.Neck,{C0 =cf(0.1,0,0.2)*angles(math.rad(-14.3 + 4 * math.sin(sine/25)),math.rad(25.6),math.rad(5.2))*necko},Alpha,'Linear','Out',0,false,0)
elseif Mode == 69 then
  	local Alpha = .6
  	TweenAnimate(RootJoint,{C0=cf(0,0.8 + 0.4 * math.cos(sine/18),0)*angles(math.rad(13.2 + 7 * math.sin(sine/18)),math.rad(-30.1),math.rad(6.4))*RootCF},Alpha,'Quint','Out',0,false,0)
  	TweenAnimate(LH,{C0=cf(-1,-1,0)*angles(math.rad(-24-7*math.sin(sine/18)),math.rad(24),math.rad(-2.2))*angles(math.rad(0),math.rad(-90),math.rad(0))},Alpha,'Quint','Out',0,false,0)
  	TweenAnimate(RH,{C0=cf(0.9,-0.5,-0.9)*angles(math.rad(-14.1-7*math.sin(sine/18)),math.rad(-2.4),math.rad(10.8))*angles(math.rad(0),math.rad(90),math.rad(0))},Alpha,'Quint','Out',0,false,0)
  	TweenAnimate(LW,{C0=cf(-0.9,0.3,-0.4)*angles(math.rad(35),math.rad(9.4),math.rad(73))},Alpha,'Quint','Out',0,false,0)
  	TweenAnimate(RW,{C0=cf(1.2,0.1,0.1)*angles(math.rad(-19.9),math.rad(9.2),math.rad(-29.5))},Alpha,'Quint','Out',0,false,0)
  	TweenAnimate(Torso.Neck,{C0 =cf(0,0,0.3)*angles(math.rad(-18.7-7*math.sin(sine/18)),math.rad(40.5),math.rad(3.1))*necko},Alpha,'Quint','Out',0,false,0)
elseif Mode == 7 then
  	local Alpha = .3
  	TweenAnimate(RootJoint,{C0=cf(-0.1,1.1 + 1 * math.cos(sine/42),0.1)*angles(math.rad(-1.4 + 10 * math.sin(sine/52)),math.rad(3.2),math.rad(2.3 + 7 * math.sin(sine/48)))*RootCF},Alpha,'Quint','Out',0,false,0)
  	TweenAnimate(LH,{C0=cf(-0.9,-1,0)*angles(math.rad(3.4),math.rad(19.6),math.rad(-6.5))*angles(math.rad(0),math.rad(-90),math.rad(0))},Alpha,'Quint','Out',0,false,0)
  	TweenAnimate(RH,{C0=cf(0.9,-0.3,-0.4)*angles(math.rad(5.5),math.rad(-37.8),math.rad(10.3))*angles(math.rad(0),math.rad(90),math.rad(0))},Alpha,'Quint','Out',0,false,0)
  	TweenAnimate(LW,{C0=cf(-1.2,0.2 + .2 * math.sin(sine/42),0.3)*angles(math.rad(-34.7 + 7 * math.sin(sine/52)),math.rad(-22.1 + 8 * math.sin(sine/32)),math.rad(15.8))},Alpha,'Quint','Out',0,false,0)
  	TweenAnimate(RW,{C0=cf(1.4,0.2 + .2 * math.sin(sine/42),0.1)*angles(math.rad(-32.9 - 5 * math.cos(sine/32)),math.rad(16.2 - 7 * math.sin(sine/32)),math.rad(-4.5))},Alpha,'Quint','Out',0,false,0)
  	TweenAnimate(Torso.Neck,{C0 =cf(-0.1,0,0.2)*angles(math.rad(-11.8 - 5 * math.sin(sine/42)),math.rad(5.6),math.rad(-4.1))*necko},Alpha,'Quint','Out',0,false,0)
elseif Mode == 8 then
  	local Alpha,Easing,Direction,Repeat,Reverse,Delay = .6,'Quad','Out',0,false,0
  	TweenAnimate(RootJoint,{C0=cf(0,0.4 + 0.3 * math.cos(sine/52),-0.2)*angles(math.rad(-10),math.rad(0),math.rad(0))*RootCF},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(LH,{C0=cf(-1,-1,0)*angles(math.rad(0),math.rad(34),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(RH,{C0=cf(1.2,-0.8,-0.7)*angles(math.rad(-25.6),math.rad(-16.4),math.rad(-7.7))*angles(math.rad(0),math.rad(90),math.rad(0))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(LW,{C0=cf(-0.8,0.4 + 0.3 * math.sin(sine/52),-0.3)*angles(math.rad(33.2+7*math.sin(sine/52)),math.rad(5.1+4*math.cos(sine/32)),math.rad(11.8))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(RW,{C0=cf(0.9,0.4 + 0.3 * math.sin(sine/52),-0.4)*angles(math.rad(36.8+7*math.sin(sine/52)),math.rad(-9.3-4*math.cos(sine/32)),math.rad(-17.7))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(Torso.Neck,{C0 =necko*angles(math.rad(36.4+7*math.sin(sine/52)),math.rad(0),math.rad(0))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
elseif Mode == 9 then
  	local Alpha,Easing,Direction,Repeat,Reverse,Delay = .1,'Linear','Out',0,false,0
  	TweenAnimate(RootJoint,{C0=cf(0,0+0.2*math.cos(sine/18),0)*angles(math.rad(0),math.rad(35),math.rad(0))*RootCF},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(LH,{C0=cf(-1,-1-0.2*math.cos(sine/18),0)*angles(math.rad(0),math.rad(17.7),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(RH,{C0=cf(1,-1-0.2*math.cos(sine/18),0)*angles(math.rad(0),math.rad(-18.7),math.rad(0))*angles(math.rad(0),math.rad(90),math.rad(0))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(LW,{C0=cf(-0.5,0.4+0.1*math.sin(sine/18),-0.6)*angles(math.rad(17.8+5*math.cos(sine/32)),math.rad(0-6*math.sin(sine/26)),math.rad(82.3+7*math.sin(sine/45)))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(RW,{C0=cf(1.5,0.6+0.1*math.sin(sine/18),0)*angles(math.rad(6.3+5*math.cos(sine/35)),math.rad(-27.6-9*math.cos(sine/45)),math.rad(13.4+6*math.cos(sine/46)))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(Torso.Neck,{C0 =necko*angles(math.rad(7.3+2*math.sin(sine/18)),math.rad(13.4),math.rad(-27.6))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
elseif Mode == 10 then -- 1859929072
  	local Alpha,Easing,Direction,Repeat,Reverse,Delay = .1,'Linear','Out',0,false,0
  	TweenAnimate(RootJoint,{C0=cf(0,0+0.1*math.cos(sine/18),0)*angles(math.rad(0),math.rad(-46.1),math.rad(0))*RootCF},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(LH,{C0=cf(-1,-1-0.1*math.cos(sine/18),0)*angles(math.rad(7.4),math.rad(11.3),math.rad(-4.7))*angles(math.rad(0),math.rad(-90),math.rad(0))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(RH,{C0=cf(1,-1-0.1*math.cos(sine/18),0)*angles(math.rad(-6.3),math.rad(0.8),math.rad(2.6))*angles(math.rad(0),math.rad(90),math.rad(0))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(LW,{C0=cf(-1,-0.2+0.1*math.sin(sine/18),-0.2)*angles(math.rad(112.8 + 7 * math.cos(sine/32)),math.rad(45.1 + 4 * math.sin(sine/54)),math.rad(39.5 + 6 * math.sin(sine/29)))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(RW,{C0=cf(1.1,0.5+0.1*math.sin(sine/18),0.6)*angles(math.rad(-5.5 - 4 * math.sin(sine/42)),math.rad(6.7 - 5.5 * math.cos(sine/26)),math.rad(-19.1 - 8 * math.cos(sine/37)))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(Torso.Neck,{C0 =necko*angles(math.rad(20.1+5*math.sin(sine/18)),math.rad(19.2),math.rad(37.4))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
elseif Mode == 11 then
  	local Alpha,Easing,Direction,Repeat,Reverse,Delay = .1,'Linear','Out',0,false,0
  	TweenAnimate(RootJoint,{C0=cf(0,0.5+0.4*math.cos(sine/42),0)*angles(math.rad(33.4+math.random(-6,6)),math.rad(0+math.random(-6,6)),math.rad(0+math.random(-6,6)))*RootCF},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(LH,{C0=cf(-1,-1,0)*angles(math.rad(-27.2+math.random(-6,6)),math.rad(0+math.random(-6,6)),math.rad(0+math.random(-6,6)))*angles(math.rad(0+math.random(-6,6)),math.rad(-90+math.random(-6,6)),math.rad(0+math.random(-6,6)))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(RH,{C0=cf(1,-0.5,-1.1)*angles(math.rad(-31.9+math.random(-6,6)),math.rad(0+math.random(-6,6)),math.rad(0+math.random(-6,6)))*angles(math.rad(0+math.random(-6,6)),math.rad(90+math.random(-6,6)),math.rad(0+math.random(-6,6)))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(LW,{C0=cf(-1.4,0.7,0.2)*angles(math.rad(-34.1+math.random(-6,6)),math.rad(32.7+math.random(-6,6)),math.rad(-9.6+math.random(-6,6)))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(RW,{C0=cf(1.4,0.7,0.1)*angles(math.rad(-31.3+math.random(-6,6)),math.rad(-26.9+math.random(-6,6)),math.rad(12+math.random(-6,6)))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(Torso.Neck,{C0 =necko*angles(math.rad(-21.4+math.random(-6,6)),math.rad(0+math.random(-6,6)),math.rad(0+math.random(-6,6)))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
elseif Mode == 31 then
  	local Alpha,Easing,Direction,Repeat,Reverse,Delay = .1,'Linear','Out',0,false,0
  	TweenAnimate(RootJoint,{C0=cf(0-0.1*math.sin(sine/18),0+0.1*math.cos(sine/18),0)*angles(math.rad(0),math.rad(0),math.rad(0))*RootCF},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(LH,{C0=cf(-1+0.1*math.sin(sine/18),-1-0.1*math.cos(sine/18),0)*angles(math.rad(0),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(RH,{C0=cf(1+0.1*math.sin(sine/18),-1-0.1*math.cos(sine/18),0)*angles(math.rad(0),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(90),math.rad(0))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(LW,{C0=cf(-1.1,0.3+0.1*math.sin(sine/18),0.4)*angles(math.rad(-33.1),math.rad(-0.5),math.rad(37.5))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(RW,{C0=cf(1.2,0.3+0.1*math.sin(sine/18),0.4)*angles(math.rad(-34.1),math.rad(0),math.rad(-32.3))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(Torso.Neck,{C0 =necko*angles(math.rad(-0),math.rad(0),math.rad(-60.9))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
elseif Mode == 469 then
  	local Alpha,Easing,Direction,Repeat,Reverse,Delay = .1,'Linear','Out',0,false,0
  	TweenAnimate(RootJoint,{C0=cf(0,0+0.2*math.cos(sine/45),0)*angles(math.rad(-41.5+3*math.sin(sine/45)),math.rad(-29.9),math.rad(-13.4))*RootCF},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(LH,{C0=cf(-0.9,-0.6-0.2*math.cos(sine/45),-0.5)*angles(math.rad(34.2),math.rad(33.6),math.rad(-8.1))*angles(math.rad(0),math.rad(-90),math.rad(0))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(RH,{C0=cf(1.1,-1.2-0.2*math.cos(sine/45),-0.7)*angles(math.rad(-15.7),math.rad(-5.1),math.rad(8.8))*angles(math.rad(0),math.rad(90),math.rad(0))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(LW,{C0=cf(-1.4,0.4+0.2*math.sin(sine/45),-0.2)*angles(math.rad(47.6+6*math.cos(sine/32)),math.rad(-2.4+2*math.sin(sine/36)),math.rad(28.9+5*math.cos(sine/45)))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(RW,{C0=cf(1.6,0.5+0.2*math.sin(sine/45),0.2)*angles(math.rad(-30.8+2*math.sin(sine/52)),math.rad(-10.2+2*math.cos(sine/55)),math.rad(31.9-6*math.sin(sine/36)))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(Torso.Neck,{C0 =necko*angles(math.rad(-19.4+5*math.sin(sine/45)),math.rad(-3.7),math.rad(32.4))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
end
end
elseif torvel>2 and torvel<22 and hitfloor~=nil then
Anim="Walk"
TAnim(cam,{FieldOfView=80},0.3,"Quad","Out",0,false,0)
if attack==false then
  	local Alpha,Easing,Direction,Repeat,Reverse,Delay = .1,'Linear','Out',0,false,0
  	TweenAnimate(RootJoint,{C0=cf(0,0+0.1*math.cos(sine/4),0)*angles(math.rad(0-20*Vec.Z+3*math.cos(sine/4)),math.rad(0),math.rad(0-10*Vec.X))*RootCF},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(LH,{C0=cf(-1+0.2*math.sin(sine/8)*Vec.X,-1+0.3*math.cos(sine/8),-0.4*math.sin(sine/8)*Vec.Z)*angles(math.rad(1+40*math.cos(sine/8)*Vec.Z),math.rad(0),math.rad(0+20*Vec.X*math.sin(sine/8)))*angles(math.rad(0),math.rad(-90),math.rad(0))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(RH,{C0=cf(1-0.2*math.sin(sine/8)*Vec.X,-1-0.3*math.cos(sine/8),0.4*math.sin(sine/8)*Vec.Z)*angles(math.rad(-1-40*math.cos(sine/8)*Vec.Z),math.rad(0),math.rad(0-20*Vec.X*math.sin(sine/8)))*angles(math.rad(0),math.rad(90),math.rad(0))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(LW,{C0=cf(-1.5,0.5,0+0.2*math.sin(sine/8)*Vec.Z)*angles(math.rad(0-60*math.cos(sine/8)*Vec.Z-10*math.cos(sine/8)*Vec.X),math.rad(0),math.rad(0 + 6 * math.sin(sine/8)*Vec.X))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(RW,{C0=cf(1.5,0.5,0-0.2*math.sin(sine/8)*Vec.Z)*angles(math.rad(0+60*math.cos(sine/8)*Vec.Z+10*math.cos(sine/8)*Vec.X),math.rad(0),math.rad(0 - 6 * math.sin(sine/8)*Vec.X))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
  	TweenAnimate(Torso.Neck,{C0 =necko*angles(math.rad(0-20*Vec.Z+3*math.sin(sine/4)),math.rad(0),math.rad(0))},Alpha,Easing,Direction,Repeat,Reverse,Delay)
end
elseif torvel>=22 and hitfloor~=nil then
Anim="Run"
TAnim(cam,{FieldOfView=100},0.3,"Quad","Out",0,false,0)
if attack==false then
	if Mode == 1 or Mode == 6 or Mode == 69 or Mode == 7 or Mode == 5 or Mode == 2 then
  	local Alpha = .1
  	TweenAnimate(RootJoint,{C0=RootCF*cf(0 - 0.15 * math.cos(sine / 47),0,2.3 + 1 * math.cos(sine / 45))*angles(math.rad(55*Vec.Z),math.rad(-16*Vec.X - root.RotVelocity.Y),math.rad(2*Vec.X - root.RotVelocity.Y *4.5 + 3 * math.cos(sine / 47)))},Alpha,'Linear','Out',0,false,0)
  	TweenAnimate(LH,{C0=cf(-1,-1,0)*angles(math.rad(-20 - 8 * math.sin(sine/37)*Vec.Z),math.rad(0),math.rad(0))*angles(math.rad(0 - 4 * math.cos(sine/46)*Vec.Z),math.rad(-90),math.rad(6*Vec.X))},Alpha,'Linear','Out',0,false,0)
  	TweenAnimate(RH,{C0=cf(1,-0.3,-0.7)*angles(math.rad(-20 - 7 * math.cos(sine/46)*Vec.Z),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(90),math.rad(5*Vec.X))},Alpha,'Linear','Out',0,false,0)
  	TweenAnimate(LW,{C0=cf(-1.5,0.7,0.1)*angles(math.rad(-16.1*Vec.Z),math.rad(8.5),math.rad(-23.5- 5 * math.cos(sine/42)))},Alpha,'Linear','Out',0,false,0)
  	TweenAnimate(RW,{C0=cf(1.5,0.7,0)*angles(math.rad(-16.1*Vec.Z),math.rad(-11.1),math.rad(17.2- 6 * math.cos(sine/45)))},Alpha,'Linear','Out',0,false,0)
  	TweenAnimate(Torso.Neck,{C0 =necko*cf(0,0,0)*angles(math.rad(-55*Vec.Z),math.rad(5*Vec.X),math.rad(2*Vec.X))},Alpha,'Linear','Out',0,false,0)
	else
  	local Alpha = .1
  	TweenAnimate(RootJoint,{C0=RootCF*cf(0,-0.3,-0.05 + 0.15 * math.cos(sine / 3))*angles(math.rad(25 - 4 * math.cos(sine / 3)),math.rad(0 + root.RotVelocity.Y*1.5),math.rad(0 - root.RotVelocity.Y - 1 * math.cos(sine / 6)))},Alpha,'Linear','Out',0,false,0)
  	TweenAnimate(LH,{C0=cf(-1, -0.8 + 1 * math.cos(sine / 7) / 2, -0.6 * math.sin(sine / 7)) * angles(math.rad(-15 + 50 * math.cos(sine / 7)) + ll.RotVelocity.Y / 75 + math.sin(sine / 7) / 2.5, math.rad(-90 - 10 * math.cos(sine / 7)), math.rad(0)) * angles(math.rad(0 - 2 * math.cos(sine / 7)), math.rad(0), math.rad(0))},Alpha,'Linear','Out',0,false,0)
  	TweenAnimate(RH,{C0=cf(1, -0.8 - 1 * math.cos(sine / 7) / 2, 0.6 * math.sin(sine / 7))  * angles(math.rad(-15 - 50 * math.cos(sine / 7)) - rl.RotVelocity.Y / 75 + -math.sin(sine / 7) / 2.5, math.rad(90 - 10 * math.cos(sine / 7)), math.rad(0)) * angles(math.rad(0 + 2 * math.cos(sine / 7)), math.rad(0), math.rad(0))},Alpha,'Linear','Out',0,false,0)
  	TweenAnimate(LW,{C0=cf(-1.5, 0.5 + 0.05 * math.sin(sine / 7), 0 + 0.5 * math.cos(sine / 7)) * angles(math.rad(-100)  * math.cos(sine / 7) , math.rad(8 * math.cos(sine / 7)) ,   math.rad(0) + la.RotVelocity.Y/75)},Alpha,'Linear','Out',0,false,0)
  	TweenAnimate(RW,{C0=cf(1.5, 0.5 + 0.05 * math.sin(sine / 7), 0 - 0.5 * math.cos(sine / 7)) * angles(math.rad(100)  * math.cos(sine / 7) , math.rad(-8 * math.cos(sine / 7)) ,   math.rad(0) - ra.RotVelocity.Y/75)},Alpha,'Linear','Out',0,false,0)
  	TweenAnimate(Torso.Neck,{C0 =necko*angles(math.rad(-6 + 2 * math.cos(sine / 3)),math.rad(0 + root.RotVelocity.Y*1.5),math.rad(0 - hed.RotVelocity.Y*1.5 + 1 * math.cos(sine / 6)))},Alpha,'Linear','Out',0,false,0)
end
end
end
end
end
end)
